
Protect_app.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00005890  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         000000d4  00800060  00005890  00005924  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000004aa  00800134  00800134  000059f8  2**0
                  ALLOC
  3 .stab         000069cc  00000000  00000000  000059f8  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      000034d5  00000000  00000000  0000c3c4  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000140  00000000  00000000  0000f899  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 00000170  00000000  00000000  0000f9d9  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00001c49  00000000  00000000  0000fb49  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00000eeb  00000000  00000000  00011792  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00000dad  00000000  00000000  0001267d  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000160  00000000  00000000  0001342c  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    0000028d  00000000  00000000  0001358c  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    000007ce  00000000  00000000  00013819  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000050  00000000  00000000  00013fe7  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 f1 0c 	jmp	0x19e2	; 0x19e2 <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	11 e0       	ldi	r17, 0x01	; 1
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	e0 e9       	ldi	r30, 0x90	; 144
      68:	f8 e5       	ldi	r31, 0x58	; 88
      6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
      70:	a4 33       	cpi	r26, 0x34	; 52
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
      76:	15 e0       	ldi	r17, 0x05	; 5
      78:	a4 e3       	ldi	r26, 0x34	; 52
      7a:	b1 e0       	ldi	r27, 0x01	; 1
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	ae 3d       	cpi	r26, 0xDE	; 222
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 8b 28 	call	0x5116	; 0x5116 <main>
      8a:	0c 94 46 2c 	jmp	0x588c	; 0x588c <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <__fixunssfsi>:
      92:	ef 92       	push	r14
      94:	ff 92       	push	r15
      96:	0f 93       	push	r16
      98:	1f 93       	push	r17
      9a:	7b 01       	movw	r14, r22
      9c:	8c 01       	movw	r16, r24
      9e:	20 e0       	ldi	r18, 0x00	; 0
      a0:	30 e0       	ldi	r19, 0x00	; 0
      a2:	40 e0       	ldi	r20, 0x00	; 0
      a4:	5f e4       	ldi	r21, 0x4F	; 79
      a6:	0e 94 49 03 	call	0x692	; 0x692 <__gesf2>
      aa:	88 23       	and	r24, r24
      ac:	8c f0       	brlt	.+34     	; 0xd0 <__fixunssfsi+0x3e>
      ae:	c8 01       	movw	r24, r16
      b0:	b7 01       	movw	r22, r14
      b2:	20 e0       	ldi	r18, 0x00	; 0
      b4:	30 e0       	ldi	r19, 0x00	; 0
      b6:	40 e0       	ldi	r20, 0x00	; 0
      b8:	5f e4       	ldi	r21, 0x4F	; 79
      ba:	0e 94 c1 01 	call	0x382	; 0x382 <__subsf3>
      be:	0e 94 a9 03 	call	0x752	; 0x752 <__fixsfsi>
      c2:	9b 01       	movw	r18, r22
      c4:	ac 01       	movw	r20, r24
      c6:	20 50       	subi	r18, 0x00	; 0
      c8:	30 40       	sbci	r19, 0x00	; 0
      ca:	40 40       	sbci	r20, 0x00	; 0
      cc:	50 48       	sbci	r21, 0x80	; 128
      ce:	06 c0       	rjmp	.+12     	; 0xdc <__fixunssfsi+0x4a>
      d0:	c8 01       	movw	r24, r16
      d2:	b7 01       	movw	r22, r14
      d4:	0e 94 a9 03 	call	0x752	; 0x752 <__fixsfsi>
      d8:	9b 01       	movw	r18, r22
      da:	ac 01       	movw	r20, r24
      dc:	b9 01       	movw	r22, r18
      de:	ca 01       	movw	r24, r20
      e0:	1f 91       	pop	r17
      e2:	0f 91       	pop	r16
      e4:	ff 90       	pop	r15
      e6:	ef 90       	pop	r14
      e8:	08 95       	ret

000000ea <_fpadd_parts>:
      ea:	a0 e0       	ldi	r26, 0x00	; 0
      ec:	b0 e0       	ldi	r27, 0x00	; 0
      ee:	eb e7       	ldi	r30, 0x7B	; 123
      f0:	f0 e0       	ldi	r31, 0x00	; 0
      f2:	0c 94 f0 2b 	jmp	0x57e0	; 0x57e0 <__prologue_saves__>
      f6:	dc 01       	movw	r26, r24
      f8:	2b 01       	movw	r4, r22
      fa:	fa 01       	movw	r30, r20
      fc:	9c 91       	ld	r25, X
      fe:	92 30       	cpi	r25, 0x02	; 2
     100:	08 f4       	brcc	.+2      	; 0x104 <_fpadd_parts+0x1a>
     102:	39 c1       	rjmp	.+626    	; 0x376 <_fpadd_parts+0x28c>
     104:	eb 01       	movw	r28, r22
     106:	88 81       	ld	r24, Y
     108:	82 30       	cpi	r24, 0x02	; 2
     10a:	08 f4       	brcc	.+2      	; 0x10e <_fpadd_parts+0x24>
     10c:	33 c1       	rjmp	.+614    	; 0x374 <_fpadd_parts+0x28a>
     10e:	94 30       	cpi	r25, 0x04	; 4
     110:	69 f4       	brne	.+26     	; 0x12c <_fpadd_parts+0x42>
     112:	84 30       	cpi	r24, 0x04	; 4
     114:	09 f0       	breq	.+2      	; 0x118 <_fpadd_parts+0x2e>
     116:	2f c1       	rjmp	.+606    	; 0x376 <_fpadd_parts+0x28c>
     118:	11 96       	adiw	r26, 0x01	; 1
     11a:	9c 91       	ld	r25, X
     11c:	11 97       	sbiw	r26, 0x01	; 1
     11e:	89 81       	ldd	r24, Y+1	; 0x01
     120:	98 17       	cp	r25, r24
     122:	09 f4       	brne	.+2      	; 0x126 <_fpadd_parts+0x3c>
     124:	28 c1       	rjmp	.+592    	; 0x376 <_fpadd_parts+0x28c>
     126:	aa e1       	ldi	r26, 0x1A	; 26
     128:	b1 e0       	ldi	r27, 0x01	; 1
     12a:	25 c1       	rjmp	.+586    	; 0x376 <_fpadd_parts+0x28c>
     12c:	84 30       	cpi	r24, 0x04	; 4
     12e:	09 f4       	brne	.+2      	; 0x132 <_fpadd_parts+0x48>
     130:	21 c1       	rjmp	.+578    	; 0x374 <_fpadd_parts+0x28a>
     132:	82 30       	cpi	r24, 0x02	; 2
     134:	a9 f4       	brne	.+42     	; 0x160 <_fpadd_parts+0x76>
     136:	92 30       	cpi	r25, 0x02	; 2
     138:	09 f0       	breq	.+2      	; 0x13c <_fpadd_parts+0x52>
     13a:	1d c1       	rjmp	.+570    	; 0x376 <_fpadd_parts+0x28c>
     13c:	9a 01       	movw	r18, r20
     13e:	ad 01       	movw	r20, r26
     140:	88 e0       	ldi	r24, 0x08	; 8
     142:	ea 01       	movw	r28, r20
     144:	09 90       	ld	r0, Y+
     146:	ae 01       	movw	r20, r28
     148:	e9 01       	movw	r28, r18
     14a:	09 92       	st	Y+, r0
     14c:	9e 01       	movw	r18, r28
     14e:	81 50       	subi	r24, 0x01	; 1
     150:	c1 f7       	brne	.-16     	; 0x142 <_fpadd_parts+0x58>
     152:	e2 01       	movw	r28, r4
     154:	89 81       	ldd	r24, Y+1	; 0x01
     156:	11 96       	adiw	r26, 0x01	; 1
     158:	9c 91       	ld	r25, X
     15a:	89 23       	and	r24, r25
     15c:	81 83       	std	Z+1, r24	; 0x01
     15e:	08 c1       	rjmp	.+528    	; 0x370 <_fpadd_parts+0x286>
     160:	92 30       	cpi	r25, 0x02	; 2
     162:	09 f4       	brne	.+2      	; 0x166 <_fpadd_parts+0x7c>
     164:	07 c1       	rjmp	.+526    	; 0x374 <_fpadd_parts+0x28a>
     166:	12 96       	adiw	r26, 0x02	; 2
     168:	2d 90       	ld	r2, X+
     16a:	3c 90       	ld	r3, X
     16c:	13 97       	sbiw	r26, 0x03	; 3
     16e:	eb 01       	movw	r28, r22
     170:	8a 81       	ldd	r24, Y+2	; 0x02
     172:	9b 81       	ldd	r25, Y+3	; 0x03
     174:	14 96       	adiw	r26, 0x04	; 4
     176:	ad 90       	ld	r10, X+
     178:	bd 90       	ld	r11, X+
     17a:	cd 90       	ld	r12, X+
     17c:	dc 90       	ld	r13, X
     17e:	17 97       	sbiw	r26, 0x07	; 7
     180:	ec 80       	ldd	r14, Y+4	; 0x04
     182:	fd 80       	ldd	r15, Y+5	; 0x05
     184:	0e 81       	ldd	r16, Y+6	; 0x06
     186:	1f 81       	ldd	r17, Y+7	; 0x07
     188:	91 01       	movw	r18, r2
     18a:	28 1b       	sub	r18, r24
     18c:	39 0b       	sbc	r19, r25
     18e:	b9 01       	movw	r22, r18
     190:	37 ff       	sbrs	r19, 7
     192:	04 c0       	rjmp	.+8      	; 0x19c <_fpadd_parts+0xb2>
     194:	66 27       	eor	r22, r22
     196:	77 27       	eor	r23, r23
     198:	62 1b       	sub	r22, r18
     19a:	73 0b       	sbc	r23, r19
     19c:	60 32       	cpi	r22, 0x20	; 32
     19e:	71 05       	cpc	r23, r1
     1a0:	0c f0       	brlt	.+2      	; 0x1a4 <_fpadd_parts+0xba>
     1a2:	61 c0       	rjmp	.+194    	; 0x266 <_fpadd_parts+0x17c>
     1a4:	12 16       	cp	r1, r18
     1a6:	13 06       	cpc	r1, r19
     1a8:	6c f5       	brge	.+90     	; 0x204 <_fpadd_parts+0x11a>
     1aa:	37 01       	movw	r6, r14
     1ac:	48 01       	movw	r8, r16
     1ae:	06 2e       	mov	r0, r22
     1b0:	04 c0       	rjmp	.+8      	; 0x1ba <_fpadd_parts+0xd0>
     1b2:	96 94       	lsr	r9
     1b4:	87 94       	ror	r8
     1b6:	77 94       	ror	r7
     1b8:	67 94       	ror	r6
     1ba:	0a 94       	dec	r0
     1bc:	d2 f7       	brpl	.-12     	; 0x1b2 <_fpadd_parts+0xc8>
     1be:	21 e0       	ldi	r18, 0x01	; 1
     1c0:	30 e0       	ldi	r19, 0x00	; 0
     1c2:	40 e0       	ldi	r20, 0x00	; 0
     1c4:	50 e0       	ldi	r21, 0x00	; 0
     1c6:	04 c0       	rjmp	.+8      	; 0x1d0 <_fpadd_parts+0xe6>
     1c8:	22 0f       	add	r18, r18
     1ca:	33 1f       	adc	r19, r19
     1cc:	44 1f       	adc	r20, r20
     1ce:	55 1f       	adc	r21, r21
     1d0:	6a 95       	dec	r22
     1d2:	d2 f7       	brpl	.-12     	; 0x1c8 <_fpadd_parts+0xde>
     1d4:	21 50       	subi	r18, 0x01	; 1
     1d6:	30 40       	sbci	r19, 0x00	; 0
     1d8:	40 40       	sbci	r20, 0x00	; 0
     1da:	50 40       	sbci	r21, 0x00	; 0
     1dc:	2e 21       	and	r18, r14
     1de:	3f 21       	and	r19, r15
     1e0:	40 23       	and	r20, r16
     1e2:	51 23       	and	r21, r17
     1e4:	21 15       	cp	r18, r1
     1e6:	31 05       	cpc	r19, r1
     1e8:	41 05       	cpc	r20, r1
     1ea:	51 05       	cpc	r21, r1
     1ec:	21 f0       	breq	.+8      	; 0x1f6 <_fpadd_parts+0x10c>
     1ee:	21 e0       	ldi	r18, 0x01	; 1
     1f0:	30 e0       	ldi	r19, 0x00	; 0
     1f2:	40 e0       	ldi	r20, 0x00	; 0
     1f4:	50 e0       	ldi	r21, 0x00	; 0
     1f6:	79 01       	movw	r14, r18
     1f8:	8a 01       	movw	r16, r20
     1fa:	e6 28       	or	r14, r6
     1fc:	f7 28       	or	r15, r7
     1fe:	08 29       	or	r16, r8
     200:	19 29       	or	r17, r9
     202:	3c c0       	rjmp	.+120    	; 0x27c <_fpadd_parts+0x192>
     204:	23 2b       	or	r18, r19
     206:	d1 f1       	breq	.+116    	; 0x27c <_fpadd_parts+0x192>
     208:	26 0e       	add	r2, r22
     20a:	37 1e       	adc	r3, r23
     20c:	35 01       	movw	r6, r10
     20e:	46 01       	movw	r8, r12
     210:	06 2e       	mov	r0, r22
     212:	04 c0       	rjmp	.+8      	; 0x21c <_fpadd_parts+0x132>
     214:	96 94       	lsr	r9
     216:	87 94       	ror	r8
     218:	77 94       	ror	r7
     21a:	67 94       	ror	r6
     21c:	0a 94       	dec	r0
     21e:	d2 f7       	brpl	.-12     	; 0x214 <_fpadd_parts+0x12a>
     220:	21 e0       	ldi	r18, 0x01	; 1
     222:	30 e0       	ldi	r19, 0x00	; 0
     224:	40 e0       	ldi	r20, 0x00	; 0
     226:	50 e0       	ldi	r21, 0x00	; 0
     228:	04 c0       	rjmp	.+8      	; 0x232 <_fpadd_parts+0x148>
     22a:	22 0f       	add	r18, r18
     22c:	33 1f       	adc	r19, r19
     22e:	44 1f       	adc	r20, r20
     230:	55 1f       	adc	r21, r21
     232:	6a 95       	dec	r22
     234:	d2 f7       	brpl	.-12     	; 0x22a <_fpadd_parts+0x140>
     236:	21 50       	subi	r18, 0x01	; 1
     238:	30 40       	sbci	r19, 0x00	; 0
     23a:	40 40       	sbci	r20, 0x00	; 0
     23c:	50 40       	sbci	r21, 0x00	; 0
     23e:	2a 21       	and	r18, r10
     240:	3b 21       	and	r19, r11
     242:	4c 21       	and	r20, r12
     244:	5d 21       	and	r21, r13
     246:	21 15       	cp	r18, r1
     248:	31 05       	cpc	r19, r1
     24a:	41 05       	cpc	r20, r1
     24c:	51 05       	cpc	r21, r1
     24e:	21 f0       	breq	.+8      	; 0x258 <_fpadd_parts+0x16e>
     250:	21 e0       	ldi	r18, 0x01	; 1
     252:	30 e0       	ldi	r19, 0x00	; 0
     254:	40 e0       	ldi	r20, 0x00	; 0
     256:	50 e0       	ldi	r21, 0x00	; 0
     258:	59 01       	movw	r10, r18
     25a:	6a 01       	movw	r12, r20
     25c:	a6 28       	or	r10, r6
     25e:	b7 28       	or	r11, r7
     260:	c8 28       	or	r12, r8
     262:	d9 28       	or	r13, r9
     264:	0b c0       	rjmp	.+22     	; 0x27c <_fpadd_parts+0x192>
     266:	82 15       	cp	r24, r2
     268:	93 05       	cpc	r25, r3
     26a:	2c f0       	brlt	.+10     	; 0x276 <_fpadd_parts+0x18c>
     26c:	1c 01       	movw	r2, r24
     26e:	aa 24       	eor	r10, r10
     270:	bb 24       	eor	r11, r11
     272:	65 01       	movw	r12, r10
     274:	03 c0       	rjmp	.+6      	; 0x27c <_fpadd_parts+0x192>
     276:	ee 24       	eor	r14, r14
     278:	ff 24       	eor	r15, r15
     27a:	87 01       	movw	r16, r14
     27c:	11 96       	adiw	r26, 0x01	; 1
     27e:	9c 91       	ld	r25, X
     280:	d2 01       	movw	r26, r4
     282:	11 96       	adiw	r26, 0x01	; 1
     284:	8c 91       	ld	r24, X
     286:	98 17       	cp	r25, r24
     288:	09 f4       	brne	.+2      	; 0x28c <_fpadd_parts+0x1a2>
     28a:	45 c0       	rjmp	.+138    	; 0x316 <_fpadd_parts+0x22c>
     28c:	99 23       	and	r25, r25
     28e:	39 f0       	breq	.+14     	; 0x29e <_fpadd_parts+0x1b4>
     290:	a8 01       	movw	r20, r16
     292:	97 01       	movw	r18, r14
     294:	2a 19       	sub	r18, r10
     296:	3b 09       	sbc	r19, r11
     298:	4c 09       	sbc	r20, r12
     29a:	5d 09       	sbc	r21, r13
     29c:	06 c0       	rjmp	.+12     	; 0x2aa <_fpadd_parts+0x1c0>
     29e:	a6 01       	movw	r20, r12
     2a0:	95 01       	movw	r18, r10
     2a2:	2e 19       	sub	r18, r14
     2a4:	3f 09       	sbc	r19, r15
     2a6:	40 0b       	sbc	r20, r16
     2a8:	51 0b       	sbc	r21, r17
     2aa:	57 fd       	sbrc	r21, 7
     2ac:	08 c0       	rjmp	.+16     	; 0x2be <_fpadd_parts+0x1d4>
     2ae:	11 82       	std	Z+1, r1	; 0x01
     2b0:	33 82       	std	Z+3, r3	; 0x03
     2b2:	22 82       	std	Z+2, r2	; 0x02
     2b4:	24 83       	std	Z+4, r18	; 0x04
     2b6:	35 83       	std	Z+5, r19	; 0x05
     2b8:	46 83       	std	Z+6, r20	; 0x06
     2ba:	57 83       	std	Z+7, r21	; 0x07
     2bc:	1d c0       	rjmp	.+58     	; 0x2f8 <_fpadd_parts+0x20e>
     2be:	81 e0       	ldi	r24, 0x01	; 1
     2c0:	81 83       	std	Z+1, r24	; 0x01
     2c2:	33 82       	std	Z+3, r3	; 0x03
     2c4:	22 82       	std	Z+2, r2	; 0x02
     2c6:	88 27       	eor	r24, r24
     2c8:	99 27       	eor	r25, r25
     2ca:	dc 01       	movw	r26, r24
     2cc:	82 1b       	sub	r24, r18
     2ce:	93 0b       	sbc	r25, r19
     2d0:	a4 0b       	sbc	r26, r20
     2d2:	b5 0b       	sbc	r27, r21
     2d4:	84 83       	std	Z+4, r24	; 0x04
     2d6:	95 83       	std	Z+5, r25	; 0x05
     2d8:	a6 83       	std	Z+6, r26	; 0x06
     2da:	b7 83       	std	Z+7, r27	; 0x07
     2dc:	0d c0       	rjmp	.+26     	; 0x2f8 <_fpadd_parts+0x20e>
     2de:	22 0f       	add	r18, r18
     2e0:	33 1f       	adc	r19, r19
     2e2:	44 1f       	adc	r20, r20
     2e4:	55 1f       	adc	r21, r21
     2e6:	24 83       	std	Z+4, r18	; 0x04
     2e8:	35 83       	std	Z+5, r19	; 0x05
     2ea:	46 83       	std	Z+6, r20	; 0x06
     2ec:	57 83       	std	Z+7, r21	; 0x07
     2ee:	82 81       	ldd	r24, Z+2	; 0x02
     2f0:	93 81       	ldd	r25, Z+3	; 0x03
     2f2:	01 97       	sbiw	r24, 0x01	; 1
     2f4:	93 83       	std	Z+3, r25	; 0x03
     2f6:	82 83       	std	Z+2, r24	; 0x02
     2f8:	24 81       	ldd	r18, Z+4	; 0x04
     2fa:	35 81       	ldd	r19, Z+5	; 0x05
     2fc:	46 81       	ldd	r20, Z+6	; 0x06
     2fe:	57 81       	ldd	r21, Z+7	; 0x07
     300:	da 01       	movw	r26, r20
     302:	c9 01       	movw	r24, r18
     304:	01 97       	sbiw	r24, 0x01	; 1
     306:	a1 09       	sbc	r26, r1
     308:	b1 09       	sbc	r27, r1
     30a:	8f 5f       	subi	r24, 0xFF	; 255
     30c:	9f 4f       	sbci	r25, 0xFF	; 255
     30e:	af 4f       	sbci	r26, 0xFF	; 255
     310:	bf 43       	sbci	r27, 0x3F	; 63
     312:	28 f3       	brcs	.-54     	; 0x2de <_fpadd_parts+0x1f4>
     314:	0b c0       	rjmp	.+22     	; 0x32c <_fpadd_parts+0x242>
     316:	91 83       	std	Z+1, r25	; 0x01
     318:	33 82       	std	Z+3, r3	; 0x03
     31a:	22 82       	std	Z+2, r2	; 0x02
     31c:	ea 0c       	add	r14, r10
     31e:	fb 1c       	adc	r15, r11
     320:	0c 1d       	adc	r16, r12
     322:	1d 1d       	adc	r17, r13
     324:	e4 82       	std	Z+4, r14	; 0x04
     326:	f5 82       	std	Z+5, r15	; 0x05
     328:	06 83       	std	Z+6, r16	; 0x06
     32a:	17 83       	std	Z+7, r17	; 0x07
     32c:	83 e0       	ldi	r24, 0x03	; 3
     32e:	80 83       	st	Z, r24
     330:	24 81       	ldd	r18, Z+4	; 0x04
     332:	35 81       	ldd	r19, Z+5	; 0x05
     334:	46 81       	ldd	r20, Z+6	; 0x06
     336:	57 81       	ldd	r21, Z+7	; 0x07
     338:	57 ff       	sbrs	r21, 7
     33a:	1a c0       	rjmp	.+52     	; 0x370 <_fpadd_parts+0x286>
     33c:	c9 01       	movw	r24, r18
     33e:	aa 27       	eor	r26, r26
     340:	97 fd       	sbrc	r25, 7
     342:	a0 95       	com	r26
     344:	ba 2f       	mov	r27, r26
     346:	81 70       	andi	r24, 0x01	; 1
     348:	90 70       	andi	r25, 0x00	; 0
     34a:	a0 70       	andi	r26, 0x00	; 0
     34c:	b0 70       	andi	r27, 0x00	; 0
     34e:	56 95       	lsr	r21
     350:	47 95       	ror	r20
     352:	37 95       	ror	r19
     354:	27 95       	ror	r18
     356:	82 2b       	or	r24, r18
     358:	93 2b       	or	r25, r19
     35a:	a4 2b       	or	r26, r20
     35c:	b5 2b       	or	r27, r21
     35e:	84 83       	std	Z+4, r24	; 0x04
     360:	95 83       	std	Z+5, r25	; 0x05
     362:	a6 83       	std	Z+6, r26	; 0x06
     364:	b7 83       	std	Z+7, r27	; 0x07
     366:	82 81       	ldd	r24, Z+2	; 0x02
     368:	93 81       	ldd	r25, Z+3	; 0x03
     36a:	01 96       	adiw	r24, 0x01	; 1
     36c:	93 83       	std	Z+3, r25	; 0x03
     36e:	82 83       	std	Z+2, r24	; 0x02
     370:	df 01       	movw	r26, r30
     372:	01 c0       	rjmp	.+2      	; 0x376 <_fpadd_parts+0x28c>
     374:	d2 01       	movw	r26, r4
     376:	cd 01       	movw	r24, r26
     378:	cd b7       	in	r28, 0x3d	; 61
     37a:	de b7       	in	r29, 0x3e	; 62
     37c:	e2 e1       	ldi	r30, 0x12	; 18
     37e:	0c 94 0c 2c 	jmp	0x5818	; 0x5818 <__epilogue_restores__>

00000382 <__subsf3>:
     382:	a0 e2       	ldi	r26, 0x20	; 32
     384:	b0 e0       	ldi	r27, 0x00	; 0
     386:	e7 ec       	ldi	r30, 0xC7	; 199
     388:	f1 e0       	ldi	r31, 0x01	; 1
     38a:	0c 94 fc 2b 	jmp	0x57f8	; 0x57f8 <__prologue_saves__+0x18>
     38e:	69 83       	std	Y+1, r22	; 0x01
     390:	7a 83       	std	Y+2, r23	; 0x02
     392:	8b 83       	std	Y+3, r24	; 0x03
     394:	9c 83       	std	Y+4, r25	; 0x04
     396:	2d 83       	std	Y+5, r18	; 0x05
     398:	3e 83       	std	Y+6, r19	; 0x06
     39a:	4f 83       	std	Y+7, r20	; 0x07
     39c:	58 87       	std	Y+8, r21	; 0x08
     39e:	e9 e0       	ldi	r30, 0x09	; 9
     3a0:	ee 2e       	mov	r14, r30
     3a2:	f1 2c       	mov	r15, r1
     3a4:	ec 0e       	add	r14, r28
     3a6:	fd 1e       	adc	r15, r29
     3a8:	ce 01       	movw	r24, r28
     3aa:	01 96       	adiw	r24, 0x01	; 1
     3ac:	b7 01       	movw	r22, r14
     3ae:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     3b2:	8e 01       	movw	r16, r28
     3b4:	0f 5e       	subi	r16, 0xEF	; 239
     3b6:	1f 4f       	sbci	r17, 0xFF	; 255
     3b8:	ce 01       	movw	r24, r28
     3ba:	05 96       	adiw	r24, 0x05	; 5
     3bc:	b8 01       	movw	r22, r16
     3be:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     3c2:	8a 89       	ldd	r24, Y+18	; 0x12
     3c4:	91 e0       	ldi	r25, 0x01	; 1
     3c6:	89 27       	eor	r24, r25
     3c8:	8a 8b       	std	Y+18, r24	; 0x12
     3ca:	c7 01       	movw	r24, r14
     3cc:	b8 01       	movw	r22, r16
     3ce:	ae 01       	movw	r20, r28
     3d0:	47 5e       	subi	r20, 0xE7	; 231
     3d2:	5f 4f       	sbci	r21, 0xFF	; 255
     3d4:	0e 94 75 00 	call	0xea	; 0xea <_fpadd_parts>
     3d8:	0e 94 fd 03 	call	0x7fa	; 0x7fa <__pack_f>
     3dc:	a0 96       	adiw	r28, 0x20	; 32
     3de:	e6 e0       	ldi	r30, 0x06	; 6
     3e0:	0c 94 18 2c 	jmp	0x5830	; 0x5830 <__epilogue_restores__+0x18>

000003e4 <__addsf3>:
     3e4:	a0 e2       	ldi	r26, 0x20	; 32
     3e6:	b0 e0       	ldi	r27, 0x00	; 0
     3e8:	e8 ef       	ldi	r30, 0xF8	; 248
     3ea:	f1 e0       	ldi	r31, 0x01	; 1
     3ec:	0c 94 fc 2b 	jmp	0x57f8	; 0x57f8 <__prologue_saves__+0x18>
     3f0:	69 83       	std	Y+1, r22	; 0x01
     3f2:	7a 83       	std	Y+2, r23	; 0x02
     3f4:	8b 83       	std	Y+3, r24	; 0x03
     3f6:	9c 83       	std	Y+4, r25	; 0x04
     3f8:	2d 83       	std	Y+5, r18	; 0x05
     3fa:	3e 83       	std	Y+6, r19	; 0x06
     3fc:	4f 83       	std	Y+7, r20	; 0x07
     3fe:	58 87       	std	Y+8, r21	; 0x08
     400:	f9 e0       	ldi	r31, 0x09	; 9
     402:	ef 2e       	mov	r14, r31
     404:	f1 2c       	mov	r15, r1
     406:	ec 0e       	add	r14, r28
     408:	fd 1e       	adc	r15, r29
     40a:	ce 01       	movw	r24, r28
     40c:	01 96       	adiw	r24, 0x01	; 1
     40e:	b7 01       	movw	r22, r14
     410:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     414:	8e 01       	movw	r16, r28
     416:	0f 5e       	subi	r16, 0xEF	; 239
     418:	1f 4f       	sbci	r17, 0xFF	; 255
     41a:	ce 01       	movw	r24, r28
     41c:	05 96       	adiw	r24, 0x05	; 5
     41e:	b8 01       	movw	r22, r16
     420:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     424:	c7 01       	movw	r24, r14
     426:	b8 01       	movw	r22, r16
     428:	ae 01       	movw	r20, r28
     42a:	47 5e       	subi	r20, 0xE7	; 231
     42c:	5f 4f       	sbci	r21, 0xFF	; 255
     42e:	0e 94 75 00 	call	0xea	; 0xea <_fpadd_parts>
     432:	0e 94 fd 03 	call	0x7fa	; 0x7fa <__pack_f>
     436:	a0 96       	adiw	r28, 0x20	; 32
     438:	e6 e0       	ldi	r30, 0x06	; 6
     43a:	0c 94 18 2c 	jmp	0x5830	; 0x5830 <__epilogue_restores__+0x18>

0000043e <__mulsf3>:
     43e:	a0 e2       	ldi	r26, 0x20	; 32
     440:	b0 e0       	ldi	r27, 0x00	; 0
     442:	e5 e2       	ldi	r30, 0x25	; 37
     444:	f2 e0       	ldi	r31, 0x02	; 2
     446:	0c 94 f0 2b 	jmp	0x57e0	; 0x57e0 <__prologue_saves__>
     44a:	69 83       	std	Y+1, r22	; 0x01
     44c:	7a 83       	std	Y+2, r23	; 0x02
     44e:	8b 83       	std	Y+3, r24	; 0x03
     450:	9c 83       	std	Y+4, r25	; 0x04
     452:	2d 83       	std	Y+5, r18	; 0x05
     454:	3e 83       	std	Y+6, r19	; 0x06
     456:	4f 83       	std	Y+7, r20	; 0x07
     458:	58 87       	std	Y+8, r21	; 0x08
     45a:	ce 01       	movw	r24, r28
     45c:	01 96       	adiw	r24, 0x01	; 1
     45e:	be 01       	movw	r22, r28
     460:	67 5f       	subi	r22, 0xF7	; 247
     462:	7f 4f       	sbci	r23, 0xFF	; 255
     464:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     468:	ce 01       	movw	r24, r28
     46a:	05 96       	adiw	r24, 0x05	; 5
     46c:	be 01       	movw	r22, r28
     46e:	6f 5e       	subi	r22, 0xEF	; 239
     470:	7f 4f       	sbci	r23, 0xFF	; 255
     472:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     476:	99 85       	ldd	r25, Y+9	; 0x09
     478:	92 30       	cpi	r25, 0x02	; 2
     47a:	88 f0       	brcs	.+34     	; 0x49e <__mulsf3+0x60>
     47c:	89 89       	ldd	r24, Y+17	; 0x11
     47e:	82 30       	cpi	r24, 0x02	; 2
     480:	c8 f0       	brcs	.+50     	; 0x4b4 <__mulsf3+0x76>
     482:	94 30       	cpi	r25, 0x04	; 4
     484:	19 f4       	brne	.+6      	; 0x48c <__mulsf3+0x4e>
     486:	82 30       	cpi	r24, 0x02	; 2
     488:	51 f4       	brne	.+20     	; 0x49e <__mulsf3+0x60>
     48a:	04 c0       	rjmp	.+8      	; 0x494 <__mulsf3+0x56>
     48c:	84 30       	cpi	r24, 0x04	; 4
     48e:	29 f4       	brne	.+10     	; 0x49a <__mulsf3+0x5c>
     490:	92 30       	cpi	r25, 0x02	; 2
     492:	81 f4       	brne	.+32     	; 0x4b4 <__mulsf3+0x76>
     494:	8a e1       	ldi	r24, 0x1A	; 26
     496:	91 e0       	ldi	r25, 0x01	; 1
     498:	c6 c0       	rjmp	.+396    	; 0x626 <__mulsf3+0x1e8>
     49a:	92 30       	cpi	r25, 0x02	; 2
     49c:	49 f4       	brne	.+18     	; 0x4b0 <__mulsf3+0x72>
     49e:	20 e0       	ldi	r18, 0x00	; 0
     4a0:	9a 85       	ldd	r25, Y+10	; 0x0a
     4a2:	8a 89       	ldd	r24, Y+18	; 0x12
     4a4:	98 13       	cpse	r25, r24
     4a6:	21 e0       	ldi	r18, 0x01	; 1
     4a8:	2a 87       	std	Y+10, r18	; 0x0a
     4aa:	ce 01       	movw	r24, r28
     4ac:	09 96       	adiw	r24, 0x09	; 9
     4ae:	bb c0       	rjmp	.+374    	; 0x626 <__mulsf3+0x1e8>
     4b0:	82 30       	cpi	r24, 0x02	; 2
     4b2:	49 f4       	brne	.+18     	; 0x4c6 <__mulsf3+0x88>
     4b4:	20 e0       	ldi	r18, 0x00	; 0
     4b6:	9a 85       	ldd	r25, Y+10	; 0x0a
     4b8:	8a 89       	ldd	r24, Y+18	; 0x12
     4ba:	98 13       	cpse	r25, r24
     4bc:	21 e0       	ldi	r18, 0x01	; 1
     4be:	2a 8b       	std	Y+18, r18	; 0x12
     4c0:	ce 01       	movw	r24, r28
     4c2:	41 96       	adiw	r24, 0x11	; 17
     4c4:	b0 c0       	rjmp	.+352    	; 0x626 <__mulsf3+0x1e8>
     4c6:	2d 84       	ldd	r2, Y+13	; 0x0d
     4c8:	3e 84       	ldd	r3, Y+14	; 0x0e
     4ca:	4f 84       	ldd	r4, Y+15	; 0x0f
     4cc:	58 88       	ldd	r5, Y+16	; 0x10
     4ce:	6d 88       	ldd	r6, Y+21	; 0x15
     4d0:	7e 88       	ldd	r7, Y+22	; 0x16
     4d2:	8f 88       	ldd	r8, Y+23	; 0x17
     4d4:	98 8c       	ldd	r9, Y+24	; 0x18
     4d6:	ee 24       	eor	r14, r14
     4d8:	ff 24       	eor	r15, r15
     4da:	87 01       	movw	r16, r14
     4dc:	aa 24       	eor	r10, r10
     4de:	bb 24       	eor	r11, r11
     4e0:	65 01       	movw	r12, r10
     4e2:	40 e0       	ldi	r20, 0x00	; 0
     4e4:	50 e0       	ldi	r21, 0x00	; 0
     4e6:	60 e0       	ldi	r22, 0x00	; 0
     4e8:	70 e0       	ldi	r23, 0x00	; 0
     4ea:	e0 e0       	ldi	r30, 0x00	; 0
     4ec:	f0 e0       	ldi	r31, 0x00	; 0
     4ee:	c1 01       	movw	r24, r2
     4f0:	81 70       	andi	r24, 0x01	; 1
     4f2:	90 70       	andi	r25, 0x00	; 0
     4f4:	89 2b       	or	r24, r25
     4f6:	e9 f0       	breq	.+58     	; 0x532 <__mulsf3+0xf4>
     4f8:	e6 0c       	add	r14, r6
     4fa:	f7 1c       	adc	r15, r7
     4fc:	08 1d       	adc	r16, r8
     4fe:	19 1d       	adc	r17, r9
     500:	9a 01       	movw	r18, r20
     502:	ab 01       	movw	r20, r22
     504:	2a 0d       	add	r18, r10
     506:	3b 1d       	adc	r19, r11
     508:	4c 1d       	adc	r20, r12
     50a:	5d 1d       	adc	r21, r13
     50c:	80 e0       	ldi	r24, 0x00	; 0
     50e:	90 e0       	ldi	r25, 0x00	; 0
     510:	a0 e0       	ldi	r26, 0x00	; 0
     512:	b0 e0       	ldi	r27, 0x00	; 0
     514:	e6 14       	cp	r14, r6
     516:	f7 04       	cpc	r15, r7
     518:	08 05       	cpc	r16, r8
     51a:	19 05       	cpc	r17, r9
     51c:	20 f4       	brcc	.+8      	; 0x526 <__mulsf3+0xe8>
     51e:	81 e0       	ldi	r24, 0x01	; 1
     520:	90 e0       	ldi	r25, 0x00	; 0
     522:	a0 e0       	ldi	r26, 0x00	; 0
     524:	b0 e0       	ldi	r27, 0x00	; 0
     526:	ba 01       	movw	r22, r20
     528:	a9 01       	movw	r20, r18
     52a:	48 0f       	add	r20, r24
     52c:	59 1f       	adc	r21, r25
     52e:	6a 1f       	adc	r22, r26
     530:	7b 1f       	adc	r23, r27
     532:	aa 0c       	add	r10, r10
     534:	bb 1c       	adc	r11, r11
     536:	cc 1c       	adc	r12, r12
     538:	dd 1c       	adc	r13, r13
     53a:	97 fe       	sbrs	r9, 7
     53c:	08 c0       	rjmp	.+16     	; 0x54e <__mulsf3+0x110>
     53e:	81 e0       	ldi	r24, 0x01	; 1
     540:	90 e0       	ldi	r25, 0x00	; 0
     542:	a0 e0       	ldi	r26, 0x00	; 0
     544:	b0 e0       	ldi	r27, 0x00	; 0
     546:	a8 2a       	or	r10, r24
     548:	b9 2a       	or	r11, r25
     54a:	ca 2a       	or	r12, r26
     54c:	db 2a       	or	r13, r27
     54e:	31 96       	adiw	r30, 0x01	; 1
     550:	e0 32       	cpi	r30, 0x20	; 32
     552:	f1 05       	cpc	r31, r1
     554:	49 f0       	breq	.+18     	; 0x568 <__mulsf3+0x12a>
     556:	66 0c       	add	r6, r6
     558:	77 1c       	adc	r7, r7
     55a:	88 1c       	adc	r8, r8
     55c:	99 1c       	adc	r9, r9
     55e:	56 94       	lsr	r5
     560:	47 94       	ror	r4
     562:	37 94       	ror	r3
     564:	27 94       	ror	r2
     566:	c3 cf       	rjmp	.-122    	; 0x4ee <__mulsf3+0xb0>
     568:	fa 85       	ldd	r31, Y+10	; 0x0a
     56a:	ea 89       	ldd	r30, Y+18	; 0x12
     56c:	2b 89       	ldd	r18, Y+19	; 0x13
     56e:	3c 89       	ldd	r19, Y+20	; 0x14
     570:	8b 85       	ldd	r24, Y+11	; 0x0b
     572:	9c 85       	ldd	r25, Y+12	; 0x0c
     574:	28 0f       	add	r18, r24
     576:	39 1f       	adc	r19, r25
     578:	2e 5f       	subi	r18, 0xFE	; 254
     57a:	3f 4f       	sbci	r19, 0xFF	; 255
     57c:	17 c0       	rjmp	.+46     	; 0x5ac <__mulsf3+0x16e>
     57e:	ca 01       	movw	r24, r20
     580:	81 70       	andi	r24, 0x01	; 1
     582:	90 70       	andi	r25, 0x00	; 0
     584:	89 2b       	or	r24, r25
     586:	61 f0       	breq	.+24     	; 0x5a0 <__mulsf3+0x162>
     588:	16 95       	lsr	r17
     58a:	07 95       	ror	r16
     58c:	f7 94       	ror	r15
     58e:	e7 94       	ror	r14
     590:	80 e0       	ldi	r24, 0x00	; 0
     592:	90 e0       	ldi	r25, 0x00	; 0
     594:	a0 e0       	ldi	r26, 0x00	; 0
     596:	b0 e8       	ldi	r27, 0x80	; 128
     598:	e8 2a       	or	r14, r24
     59a:	f9 2a       	or	r15, r25
     59c:	0a 2b       	or	r16, r26
     59e:	1b 2b       	or	r17, r27
     5a0:	76 95       	lsr	r23
     5a2:	67 95       	ror	r22
     5a4:	57 95       	ror	r21
     5a6:	47 95       	ror	r20
     5a8:	2f 5f       	subi	r18, 0xFF	; 255
     5aa:	3f 4f       	sbci	r19, 0xFF	; 255
     5ac:	77 fd       	sbrc	r23, 7
     5ae:	e7 cf       	rjmp	.-50     	; 0x57e <__mulsf3+0x140>
     5b0:	0c c0       	rjmp	.+24     	; 0x5ca <__mulsf3+0x18c>
     5b2:	44 0f       	add	r20, r20
     5b4:	55 1f       	adc	r21, r21
     5b6:	66 1f       	adc	r22, r22
     5b8:	77 1f       	adc	r23, r23
     5ba:	17 fd       	sbrc	r17, 7
     5bc:	41 60       	ori	r20, 0x01	; 1
     5be:	ee 0c       	add	r14, r14
     5c0:	ff 1c       	adc	r15, r15
     5c2:	00 1f       	adc	r16, r16
     5c4:	11 1f       	adc	r17, r17
     5c6:	21 50       	subi	r18, 0x01	; 1
     5c8:	30 40       	sbci	r19, 0x00	; 0
     5ca:	40 30       	cpi	r20, 0x00	; 0
     5cc:	90 e0       	ldi	r25, 0x00	; 0
     5ce:	59 07       	cpc	r21, r25
     5d0:	90 e0       	ldi	r25, 0x00	; 0
     5d2:	69 07       	cpc	r22, r25
     5d4:	90 e4       	ldi	r25, 0x40	; 64
     5d6:	79 07       	cpc	r23, r25
     5d8:	60 f3       	brcs	.-40     	; 0x5b2 <__mulsf3+0x174>
     5da:	2b 8f       	std	Y+27, r18	; 0x1b
     5dc:	3c 8f       	std	Y+28, r19	; 0x1c
     5de:	db 01       	movw	r26, r22
     5e0:	ca 01       	movw	r24, r20
     5e2:	8f 77       	andi	r24, 0x7F	; 127
     5e4:	90 70       	andi	r25, 0x00	; 0
     5e6:	a0 70       	andi	r26, 0x00	; 0
     5e8:	b0 70       	andi	r27, 0x00	; 0
     5ea:	80 34       	cpi	r24, 0x40	; 64
     5ec:	91 05       	cpc	r25, r1
     5ee:	a1 05       	cpc	r26, r1
     5f0:	b1 05       	cpc	r27, r1
     5f2:	61 f4       	brne	.+24     	; 0x60c <__mulsf3+0x1ce>
     5f4:	47 fd       	sbrc	r20, 7
     5f6:	0a c0       	rjmp	.+20     	; 0x60c <__mulsf3+0x1ce>
     5f8:	e1 14       	cp	r14, r1
     5fa:	f1 04       	cpc	r15, r1
     5fc:	01 05       	cpc	r16, r1
     5fe:	11 05       	cpc	r17, r1
     600:	29 f0       	breq	.+10     	; 0x60c <__mulsf3+0x1ce>
     602:	40 5c       	subi	r20, 0xC0	; 192
     604:	5f 4f       	sbci	r21, 0xFF	; 255
     606:	6f 4f       	sbci	r22, 0xFF	; 255
     608:	7f 4f       	sbci	r23, 0xFF	; 255
     60a:	40 78       	andi	r20, 0x80	; 128
     60c:	1a 8e       	std	Y+26, r1	; 0x1a
     60e:	fe 17       	cp	r31, r30
     610:	11 f0       	breq	.+4      	; 0x616 <__mulsf3+0x1d8>
     612:	81 e0       	ldi	r24, 0x01	; 1
     614:	8a 8f       	std	Y+26, r24	; 0x1a
     616:	4d 8f       	std	Y+29, r20	; 0x1d
     618:	5e 8f       	std	Y+30, r21	; 0x1e
     61a:	6f 8f       	std	Y+31, r22	; 0x1f
     61c:	78 a3       	std	Y+32, r23	; 0x20
     61e:	83 e0       	ldi	r24, 0x03	; 3
     620:	89 8f       	std	Y+25, r24	; 0x19
     622:	ce 01       	movw	r24, r28
     624:	49 96       	adiw	r24, 0x19	; 25
     626:	0e 94 fd 03 	call	0x7fa	; 0x7fa <__pack_f>
     62a:	a0 96       	adiw	r28, 0x20	; 32
     62c:	e2 e1       	ldi	r30, 0x12	; 18
     62e:	0c 94 0c 2c 	jmp	0x5818	; 0x5818 <__epilogue_restores__>

00000632 <__gtsf2>:
     632:	a8 e1       	ldi	r26, 0x18	; 24
     634:	b0 e0       	ldi	r27, 0x00	; 0
     636:	ef e1       	ldi	r30, 0x1F	; 31
     638:	f3 e0       	ldi	r31, 0x03	; 3
     63a:	0c 94 fc 2b 	jmp	0x57f8	; 0x57f8 <__prologue_saves__+0x18>
     63e:	69 83       	std	Y+1, r22	; 0x01
     640:	7a 83       	std	Y+2, r23	; 0x02
     642:	8b 83       	std	Y+3, r24	; 0x03
     644:	9c 83       	std	Y+4, r25	; 0x04
     646:	2d 83       	std	Y+5, r18	; 0x05
     648:	3e 83       	std	Y+6, r19	; 0x06
     64a:	4f 83       	std	Y+7, r20	; 0x07
     64c:	58 87       	std	Y+8, r21	; 0x08
     64e:	89 e0       	ldi	r24, 0x09	; 9
     650:	e8 2e       	mov	r14, r24
     652:	f1 2c       	mov	r15, r1
     654:	ec 0e       	add	r14, r28
     656:	fd 1e       	adc	r15, r29
     658:	ce 01       	movw	r24, r28
     65a:	01 96       	adiw	r24, 0x01	; 1
     65c:	b7 01       	movw	r22, r14
     65e:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     662:	8e 01       	movw	r16, r28
     664:	0f 5e       	subi	r16, 0xEF	; 239
     666:	1f 4f       	sbci	r17, 0xFF	; 255
     668:	ce 01       	movw	r24, r28
     66a:	05 96       	adiw	r24, 0x05	; 5
     66c:	b8 01       	movw	r22, r16
     66e:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     672:	89 85       	ldd	r24, Y+9	; 0x09
     674:	82 30       	cpi	r24, 0x02	; 2
     676:	40 f0       	brcs	.+16     	; 0x688 <__gtsf2+0x56>
     678:	89 89       	ldd	r24, Y+17	; 0x11
     67a:	82 30       	cpi	r24, 0x02	; 2
     67c:	28 f0       	brcs	.+10     	; 0x688 <__gtsf2+0x56>
     67e:	c7 01       	movw	r24, r14
     680:	b8 01       	movw	r22, r16
     682:	0e 94 4a 05 	call	0xa94	; 0xa94 <__fpcmp_parts_f>
     686:	01 c0       	rjmp	.+2      	; 0x68a <__gtsf2+0x58>
     688:	8f ef       	ldi	r24, 0xFF	; 255
     68a:	68 96       	adiw	r28, 0x18	; 24
     68c:	e6 e0       	ldi	r30, 0x06	; 6
     68e:	0c 94 18 2c 	jmp	0x5830	; 0x5830 <__epilogue_restores__+0x18>

00000692 <__gesf2>:
     692:	a8 e1       	ldi	r26, 0x18	; 24
     694:	b0 e0       	ldi	r27, 0x00	; 0
     696:	ef e4       	ldi	r30, 0x4F	; 79
     698:	f3 e0       	ldi	r31, 0x03	; 3
     69a:	0c 94 fc 2b 	jmp	0x57f8	; 0x57f8 <__prologue_saves__+0x18>
     69e:	69 83       	std	Y+1, r22	; 0x01
     6a0:	7a 83       	std	Y+2, r23	; 0x02
     6a2:	8b 83       	std	Y+3, r24	; 0x03
     6a4:	9c 83       	std	Y+4, r25	; 0x04
     6a6:	2d 83       	std	Y+5, r18	; 0x05
     6a8:	3e 83       	std	Y+6, r19	; 0x06
     6aa:	4f 83       	std	Y+7, r20	; 0x07
     6ac:	58 87       	std	Y+8, r21	; 0x08
     6ae:	89 e0       	ldi	r24, 0x09	; 9
     6b0:	e8 2e       	mov	r14, r24
     6b2:	f1 2c       	mov	r15, r1
     6b4:	ec 0e       	add	r14, r28
     6b6:	fd 1e       	adc	r15, r29
     6b8:	ce 01       	movw	r24, r28
     6ba:	01 96       	adiw	r24, 0x01	; 1
     6bc:	b7 01       	movw	r22, r14
     6be:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     6c2:	8e 01       	movw	r16, r28
     6c4:	0f 5e       	subi	r16, 0xEF	; 239
     6c6:	1f 4f       	sbci	r17, 0xFF	; 255
     6c8:	ce 01       	movw	r24, r28
     6ca:	05 96       	adiw	r24, 0x05	; 5
     6cc:	b8 01       	movw	r22, r16
     6ce:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     6d2:	89 85       	ldd	r24, Y+9	; 0x09
     6d4:	82 30       	cpi	r24, 0x02	; 2
     6d6:	40 f0       	brcs	.+16     	; 0x6e8 <__gesf2+0x56>
     6d8:	89 89       	ldd	r24, Y+17	; 0x11
     6da:	82 30       	cpi	r24, 0x02	; 2
     6dc:	28 f0       	brcs	.+10     	; 0x6e8 <__gesf2+0x56>
     6de:	c7 01       	movw	r24, r14
     6e0:	b8 01       	movw	r22, r16
     6e2:	0e 94 4a 05 	call	0xa94	; 0xa94 <__fpcmp_parts_f>
     6e6:	01 c0       	rjmp	.+2      	; 0x6ea <__gesf2+0x58>
     6e8:	8f ef       	ldi	r24, 0xFF	; 255
     6ea:	68 96       	adiw	r28, 0x18	; 24
     6ec:	e6 e0       	ldi	r30, 0x06	; 6
     6ee:	0c 94 18 2c 	jmp	0x5830	; 0x5830 <__epilogue_restores__+0x18>

000006f2 <__ltsf2>:
     6f2:	a8 e1       	ldi	r26, 0x18	; 24
     6f4:	b0 e0       	ldi	r27, 0x00	; 0
     6f6:	ef e7       	ldi	r30, 0x7F	; 127
     6f8:	f3 e0       	ldi	r31, 0x03	; 3
     6fa:	0c 94 fc 2b 	jmp	0x57f8	; 0x57f8 <__prologue_saves__+0x18>
     6fe:	69 83       	std	Y+1, r22	; 0x01
     700:	7a 83       	std	Y+2, r23	; 0x02
     702:	8b 83       	std	Y+3, r24	; 0x03
     704:	9c 83       	std	Y+4, r25	; 0x04
     706:	2d 83       	std	Y+5, r18	; 0x05
     708:	3e 83       	std	Y+6, r19	; 0x06
     70a:	4f 83       	std	Y+7, r20	; 0x07
     70c:	58 87       	std	Y+8, r21	; 0x08
     70e:	89 e0       	ldi	r24, 0x09	; 9
     710:	e8 2e       	mov	r14, r24
     712:	f1 2c       	mov	r15, r1
     714:	ec 0e       	add	r14, r28
     716:	fd 1e       	adc	r15, r29
     718:	ce 01       	movw	r24, r28
     71a:	01 96       	adiw	r24, 0x01	; 1
     71c:	b7 01       	movw	r22, r14
     71e:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     722:	8e 01       	movw	r16, r28
     724:	0f 5e       	subi	r16, 0xEF	; 239
     726:	1f 4f       	sbci	r17, 0xFF	; 255
     728:	ce 01       	movw	r24, r28
     72a:	05 96       	adiw	r24, 0x05	; 5
     72c:	b8 01       	movw	r22, r16
     72e:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     732:	89 85       	ldd	r24, Y+9	; 0x09
     734:	82 30       	cpi	r24, 0x02	; 2
     736:	40 f0       	brcs	.+16     	; 0x748 <__ltsf2+0x56>
     738:	89 89       	ldd	r24, Y+17	; 0x11
     73a:	82 30       	cpi	r24, 0x02	; 2
     73c:	28 f0       	brcs	.+10     	; 0x748 <__ltsf2+0x56>
     73e:	c7 01       	movw	r24, r14
     740:	b8 01       	movw	r22, r16
     742:	0e 94 4a 05 	call	0xa94	; 0xa94 <__fpcmp_parts_f>
     746:	01 c0       	rjmp	.+2      	; 0x74a <__ltsf2+0x58>
     748:	81 e0       	ldi	r24, 0x01	; 1
     74a:	68 96       	adiw	r28, 0x18	; 24
     74c:	e6 e0       	ldi	r30, 0x06	; 6
     74e:	0c 94 18 2c 	jmp	0x5830	; 0x5830 <__epilogue_restores__+0x18>

00000752 <__fixsfsi>:
     752:	ac e0       	ldi	r26, 0x0C	; 12
     754:	b0 e0       	ldi	r27, 0x00	; 0
     756:	ef ea       	ldi	r30, 0xAF	; 175
     758:	f3 e0       	ldi	r31, 0x03	; 3
     75a:	0c 94 00 2c 	jmp	0x5800	; 0x5800 <__prologue_saves__+0x20>
     75e:	69 83       	std	Y+1, r22	; 0x01
     760:	7a 83       	std	Y+2, r23	; 0x02
     762:	8b 83       	std	Y+3, r24	; 0x03
     764:	9c 83       	std	Y+4, r25	; 0x04
     766:	ce 01       	movw	r24, r28
     768:	01 96       	adiw	r24, 0x01	; 1
     76a:	be 01       	movw	r22, r28
     76c:	6b 5f       	subi	r22, 0xFB	; 251
     76e:	7f 4f       	sbci	r23, 0xFF	; 255
     770:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     774:	8d 81       	ldd	r24, Y+5	; 0x05
     776:	82 30       	cpi	r24, 0x02	; 2
     778:	61 f1       	breq	.+88     	; 0x7d2 <__fixsfsi+0x80>
     77a:	82 30       	cpi	r24, 0x02	; 2
     77c:	50 f1       	brcs	.+84     	; 0x7d2 <__fixsfsi+0x80>
     77e:	84 30       	cpi	r24, 0x04	; 4
     780:	21 f4       	brne	.+8      	; 0x78a <__fixsfsi+0x38>
     782:	8e 81       	ldd	r24, Y+6	; 0x06
     784:	88 23       	and	r24, r24
     786:	51 f1       	breq	.+84     	; 0x7dc <__fixsfsi+0x8a>
     788:	2e c0       	rjmp	.+92     	; 0x7e6 <__fixsfsi+0x94>
     78a:	2f 81       	ldd	r18, Y+7	; 0x07
     78c:	38 85       	ldd	r19, Y+8	; 0x08
     78e:	37 fd       	sbrc	r19, 7
     790:	20 c0       	rjmp	.+64     	; 0x7d2 <__fixsfsi+0x80>
     792:	6e 81       	ldd	r22, Y+6	; 0x06
     794:	2f 31       	cpi	r18, 0x1F	; 31
     796:	31 05       	cpc	r19, r1
     798:	1c f0       	brlt	.+6      	; 0x7a0 <__fixsfsi+0x4e>
     79a:	66 23       	and	r22, r22
     79c:	f9 f0       	breq	.+62     	; 0x7dc <__fixsfsi+0x8a>
     79e:	23 c0       	rjmp	.+70     	; 0x7e6 <__fixsfsi+0x94>
     7a0:	8e e1       	ldi	r24, 0x1E	; 30
     7a2:	90 e0       	ldi	r25, 0x00	; 0
     7a4:	82 1b       	sub	r24, r18
     7a6:	93 0b       	sbc	r25, r19
     7a8:	29 85       	ldd	r18, Y+9	; 0x09
     7aa:	3a 85       	ldd	r19, Y+10	; 0x0a
     7ac:	4b 85       	ldd	r20, Y+11	; 0x0b
     7ae:	5c 85       	ldd	r21, Y+12	; 0x0c
     7b0:	04 c0       	rjmp	.+8      	; 0x7ba <__fixsfsi+0x68>
     7b2:	56 95       	lsr	r21
     7b4:	47 95       	ror	r20
     7b6:	37 95       	ror	r19
     7b8:	27 95       	ror	r18
     7ba:	8a 95       	dec	r24
     7bc:	d2 f7       	brpl	.-12     	; 0x7b2 <__fixsfsi+0x60>
     7be:	66 23       	and	r22, r22
     7c0:	b1 f0       	breq	.+44     	; 0x7ee <__fixsfsi+0x9c>
     7c2:	50 95       	com	r21
     7c4:	40 95       	com	r20
     7c6:	30 95       	com	r19
     7c8:	21 95       	neg	r18
     7ca:	3f 4f       	sbci	r19, 0xFF	; 255
     7cc:	4f 4f       	sbci	r20, 0xFF	; 255
     7ce:	5f 4f       	sbci	r21, 0xFF	; 255
     7d0:	0e c0       	rjmp	.+28     	; 0x7ee <__fixsfsi+0x9c>
     7d2:	20 e0       	ldi	r18, 0x00	; 0
     7d4:	30 e0       	ldi	r19, 0x00	; 0
     7d6:	40 e0       	ldi	r20, 0x00	; 0
     7d8:	50 e0       	ldi	r21, 0x00	; 0
     7da:	09 c0       	rjmp	.+18     	; 0x7ee <__fixsfsi+0x9c>
     7dc:	2f ef       	ldi	r18, 0xFF	; 255
     7de:	3f ef       	ldi	r19, 0xFF	; 255
     7e0:	4f ef       	ldi	r20, 0xFF	; 255
     7e2:	5f e7       	ldi	r21, 0x7F	; 127
     7e4:	04 c0       	rjmp	.+8      	; 0x7ee <__fixsfsi+0x9c>
     7e6:	20 e0       	ldi	r18, 0x00	; 0
     7e8:	30 e0       	ldi	r19, 0x00	; 0
     7ea:	40 e0       	ldi	r20, 0x00	; 0
     7ec:	50 e8       	ldi	r21, 0x80	; 128
     7ee:	b9 01       	movw	r22, r18
     7f0:	ca 01       	movw	r24, r20
     7f2:	2c 96       	adiw	r28, 0x0c	; 12
     7f4:	e2 e0       	ldi	r30, 0x02	; 2
     7f6:	0c 94 1c 2c 	jmp	0x5838	; 0x5838 <__epilogue_restores__+0x20>

000007fa <__pack_f>:
     7fa:	df 92       	push	r13
     7fc:	ef 92       	push	r14
     7fe:	ff 92       	push	r15
     800:	0f 93       	push	r16
     802:	1f 93       	push	r17
     804:	fc 01       	movw	r30, r24
     806:	e4 80       	ldd	r14, Z+4	; 0x04
     808:	f5 80       	ldd	r15, Z+5	; 0x05
     80a:	06 81       	ldd	r16, Z+6	; 0x06
     80c:	17 81       	ldd	r17, Z+7	; 0x07
     80e:	d1 80       	ldd	r13, Z+1	; 0x01
     810:	80 81       	ld	r24, Z
     812:	82 30       	cpi	r24, 0x02	; 2
     814:	48 f4       	brcc	.+18     	; 0x828 <__pack_f+0x2e>
     816:	80 e0       	ldi	r24, 0x00	; 0
     818:	90 e0       	ldi	r25, 0x00	; 0
     81a:	a0 e1       	ldi	r26, 0x10	; 16
     81c:	b0 e0       	ldi	r27, 0x00	; 0
     81e:	e8 2a       	or	r14, r24
     820:	f9 2a       	or	r15, r25
     822:	0a 2b       	or	r16, r26
     824:	1b 2b       	or	r17, r27
     826:	a5 c0       	rjmp	.+330    	; 0x972 <__stack+0x113>
     828:	84 30       	cpi	r24, 0x04	; 4
     82a:	09 f4       	brne	.+2      	; 0x82e <__pack_f+0x34>
     82c:	9f c0       	rjmp	.+318    	; 0x96c <__stack+0x10d>
     82e:	82 30       	cpi	r24, 0x02	; 2
     830:	21 f4       	brne	.+8      	; 0x83a <__pack_f+0x40>
     832:	ee 24       	eor	r14, r14
     834:	ff 24       	eor	r15, r15
     836:	87 01       	movw	r16, r14
     838:	05 c0       	rjmp	.+10     	; 0x844 <__pack_f+0x4a>
     83a:	e1 14       	cp	r14, r1
     83c:	f1 04       	cpc	r15, r1
     83e:	01 05       	cpc	r16, r1
     840:	11 05       	cpc	r17, r1
     842:	19 f4       	brne	.+6      	; 0x84a <__pack_f+0x50>
     844:	e0 e0       	ldi	r30, 0x00	; 0
     846:	f0 e0       	ldi	r31, 0x00	; 0
     848:	96 c0       	rjmp	.+300    	; 0x976 <__stack+0x117>
     84a:	62 81       	ldd	r22, Z+2	; 0x02
     84c:	73 81       	ldd	r23, Z+3	; 0x03
     84e:	9f ef       	ldi	r25, 0xFF	; 255
     850:	62 38       	cpi	r22, 0x82	; 130
     852:	79 07       	cpc	r23, r25
     854:	0c f0       	brlt	.+2      	; 0x858 <__pack_f+0x5e>
     856:	5b c0       	rjmp	.+182    	; 0x90e <__stack+0xaf>
     858:	22 e8       	ldi	r18, 0x82	; 130
     85a:	3f ef       	ldi	r19, 0xFF	; 255
     85c:	26 1b       	sub	r18, r22
     85e:	37 0b       	sbc	r19, r23
     860:	2a 31       	cpi	r18, 0x1A	; 26
     862:	31 05       	cpc	r19, r1
     864:	2c f0       	brlt	.+10     	; 0x870 <__stack+0x11>
     866:	20 e0       	ldi	r18, 0x00	; 0
     868:	30 e0       	ldi	r19, 0x00	; 0
     86a:	40 e0       	ldi	r20, 0x00	; 0
     86c:	50 e0       	ldi	r21, 0x00	; 0
     86e:	2a c0       	rjmp	.+84     	; 0x8c4 <__stack+0x65>
     870:	b8 01       	movw	r22, r16
     872:	a7 01       	movw	r20, r14
     874:	02 2e       	mov	r0, r18
     876:	04 c0       	rjmp	.+8      	; 0x880 <__stack+0x21>
     878:	76 95       	lsr	r23
     87a:	67 95       	ror	r22
     87c:	57 95       	ror	r21
     87e:	47 95       	ror	r20
     880:	0a 94       	dec	r0
     882:	d2 f7       	brpl	.-12     	; 0x878 <__stack+0x19>
     884:	81 e0       	ldi	r24, 0x01	; 1
     886:	90 e0       	ldi	r25, 0x00	; 0
     888:	a0 e0       	ldi	r26, 0x00	; 0
     88a:	b0 e0       	ldi	r27, 0x00	; 0
     88c:	04 c0       	rjmp	.+8      	; 0x896 <__stack+0x37>
     88e:	88 0f       	add	r24, r24
     890:	99 1f       	adc	r25, r25
     892:	aa 1f       	adc	r26, r26
     894:	bb 1f       	adc	r27, r27
     896:	2a 95       	dec	r18
     898:	d2 f7       	brpl	.-12     	; 0x88e <__stack+0x2f>
     89a:	01 97       	sbiw	r24, 0x01	; 1
     89c:	a1 09       	sbc	r26, r1
     89e:	b1 09       	sbc	r27, r1
     8a0:	8e 21       	and	r24, r14
     8a2:	9f 21       	and	r25, r15
     8a4:	a0 23       	and	r26, r16
     8a6:	b1 23       	and	r27, r17
     8a8:	00 97       	sbiw	r24, 0x00	; 0
     8aa:	a1 05       	cpc	r26, r1
     8ac:	b1 05       	cpc	r27, r1
     8ae:	21 f0       	breq	.+8      	; 0x8b8 <__stack+0x59>
     8b0:	81 e0       	ldi	r24, 0x01	; 1
     8b2:	90 e0       	ldi	r25, 0x00	; 0
     8b4:	a0 e0       	ldi	r26, 0x00	; 0
     8b6:	b0 e0       	ldi	r27, 0x00	; 0
     8b8:	9a 01       	movw	r18, r20
     8ba:	ab 01       	movw	r20, r22
     8bc:	28 2b       	or	r18, r24
     8be:	39 2b       	or	r19, r25
     8c0:	4a 2b       	or	r20, r26
     8c2:	5b 2b       	or	r21, r27
     8c4:	da 01       	movw	r26, r20
     8c6:	c9 01       	movw	r24, r18
     8c8:	8f 77       	andi	r24, 0x7F	; 127
     8ca:	90 70       	andi	r25, 0x00	; 0
     8cc:	a0 70       	andi	r26, 0x00	; 0
     8ce:	b0 70       	andi	r27, 0x00	; 0
     8d0:	80 34       	cpi	r24, 0x40	; 64
     8d2:	91 05       	cpc	r25, r1
     8d4:	a1 05       	cpc	r26, r1
     8d6:	b1 05       	cpc	r27, r1
     8d8:	39 f4       	brne	.+14     	; 0x8e8 <__stack+0x89>
     8da:	27 ff       	sbrs	r18, 7
     8dc:	09 c0       	rjmp	.+18     	; 0x8f0 <__stack+0x91>
     8de:	20 5c       	subi	r18, 0xC0	; 192
     8e0:	3f 4f       	sbci	r19, 0xFF	; 255
     8e2:	4f 4f       	sbci	r20, 0xFF	; 255
     8e4:	5f 4f       	sbci	r21, 0xFF	; 255
     8e6:	04 c0       	rjmp	.+8      	; 0x8f0 <__stack+0x91>
     8e8:	21 5c       	subi	r18, 0xC1	; 193
     8ea:	3f 4f       	sbci	r19, 0xFF	; 255
     8ec:	4f 4f       	sbci	r20, 0xFF	; 255
     8ee:	5f 4f       	sbci	r21, 0xFF	; 255
     8f0:	e0 e0       	ldi	r30, 0x00	; 0
     8f2:	f0 e0       	ldi	r31, 0x00	; 0
     8f4:	20 30       	cpi	r18, 0x00	; 0
     8f6:	a0 e0       	ldi	r26, 0x00	; 0
     8f8:	3a 07       	cpc	r19, r26
     8fa:	a0 e0       	ldi	r26, 0x00	; 0
     8fc:	4a 07       	cpc	r20, r26
     8fe:	a0 e4       	ldi	r26, 0x40	; 64
     900:	5a 07       	cpc	r21, r26
     902:	10 f0       	brcs	.+4      	; 0x908 <__stack+0xa9>
     904:	e1 e0       	ldi	r30, 0x01	; 1
     906:	f0 e0       	ldi	r31, 0x00	; 0
     908:	79 01       	movw	r14, r18
     90a:	8a 01       	movw	r16, r20
     90c:	27 c0       	rjmp	.+78     	; 0x95c <__stack+0xfd>
     90e:	60 38       	cpi	r22, 0x80	; 128
     910:	71 05       	cpc	r23, r1
     912:	64 f5       	brge	.+88     	; 0x96c <__stack+0x10d>
     914:	fb 01       	movw	r30, r22
     916:	e1 58       	subi	r30, 0x81	; 129
     918:	ff 4f       	sbci	r31, 0xFF	; 255
     91a:	d8 01       	movw	r26, r16
     91c:	c7 01       	movw	r24, r14
     91e:	8f 77       	andi	r24, 0x7F	; 127
     920:	90 70       	andi	r25, 0x00	; 0
     922:	a0 70       	andi	r26, 0x00	; 0
     924:	b0 70       	andi	r27, 0x00	; 0
     926:	80 34       	cpi	r24, 0x40	; 64
     928:	91 05       	cpc	r25, r1
     92a:	a1 05       	cpc	r26, r1
     92c:	b1 05       	cpc	r27, r1
     92e:	39 f4       	brne	.+14     	; 0x93e <__stack+0xdf>
     930:	e7 fe       	sbrs	r14, 7
     932:	0d c0       	rjmp	.+26     	; 0x94e <__stack+0xef>
     934:	80 e4       	ldi	r24, 0x40	; 64
     936:	90 e0       	ldi	r25, 0x00	; 0
     938:	a0 e0       	ldi	r26, 0x00	; 0
     93a:	b0 e0       	ldi	r27, 0x00	; 0
     93c:	04 c0       	rjmp	.+8      	; 0x946 <__stack+0xe7>
     93e:	8f e3       	ldi	r24, 0x3F	; 63
     940:	90 e0       	ldi	r25, 0x00	; 0
     942:	a0 e0       	ldi	r26, 0x00	; 0
     944:	b0 e0       	ldi	r27, 0x00	; 0
     946:	e8 0e       	add	r14, r24
     948:	f9 1e       	adc	r15, r25
     94a:	0a 1f       	adc	r16, r26
     94c:	1b 1f       	adc	r17, r27
     94e:	17 ff       	sbrs	r17, 7
     950:	05 c0       	rjmp	.+10     	; 0x95c <__stack+0xfd>
     952:	16 95       	lsr	r17
     954:	07 95       	ror	r16
     956:	f7 94       	ror	r15
     958:	e7 94       	ror	r14
     95a:	31 96       	adiw	r30, 0x01	; 1
     95c:	87 e0       	ldi	r24, 0x07	; 7
     95e:	16 95       	lsr	r17
     960:	07 95       	ror	r16
     962:	f7 94       	ror	r15
     964:	e7 94       	ror	r14
     966:	8a 95       	dec	r24
     968:	d1 f7       	brne	.-12     	; 0x95e <__stack+0xff>
     96a:	05 c0       	rjmp	.+10     	; 0x976 <__stack+0x117>
     96c:	ee 24       	eor	r14, r14
     96e:	ff 24       	eor	r15, r15
     970:	87 01       	movw	r16, r14
     972:	ef ef       	ldi	r30, 0xFF	; 255
     974:	f0 e0       	ldi	r31, 0x00	; 0
     976:	6e 2f       	mov	r22, r30
     978:	67 95       	ror	r22
     97a:	66 27       	eor	r22, r22
     97c:	67 95       	ror	r22
     97e:	90 2f       	mov	r25, r16
     980:	9f 77       	andi	r25, 0x7F	; 127
     982:	d7 94       	ror	r13
     984:	dd 24       	eor	r13, r13
     986:	d7 94       	ror	r13
     988:	8e 2f       	mov	r24, r30
     98a:	86 95       	lsr	r24
     98c:	49 2f       	mov	r20, r25
     98e:	46 2b       	or	r20, r22
     990:	58 2f       	mov	r21, r24
     992:	5d 29       	or	r21, r13
     994:	b7 01       	movw	r22, r14
     996:	ca 01       	movw	r24, r20
     998:	1f 91       	pop	r17
     99a:	0f 91       	pop	r16
     99c:	ff 90       	pop	r15
     99e:	ef 90       	pop	r14
     9a0:	df 90       	pop	r13
     9a2:	08 95       	ret

000009a4 <__unpack_f>:
     9a4:	fc 01       	movw	r30, r24
     9a6:	db 01       	movw	r26, r22
     9a8:	40 81       	ld	r20, Z
     9aa:	51 81       	ldd	r21, Z+1	; 0x01
     9ac:	22 81       	ldd	r18, Z+2	; 0x02
     9ae:	62 2f       	mov	r22, r18
     9b0:	6f 77       	andi	r22, 0x7F	; 127
     9b2:	70 e0       	ldi	r23, 0x00	; 0
     9b4:	22 1f       	adc	r18, r18
     9b6:	22 27       	eor	r18, r18
     9b8:	22 1f       	adc	r18, r18
     9ba:	93 81       	ldd	r25, Z+3	; 0x03
     9bc:	89 2f       	mov	r24, r25
     9be:	88 0f       	add	r24, r24
     9c0:	82 2b       	or	r24, r18
     9c2:	28 2f       	mov	r18, r24
     9c4:	30 e0       	ldi	r19, 0x00	; 0
     9c6:	99 1f       	adc	r25, r25
     9c8:	99 27       	eor	r25, r25
     9ca:	99 1f       	adc	r25, r25
     9cc:	11 96       	adiw	r26, 0x01	; 1
     9ce:	9c 93       	st	X, r25
     9d0:	11 97       	sbiw	r26, 0x01	; 1
     9d2:	21 15       	cp	r18, r1
     9d4:	31 05       	cpc	r19, r1
     9d6:	a9 f5       	brne	.+106    	; 0xa42 <__unpack_f+0x9e>
     9d8:	41 15       	cp	r20, r1
     9da:	51 05       	cpc	r21, r1
     9dc:	61 05       	cpc	r22, r1
     9de:	71 05       	cpc	r23, r1
     9e0:	11 f4       	brne	.+4      	; 0x9e6 <__unpack_f+0x42>
     9e2:	82 e0       	ldi	r24, 0x02	; 2
     9e4:	37 c0       	rjmp	.+110    	; 0xa54 <__unpack_f+0xb0>
     9e6:	82 e8       	ldi	r24, 0x82	; 130
     9e8:	9f ef       	ldi	r25, 0xFF	; 255
     9ea:	13 96       	adiw	r26, 0x03	; 3
     9ec:	9c 93       	st	X, r25
     9ee:	8e 93       	st	-X, r24
     9f0:	12 97       	sbiw	r26, 0x02	; 2
     9f2:	9a 01       	movw	r18, r20
     9f4:	ab 01       	movw	r20, r22
     9f6:	67 e0       	ldi	r22, 0x07	; 7
     9f8:	22 0f       	add	r18, r18
     9fa:	33 1f       	adc	r19, r19
     9fc:	44 1f       	adc	r20, r20
     9fe:	55 1f       	adc	r21, r21
     a00:	6a 95       	dec	r22
     a02:	d1 f7       	brne	.-12     	; 0x9f8 <__unpack_f+0x54>
     a04:	83 e0       	ldi	r24, 0x03	; 3
     a06:	8c 93       	st	X, r24
     a08:	0d c0       	rjmp	.+26     	; 0xa24 <__unpack_f+0x80>
     a0a:	22 0f       	add	r18, r18
     a0c:	33 1f       	adc	r19, r19
     a0e:	44 1f       	adc	r20, r20
     a10:	55 1f       	adc	r21, r21
     a12:	12 96       	adiw	r26, 0x02	; 2
     a14:	8d 91       	ld	r24, X+
     a16:	9c 91       	ld	r25, X
     a18:	13 97       	sbiw	r26, 0x03	; 3
     a1a:	01 97       	sbiw	r24, 0x01	; 1
     a1c:	13 96       	adiw	r26, 0x03	; 3
     a1e:	9c 93       	st	X, r25
     a20:	8e 93       	st	-X, r24
     a22:	12 97       	sbiw	r26, 0x02	; 2
     a24:	20 30       	cpi	r18, 0x00	; 0
     a26:	80 e0       	ldi	r24, 0x00	; 0
     a28:	38 07       	cpc	r19, r24
     a2a:	80 e0       	ldi	r24, 0x00	; 0
     a2c:	48 07       	cpc	r20, r24
     a2e:	80 e4       	ldi	r24, 0x40	; 64
     a30:	58 07       	cpc	r21, r24
     a32:	58 f3       	brcs	.-42     	; 0xa0a <__unpack_f+0x66>
     a34:	14 96       	adiw	r26, 0x04	; 4
     a36:	2d 93       	st	X+, r18
     a38:	3d 93       	st	X+, r19
     a3a:	4d 93       	st	X+, r20
     a3c:	5c 93       	st	X, r21
     a3e:	17 97       	sbiw	r26, 0x07	; 7
     a40:	08 95       	ret
     a42:	2f 3f       	cpi	r18, 0xFF	; 255
     a44:	31 05       	cpc	r19, r1
     a46:	79 f4       	brne	.+30     	; 0xa66 <__unpack_f+0xc2>
     a48:	41 15       	cp	r20, r1
     a4a:	51 05       	cpc	r21, r1
     a4c:	61 05       	cpc	r22, r1
     a4e:	71 05       	cpc	r23, r1
     a50:	19 f4       	brne	.+6      	; 0xa58 <__unpack_f+0xb4>
     a52:	84 e0       	ldi	r24, 0x04	; 4
     a54:	8c 93       	st	X, r24
     a56:	08 95       	ret
     a58:	64 ff       	sbrs	r22, 4
     a5a:	03 c0       	rjmp	.+6      	; 0xa62 <__unpack_f+0xbe>
     a5c:	81 e0       	ldi	r24, 0x01	; 1
     a5e:	8c 93       	st	X, r24
     a60:	12 c0       	rjmp	.+36     	; 0xa86 <__unpack_f+0xe2>
     a62:	1c 92       	st	X, r1
     a64:	10 c0       	rjmp	.+32     	; 0xa86 <__unpack_f+0xe2>
     a66:	2f 57       	subi	r18, 0x7F	; 127
     a68:	30 40       	sbci	r19, 0x00	; 0
     a6a:	13 96       	adiw	r26, 0x03	; 3
     a6c:	3c 93       	st	X, r19
     a6e:	2e 93       	st	-X, r18
     a70:	12 97       	sbiw	r26, 0x02	; 2
     a72:	83 e0       	ldi	r24, 0x03	; 3
     a74:	8c 93       	st	X, r24
     a76:	87 e0       	ldi	r24, 0x07	; 7
     a78:	44 0f       	add	r20, r20
     a7a:	55 1f       	adc	r21, r21
     a7c:	66 1f       	adc	r22, r22
     a7e:	77 1f       	adc	r23, r23
     a80:	8a 95       	dec	r24
     a82:	d1 f7       	brne	.-12     	; 0xa78 <__unpack_f+0xd4>
     a84:	70 64       	ori	r23, 0x40	; 64
     a86:	14 96       	adiw	r26, 0x04	; 4
     a88:	4d 93       	st	X+, r20
     a8a:	5d 93       	st	X+, r21
     a8c:	6d 93       	st	X+, r22
     a8e:	7c 93       	st	X, r23
     a90:	17 97       	sbiw	r26, 0x07	; 7
     a92:	08 95       	ret

00000a94 <__fpcmp_parts_f>:
     a94:	1f 93       	push	r17
     a96:	dc 01       	movw	r26, r24
     a98:	fb 01       	movw	r30, r22
     a9a:	9c 91       	ld	r25, X
     a9c:	92 30       	cpi	r25, 0x02	; 2
     a9e:	08 f4       	brcc	.+2      	; 0xaa2 <__fpcmp_parts_f+0xe>
     aa0:	47 c0       	rjmp	.+142    	; 0xb30 <__fpcmp_parts_f+0x9c>
     aa2:	80 81       	ld	r24, Z
     aa4:	82 30       	cpi	r24, 0x02	; 2
     aa6:	08 f4       	brcc	.+2      	; 0xaaa <__fpcmp_parts_f+0x16>
     aa8:	43 c0       	rjmp	.+134    	; 0xb30 <__fpcmp_parts_f+0x9c>
     aaa:	94 30       	cpi	r25, 0x04	; 4
     aac:	51 f4       	brne	.+20     	; 0xac2 <__fpcmp_parts_f+0x2e>
     aae:	11 96       	adiw	r26, 0x01	; 1
     ab0:	1c 91       	ld	r17, X
     ab2:	84 30       	cpi	r24, 0x04	; 4
     ab4:	99 f5       	brne	.+102    	; 0xb1c <__fpcmp_parts_f+0x88>
     ab6:	81 81       	ldd	r24, Z+1	; 0x01
     ab8:	68 2f       	mov	r22, r24
     aba:	70 e0       	ldi	r23, 0x00	; 0
     abc:	61 1b       	sub	r22, r17
     abe:	71 09       	sbc	r23, r1
     ac0:	3f c0       	rjmp	.+126    	; 0xb40 <__fpcmp_parts_f+0xac>
     ac2:	84 30       	cpi	r24, 0x04	; 4
     ac4:	21 f0       	breq	.+8      	; 0xace <__fpcmp_parts_f+0x3a>
     ac6:	92 30       	cpi	r25, 0x02	; 2
     ac8:	31 f4       	brne	.+12     	; 0xad6 <__fpcmp_parts_f+0x42>
     aca:	82 30       	cpi	r24, 0x02	; 2
     acc:	b9 f1       	breq	.+110    	; 0xb3c <__fpcmp_parts_f+0xa8>
     ace:	81 81       	ldd	r24, Z+1	; 0x01
     ad0:	88 23       	and	r24, r24
     ad2:	89 f1       	breq	.+98     	; 0xb36 <__fpcmp_parts_f+0xa2>
     ad4:	2d c0       	rjmp	.+90     	; 0xb30 <__fpcmp_parts_f+0x9c>
     ad6:	11 96       	adiw	r26, 0x01	; 1
     ad8:	1c 91       	ld	r17, X
     ada:	11 97       	sbiw	r26, 0x01	; 1
     adc:	82 30       	cpi	r24, 0x02	; 2
     ade:	f1 f0       	breq	.+60     	; 0xb1c <__fpcmp_parts_f+0x88>
     ae0:	81 81       	ldd	r24, Z+1	; 0x01
     ae2:	18 17       	cp	r17, r24
     ae4:	d9 f4       	brne	.+54     	; 0xb1c <__fpcmp_parts_f+0x88>
     ae6:	12 96       	adiw	r26, 0x02	; 2
     ae8:	2d 91       	ld	r18, X+
     aea:	3c 91       	ld	r19, X
     aec:	13 97       	sbiw	r26, 0x03	; 3
     aee:	82 81       	ldd	r24, Z+2	; 0x02
     af0:	93 81       	ldd	r25, Z+3	; 0x03
     af2:	82 17       	cp	r24, r18
     af4:	93 07       	cpc	r25, r19
     af6:	94 f0       	brlt	.+36     	; 0xb1c <__fpcmp_parts_f+0x88>
     af8:	28 17       	cp	r18, r24
     afa:	39 07       	cpc	r19, r25
     afc:	bc f0       	brlt	.+46     	; 0xb2c <__fpcmp_parts_f+0x98>
     afe:	14 96       	adiw	r26, 0x04	; 4
     b00:	8d 91       	ld	r24, X+
     b02:	9d 91       	ld	r25, X+
     b04:	0d 90       	ld	r0, X+
     b06:	bc 91       	ld	r27, X
     b08:	a0 2d       	mov	r26, r0
     b0a:	24 81       	ldd	r18, Z+4	; 0x04
     b0c:	35 81       	ldd	r19, Z+5	; 0x05
     b0e:	46 81       	ldd	r20, Z+6	; 0x06
     b10:	57 81       	ldd	r21, Z+7	; 0x07
     b12:	28 17       	cp	r18, r24
     b14:	39 07       	cpc	r19, r25
     b16:	4a 07       	cpc	r20, r26
     b18:	5b 07       	cpc	r21, r27
     b1a:	18 f4       	brcc	.+6      	; 0xb22 <__fpcmp_parts_f+0x8e>
     b1c:	11 23       	and	r17, r17
     b1e:	41 f0       	breq	.+16     	; 0xb30 <__fpcmp_parts_f+0x9c>
     b20:	0a c0       	rjmp	.+20     	; 0xb36 <__fpcmp_parts_f+0xa2>
     b22:	82 17       	cp	r24, r18
     b24:	93 07       	cpc	r25, r19
     b26:	a4 07       	cpc	r26, r20
     b28:	b5 07       	cpc	r27, r21
     b2a:	40 f4       	brcc	.+16     	; 0xb3c <__fpcmp_parts_f+0xa8>
     b2c:	11 23       	and	r17, r17
     b2e:	19 f0       	breq	.+6      	; 0xb36 <__fpcmp_parts_f+0xa2>
     b30:	61 e0       	ldi	r22, 0x01	; 1
     b32:	70 e0       	ldi	r23, 0x00	; 0
     b34:	05 c0       	rjmp	.+10     	; 0xb40 <__fpcmp_parts_f+0xac>
     b36:	6f ef       	ldi	r22, 0xFF	; 255
     b38:	7f ef       	ldi	r23, 0xFF	; 255
     b3a:	02 c0       	rjmp	.+4      	; 0xb40 <__fpcmp_parts_f+0xac>
     b3c:	60 e0       	ldi	r22, 0x00	; 0
     b3e:	70 e0       	ldi	r23, 0x00	; 0
     b40:	cb 01       	movw	r24, r22
     b42:	1f 91       	pop	r17
     b44:	08 95       	ret

00000b46 <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, unsigned portBASE_TYPE uxPriority, unsigned portBASE_TYPE uxIndex )
{
     b46:	df 93       	push	r29
     b48:	cf 93       	push	r28
     b4a:	cd b7       	in	r28, 0x3d	; 61
     b4c:	de b7       	in	r29, 0x3e	; 62
     b4e:	27 97       	sbiw	r28, 0x07	; 7
     b50:	0f b6       	in	r0, 0x3f	; 63
     b52:	f8 94       	cli
     b54:	de bf       	out	0x3e, r29	; 62
     b56:	0f be       	out	0x3f, r0	; 63
     b58:	cd bf       	out	0x3d, r28	; 61
     b5a:	9d 83       	std	Y+5, r25	; 0x05
     b5c:	8c 83       	std	Y+4, r24	; 0x04
     b5e:	6e 83       	std	Y+6, r22	; 0x06
     b60:	4f 83       	std	Y+7, r20	; 0x07
signed portBASE_TYPE xReturn;
corCRCB *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( corCRCB * ) pvPortMalloc( sizeof( corCRCB ) );
     b62:	8a e1       	ldi	r24, 0x1A	; 26
     b64:	90 e0       	ldi	r25, 0x00	; 0
     b66:	0e 94 7b 08 	call	0x10f6	; 0x10f6 <pvPortMalloc>
     b6a:	9a 83       	std	Y+2, r25	; 0x02
     b6c:	89 83       	std	Y+1, r24	; 0x01
	if( pxCoRoutine )
     b6e:	89 81       	ldd	r24, Y+1	; 0x01
     b70:	9a 81       	ldd	r25, Y+2	; 0x02
     b72:	00 97       	sbiw	r24, 0x00	; 0
     b74:	09 f4       	brne	.+2      	; 0xb78 <xCoRoutineCreate+0x32>
     b76:	6f c0       	rjmp	.+222    	; 0xc56 <xCoRoutineCreate+0x110>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
     b78:	80 91 34 01 	lds	r24, 0x0134
     b7c:	90 91 35 01 	lds	r25, 0x0135
     b80:	00 97       	sbiw	r24, 0x00	; 0
     b82:	41 f4       	brne	.+16     	; 0xb94 <xCoRoutineCreate+0x4e>
		{
			pxCurrentCoRoutine = pxCoRoutine;
     b84:	89 81       	ldd	r24, Y+1	; 0x01
     b86:	9a 81       	ldd	r25, Y+2	; 0x02
     b88:	90 93 35 01 	sts	0x0135, r25
     b8c:	80 93 34 01 	sts	0x0134, r24
			prvInitialiseCoRoutineLists();
     b90:	0e 94 0a 08 	call	0x1014	; 0x1014 <prvInitialiseCoRoutineLists>
		}

		/* Check the priority is within limits. */
		if( uxPriority >= configMAX_CO_ROUTINE_PRIORITIES )
     b94:	8e 81       	ldd	r24, Y+6	; 0x06
     b96:	82 30       	cpi	r24, 0x02	; 2
     b98:	10 f0       	brcs	.+4      	; 0xb9e <xCoRoutineCreate+0x58>
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
     b9a:	81 e0       	ldi	r24, 0x01	; 1
     b9c:	8e 83       	std	Y+6, r24	; 0x06
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
     b9e:	e9 81       	ldd	r30, Y+1	; 0x01
     ba0:	fa 81       	ldd	r31, Y+2	; 0x02
     ba2:	11 8e       	std	Z+25, r1	; 0x19
     ba4:	10 8e       	std	Z+24, r1	; 0x18
		pxCoRoutine->uxPriority = uxPriority;
     ba6:	e9 81       	ldd	r30, Y+1	; 0x01
     ba8:	fa 81       	ldd	r31, Y+2	; 0x02
     baa:	8e 81       	ldd	r24, Y+6	; 0x06
     bac:	86 8b       	std	Z+22, r24	; 0x16
		pxCoRoutine->uxIndex = uxIndex;
     bae:	e9 81       	ldd	r30, Y+1	; 0x01
     bb0:	fa 81       	ldd	r31, Y+2	; 0x02
     bb2:	8f 81       	ldd	r24, Y+7	; 0x07
     bb4:	87 8b       	std	Z+23, r24	; 0x17
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
     bb6:	e9 81       	ldd	r30, Y+1	; 0x01
     bb8:	fa 81       	ldd	r31, Y+2	; 0x02
     bba:	8c 81       	ldd	r24, Y+4	; 0x04
     bbc:	9d 81       	ldd	r25, Y+5	; 0x05
     bbe:	91 83       	std	Z+1, r25	; 0x01
     bc0:	80 83       	st	Z, r24

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
     bc2:	89 81       	ldd	r24, Y+1	; 0x01
     bc4:	9a 81       	ldd	r25, Y+2	; 0x02
     bc6:	02 96       	adiw	r24, 0x02	; 2
     bc8:	0e 94 11 09 	call	0x1222	; 0x1222 <vListInitialiseItem>
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
     bcc:	89 81       	ldd	r24, Y+1	; 0x01
     bce:	9a 81       	ldd	r25, Y+2	; 0x02
     bd0:	0c 96       	adiw	r24, 0x0c	; 12
     bd2:	0e 94 11 09 	call	0x1222	; 0x1222 <vListInitialiseItem>

		/* Set the co-routine control block as a link back from the xListItem.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
     bd6:	e9 81       	ldd	r30, Y+1	; 0x01
     bd8:	fa 81       	ldd	r31, Y+2	; 0x02
     bda:	89 81       	ldd	r24, Y+1	; 0x01
     bdc:	9a 81       	ldd	r25, Y+2	; 0x02
     bde:	91 87       	std	Z+9, r25	; 0x09
     be0:	80 87       	std	Z+8, r24	; 0x08
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
     be2:	e9 81       	ldd	r30, Y+1	; 0x01
     be4:	fa 81       	ldd	r31, Y+2	; 0x02
     be6:	89 81       	ldd	r24, Y+1	; 0x01
     be8:	9a 81       	ldd	r25, Y+2	; 0x02
     bea:	93 8b       	std	Z+19, r25	; 0x13
     bec:	82 8b       	std	Z+18, r24	; 0x12
	
		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
     bee:	8e 81       	ldd	r24, Y+6	; 0x06
     bf0:	28 2f       	mov	r18, r24
     bf2:	30 e0       	ldi	r19, 0x00	; 0
     bf4:	85 e0       	ldi	r24, 0x05	; 5
     bf6:	90 e0       	ldi	r25, 0x00	; 0
     bf8:	82 1b       	sub	r24, r18
     bfa:	93 0b       	sbc	r25, r19
     bfc:	e9 81       	ldd	r30, Y+1	; 0x01
     bfe:	fa 81       	ldd	r31, Y+2	; 0x02
     c00:	95 87       	std	Z+13, r25	; 0x0d
     c02:	84 87       	std	Z+12, r24	; 0x0c
		
		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
     c04:	e9 81       	ldd	r30, Y+1	; 0x01
     c06:	fa 81       	ldd	r31, Y+2	; 0x02
     c08:	96 89       	ldd	r25, Z+22	; 0x16
     c0a:	80 91 36 01 	lds	r24, 0x0136
     c0e:	89 17       	cp	r24, r25
     c10:	28 f4       	brcc	.+10     	; 0xc1c <xCoRoutineCreate+0xd6>
     c12:	e9 81       	ldd	r30, Y+1	; 0x01
     c14:	fa 81       	ldd	r31, Y+2	; 0x02
     c16:	86 89       	ldd	r24, Z+22	; 0x16
     c18:	80 93 36 01 	sts	0x0136, r24
     c1c:	e9 81       	ldd	r30, Y+1	; 0x01
     c1e:	fa 81       	ldd	r31, Y+2	; 0x02
     c20:	86 89       	ldd	r24, Z+22	; 0x16
     c22:	28 2f       	mov	r18, r24
     c24:	30 e0       	ldi	r19, 0x00	; 0
     c26:	c9 01       	movw	r24, r18
     c28:	88 0f       	add	r24, r24
     c2a:	99 1f       	adc	r25, r25
     c2c:	88 0f       	add	r24, r24
     c2e:	99 1f       	adc	r25, r25
     c30:	88 0f       	add	r24, r24
     c32:	99 1f       	adc	r25, r25
     c34:	82 0f       	add	r24, r18
     c36:	93 1f       	adc	r25, r19
     c38:	ac 01       	movw	r20, r24
     c3a:	43 5c       	subi	r20, 0xC3	; 195
     c3c:	5e 4f       	sbci	r21, 0xFE	; 254
     c3e:	89 81       	ldd	r24, Y+1	; 0x01
     c40:	9a 81       	ldd	r25, Y+2	; 0x02
     c42:	9c 01       	movw	r18, r24
     c44:	2e 5f       	subi	r18, 0xFE	; 254
     c46:	3f 4f       	sbci	r19, 0xFF	; 255
     c48:	ca 01       	movw	r24, r20
     c4a:	b9 01       	movw	r22, r18
     c4c:	0e 94 21 09 	call	0x1242	; 0x1242 <vListInsertEnd>

		xReturn = pdPASS;
     c50:	81 e0       	ldi	r24, 0x01	; 1
     c52:	8b 83       	std	Y+3, r24	; 0x03
     c54:	02 c0       	rjmp	.+4      	; 0xc5a <xCoRoutineCreate+0x114>
	}
	else
	{		
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
     c56:	8f ef       	ldi	r24, 0xFF	; 255
     c58:	8b 83       	std	Y+3, r24	; 0x03
	}
	
	return xReturn;	
     c5a:	8b 81       	ldd	r24, Y+3	; 0x03
}
     c5c:	27 96       	adiw	r28, 0x07	; 7
     c5e:	0f b6       	in	r0, 0x3f	; 63
     c60:	f8 94       	cli
     c62:	de bf       	out	0x3e, r29	; 62
     c64:	0f be       	out	0x3f, r0	; 63
     c66:	cd bf       	out	0x3d, r28	; 61
     c68:	cf 91       	pop	r28
     c6a:	df 91       	pop	r29
     c6c:	08 95       	ret

00000c6e <vCoRoutineAddToDelayedList>:
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( portTickType xTicksToDelay, xList *pxEventList )
{
     c6e:	df 93       	push	r29
     c70:	cf 93       	push	r28
     c72:	00 d0       	rcall	.+0      	; 0xc74 <vCoRoutineAddToDelayedList+0x6>
     c74:	00 d0       	rcall	.+0      	; 0xc76 <vCoRoutineAddToDelayedList+0x8>
     c76:	00 d0       	rcall	.+0      	; 0xc78 <vCoRoutineAddToDelayedList+0xa>
     c78:	cd b7       	in	r28, 0x3d	; 61
     c7a:	de b7       	in	r29, 0x3e	; 62
     c7c:	9c 83       	std	Y+4, r25	; 0x04
     c7e:	8b 83       	std	Y+3, r24	; 0x03
     c80:	7e 83       	std	Y+6, r23	; 0x06
     c82:	6d 83       	std	Y+5, r22	; 0x05
portTickType xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
     c84:	20 91 37 01 	lds	r18, 0x0137
     c88:	30 91 38 01 	lds	r19, 0x0138
     c8c:	8b 81       	ldd	r24, Y+3	; 0x03
     c8e:	9c 81       	ldd	r25, Y+4	; 0x04
     c90:	82 0f       	add	r24, r18
     c92:	93 1f       	adc	r25, r19
     c94:	9a 83       	std	Y+2, r25	; 0x02
     c96:	89 83       	std	Y+1, r24	; 0x01

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	vListRemove( ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     c98:	80 91 34 01 	lds	r24, 0x0134
     c9c:	90 91 35 01 	lds	r25, 0x0135
     ca0:	02 96       	adiw	r24, 0x02	; 2
     ca2:	0e 94 d9 09 	call	0x13b2	; 0x13b2 <vListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
     ca6:	e0 91 34 01 	lds	r30, 0x0134
     caa:	f0 91 35 01 	lds	r31, 0x0135
     cae:	89 81       	ldd	r24, Y+1	; 0x01
     cb0:	9a 81       	ldd	r25, Y+2	; 0x02
     cb2:	93 83       	std	Z+3, r25	; 0x03
     cb4:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xCoRoutineTickCount )
     cb6:	20 91 37 01 	lds	r18, 0x0137
     cba:	30 91 38 01 	lds	r19, 0x0138
     cbe:	89 81       	ldd	r24, Y+1	; 0x01
     cc0:	9a 81       	ldd	r25, Y+2	; 0x02
     cc2:	82 17       	cp	r24, r18
     cc4:	93 07       	cpc	r25, r19
     cc6:	70 f4       	brcc	.+28     	; 0xce4 <vCoRoutineAddToDelayedList+0x76>
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     cc8:	80 91 63 01 	lds	r24, 0x0163
     ccc:	90 91 64 01 	lds	r25, 0x0164
     cd0:	20 91 34 01 	lds	r18, 0x0134
     cd4:	30 91 35 01 	lds	r19, 0x0135
     cd8:	2e 5f       	subi	r18, 0xFE	; 254
     cda:	3f 4f       	sbci	r19, 0xFF	; 255
     cdc:	b9 01       	movw	r22, r18
     cde:	0e 94 6d 09 	call	0x12da	; 0x12da <vListInsert>
     ce2:	0d c0       	rjmp	.+26     	; 0xcfe <vCoRoutineAddToDelayedList+0x90>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( xList * ) pxDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     ce4:	80 91 61 01 	lds	r24, 0x0161
     ce8:	90 91 62 01 	lds	r25, 0x0162
     cec:	20 91 34 01 	lds	r18, 0x0134
     cf0:	30 91 35 01 	lds	r19, 0x0135
     cf4:	2e 5f       	subi	r18, 0xFE	; 254
     cf6:	3f 4f       	sbci	r19, 0xFF	; 255
     cf8:	b9 01       	movw	r22, r18
     cfa:	0e 94 6d 09 	call	0x12da	; 0x12da <vListInsert>
	}

	if( pxEventList )
     cfe:	8d 81       	ldd	r24, Y+5	; 0x05
     d00:	9e 81       	ldd	r25, Y+6	; 0x06
     d02:	00 97       	sbiw	r24, 0x00	; 0
     d04:	61 f0       	breq	.+24     	; 0xd1e <vCoRoutineAddToDelayedList+0xb0>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
     d06:	80 91 34 01 	lds	r24, 0x0134
     d0a:	90 91 35 01 	lds	r25, 0x0135
     d0e:	9c 01       	movw	r18, r24
     d10:	24 5f       	subi	r18, 0xF4	; 244
     d12:	3f 4f       	sbci	r19, 0xFF	; 255
     d14:	8d 81       	ldd	r24, Y+5	; 0x05
     d16:	9e 81       	ldd	r25, Y+6	; 0x06
     d18:	b9 01       	movw	r22, r18
     d1a:	0e 94 6d 09 	call	0x12da	; 0x12da <vListInsert>
	}
}
     d1e:	26 96       	adiw	r28, 0x06	; 6
     d20:	0f b6       	in	r0, 0x3f	; 63
     d22:	f8 94       	cli
     d24:	de bf       	out	0x3e, r29	; 62
     d26:	0f be       	out	0x3f, r0	; 63
     d28:	cd bf       	out	0x3d, r28	; 61
     d2a:	cf 91       	pop	r28
     d2c:	df 91       	pop	r29
     d2e:	08 95       	ret

00000d30 <prvCheckPendingReadyList>:
/*-----------------------------------------------------------*/

static void prvCheckPendingReadyList( void )
{
     d30:	df 93       	push	r29
     d32:	cf 93       	push	r28
     d34:	00 d0       	rcall	.+0      	; 0xd36 <prvCheckPendingReadyList+0x6>
     d36:	cd b7       	in	r28, 0x3d	; 61
     d38:	de b7       	in	r29, 0x3e	; 62
     d3a:	3a c0       	rjmp	.+116    	; 0xdb0 <prvCheckPendingReadyList+0x80>
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
	{
		corCRCB *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
     d3c:	f8 94       	cli
		{	
			pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );			
     d3e:	e0 91 6a 01 	lds	r30, 0x016A
     d42:	f0 91 6b 01 	lds	r31, 0x016B
     d46:	86 81       	ldd	r24, Z+6	; 0x06
     d48:	97 81       	ldd	r25, Z+7	; 0x07
     d4a:	9a 83       	std	Y+2, r25	; 0x02
     d4c:	89 83       	std	Y+1, r24	; 0x01
			vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
     d4e:	89 81       	ldd	r24, Y+1	; 0x01
     d50:	9a 81       	ldd	r25, Y+2	; 0x02
     d52:	0c 96       	adiw	r24, 0x0c	; 12
     d54:	0e 94 d9 09 	call	0x13b2	; 0x13b2 <vListRemove>
		}
		portENABLE_INTERRUPTS();
     d58:	78 94       	sei

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
     d5a:	89 81       	ldd	r24, Y+1	; 0x01
     d5c:	9a 81       	ldd	r25, Y+2	; 0x02
     d5e:	02 96       	adiw	r24, 0x02	; 2
     d60:	0e 94 d9 09 	call	0x13b2	; 0x13b2 <vListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
     d64:	e9 81       	ldd	r30, Y+1	; 0x01
     d66:	fa 81       	ldd	r31, Y+2	; 0x02
     d68:	96 89       	ldd	r25, Z+22	; 0x16
     d6a:	80 91 36 01 	lds	r24, 0x0136
     d6e:	89 17       	cp	r24, r25
     d70:	28 f4       	brcc	.+10     	; 0xd7c <prvCheckPendingReadyList+0x4c>
     d72:	e9 81       	ldd	r30, Y+1	; 0x01
     d74:	fa 81       	ldd	r31, Y+2	; 0x02
     d76:	86 89       	ldd	r24, Z+22	; 0x16
     d78:	80 93 36 01 	sts	0x0136, r24
     d7c:	e9 81       	ldd	r30, Y+1	; 0x01
     d7e:	fa 81       	ldd	r31, Y+2	; 0x02
     d80:	86 89       	ldd	r24, Z+22	; 0x16
     d82:	28 2f       	mov	r18, r24
     d84:	30 e0       	ldi	r19, 0x00	; 0
     d86:	c9 01       	movw	r24, r18
     d88:	88 0f       	add	r24, r24
     d8a:	99 1f       	adc	r25, r25
     d8c:	88 0f       	add	r24, r24
     d8e:	99 1f       	adc	r25, r25
     d90:	88 0f       	add	r24, r24
     d92:	99 1f       	adc	r25, r25
     d94:	82 0f       	add	r24, r18
     d96:	93 1f       	adc	r25, r19
     d98:	ac 01       	movw	r20, r24
     d9a:	43 5c       	subi	r20, 0xC3	; 195
     d9c:	5e 4f       	sbci	r21, 0xFE	; 254
     d9e:	89 81       	ldd	r24, Y+1	; 0x01
     da0:	9a 81       	ldd	r25, Y+2	; 0x02
     da2:	9c 01       	movw	r18, r24
     da4:	2e 5f       	subi	r18, 0xFE	; 254
     da6:	3f 4f       	sbci	r19, 0xFF	; 255
     da8:	ca 01       	movw	r24, r20
     daa:	b9 01       	movw	r22, r18
     dac:	0e 94 21 09 	call	0x1242	; 0x1242 <vListInsertEnd>
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
     db0:	80 91 65 01 	lds	r24, 0x0165
     db4:	88 23       	and	r24, r24
     db6:	09 f0       	breq	.+2      	; 0xdba <prvCheckPendingReadyList+0x8a>
     db8:	c1 cf       	rjmp	.-126    	; 0xd3c <prvCheckPendingReadyList+0xc>
		portENABLE_INTERRUPTS();

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
	}
}
     dba:	0f 90       	pop	r0
     dbc:	0f 90       	pop	r0
     dbe:	cf 91       	pop	r28
     dc0:	df 91       	pop	r29
     dc2:	08 95       	ret

00000dc4 <prvCheckDelayedList>:
/*-----------------------------------------------------------*/

static void prvCheckDelayedList( void )
{
     dc4:	df 93       	push	r29
     dc6:	cf 93       	push	r28
     dc8:	00 d0       	rcall	.+0      	; 0xdca <prvCheckDelayedList+0x6>
     dca:	00 d0       	rcall	.+0      	; 0xdcc <prvCheckDelayedList+0x8>
     dcc:	cd b7       	in	r28, 0x3d	; 61
     dce:	de b7       	in	r29, 0x3e	; 62
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
     dd0:	0e 94 df 14 	call	0x29be	; 0x29be <xTaskGetTickCount>
     dd4:	20 91 39 01 	lds	r18, 0x0139
     dd8:	30 91 3a 01 	lds	r19, 0x013A
     ddc:	82 1b       	sub	r24, r18
     dde:	93 0b       	sbc	r25, r19
     de0:	90 93 3c 01 	sts	0x013C, r25
     de4:	80 93 3b 01 	sts	0x013B, r24
     de8:	85 c0       	rjmp	.+266    	; 0xef4 <prvCheckDelayedList+0x130>
	while( xPassedTicks )
	{
		xCoRoutineTickCount++;
     dea:	80 91 37 01 	lds	r24, 0x0137
     dee:	90 91 38 01 	lds	r25, 0x0138
     df2:	01 96       	adiw	r24, 0x01	; 1
     df4:	90 93 38 01 	sts	0x0138, r25
     df8:	80 93 37 01 	sts	0x0137, r24
		xPassedTicks--;
     dfc:	80 91 3b 01 	lds	r24, 0x013B
     e00:	90 91 3c 01 	lds	r25, 0x013C
     e04:	01 97       	sbiw	r24, 0x01	; 1
     e06:	90 93 3c 01 	sts	0x013C, r25
     e0a:	80 93 3b 01 	sts	0x013B, r24

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
     e0e:	80 91 37 01 	lds	r24, 0x0137
     e12:	90 91 38 01 	lds	r25, 0x0138
     e16:	00 97       	sbiw	r24, 0x00	; 0
     e18:	09 f0       	breq	.+2      	; 0xe1c <prvCheckDelayedList+0x58>
     e1a:	64 c0       	rjmp	.+200    	; 0xee4 <prvCheckDelayedList+0x120>
		{
			xList * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
     e1c:	80 91 61 01 	lds	r24, 0x0161
     e20:	90 91 62 01 	lds	r25, 0x0162
     e24:	9a 83       	std	Y+2, r25	; 0x02
     e26:	89 83       	std	Y+1, r24	; 0x01
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
     e28:	80 91 63 01 	lds	r24, 0x0163
     e2c:	90 91 64 01 	lds	r25, 0x0164
     e30:	90 93 62 01 	sts	0x0162, r25
     e34:	80 93 61 01 	sts	0x0161, r24
			pxOverflowDelayedCoRoutineList = pxTemp;
     e38:	89 81       	ldd	r24, Y+1	; 0x01
     e3a:	9a 81       	ldd	r25, Y+2	; 0x02
     e3c:	90 93 64 01 	sts	0x0164, r25
     e40:	80 93 63 01 	sts	0x0163, r24
     e44:	4f c0       	rjmp	.+158    	; 0xee4 <prvCheckDelayedList+0x120>
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
		{
			pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
     e46:	e0 91 61 01 	lds	r30, 0x0161
     e4a:	f0 91 62 01 	lds	r31, 0x0162
     e4e:	05 80       	ldd	r0, Z+5	; 0x05
     e50:	f6 81       	ldd	r31, Z+6	; 0x06
     e52:	e0 2d       	mov	r30, r0
     e54:	86 81       	ldd	r24, Z+6	; 0x06
     e56:	97 81       	ldd	r25, Z+7	; 0x07
     e58:	9c 83       	std	Y+4, r25	; 0x04
     e5a:	8b 83       	std	Y+3, r24	; 0x03

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )				
     e5c:	eb 81       	ldd	r30, Y+3	; 0x03
     e5e:	fc 81       	ldd	r31, Y+4	; 0x04
     e60:	22 81       	ldd	r18, Z+2	; 0x02
     e62:	33 81       	ldd	r19, Z+3	; 0x03
     e64:	80 91 37 01 	lds	r24, 0x0137
     e68:	90 91 38 01 	lds	r25, 0x0138
     e6c:	82 17       	cp	r24, r18
     e6e:	93 07       	cpc	r25, r19
     e70:	08 f4       	brcc	.+2      	; 0xe74 <prvCheckDelayedList+0xb0>
     e72:	40 c0       	rjmp	.+128    	; 0xef4 <prvCheckDelayedList+0x130>
			{			
				/* Timeout not yet expired. */																			
				break;																				
			}																						

			portDISABLE_INTERRUPTS();
     e74:	f8 94       	cli
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				vListRemove( &( pxCRCB->xGenericListItem ) );											
     e76:	8b 81       	ldd	r24, Y+3	; 0x03
     e78:	9c 81       	ldd	r25, Y+4	; 0x04
     e7a:	02 96       	adiw	r24, 0x02	; 2
     e7c:	0e 94 d9 09 	call	0x13b2	; 0x13b2 <vListRemove>

				/* Is the co-routine waiting on an event also? */												
				if( pxCRCB->xEventListItem.pvContainer )													
     e80:	eb 81       	ldd	r30, Y+3	; 0x03
     e82:	fc 81       	ldd	r31, Y+4	; 0x04
     e84:	84 89       	ldd	r24, Z+20	; 0x14
     e86:	95 89       	ldd	r25, Z+21	; 0x15
     e88:	00 97       	sbiw	r24, 0x00	; 0
     e8a:	29 f0       	breq	.+10     	; 0xe96 <prvCheckDelayedList+0xd2>
				{															
					vListRemove( &( pxCRCB->xEventListItem ) );											
     e8c:	8b 81       	ldd	r24, Y+3	; 0x03
     e8e:	9c 81       	ldd	r25, Y+4	; 0x04
     e90:	0c 96       	adiw	r24, 0x0c	; 12
     e92:	0e 94 d9 09 	call	0x13b2	; 0x13b2 <vListRemove>
				}
			}
			portENABLE_INTERRUPTS();
     e96:	78 94       	sei

			prvAddCoRoutineToReadyQueue( pxCRCB );													
     e98:	eb 81       	ldd	r30, Y+3	; 0x03
     e9a:	fc 81       	ldd	r31, Y+4	; 0x04
     e9c:	96 89       	ldd	r25, Z+22	; 0x16
     e9e:	80 91 36 01 	lds	r24, 0x0136
     ea2:	89 17       	cp	r24, r25
     ea4:	28 f4       	brcc	.+10     	; 0xeb0 <prvCheckDelayedList+0xec>
     ea6:	eb 81       	ldd	r30, Y+3	; 0x03
     ea8:	fc 81       	ldd	r31, Y+4	; 0x04
     eaa:	86 89       	ldd	r24, Z+22	; 0x16
     eac:	80 93 36 01 	sts	0x0136, r24
     eb0:	eb 81       	ldd	r30, Y+3	; 0x03
     eb2:	fc 81       	ldd	r31, Y+4	; 0x04
     eb4:	86 89       	ldd	r24, Z+22	; 0x16
     eb6:	28 2f       	mov	r18, r24
     eb8:	30 e0       	ldi	r19, 0x00	; 0
     eba:	c9 01       	movw	r24, r18
     ebc:	88 0f       	add	r24, r24
     ebe:	99 1f       	adc	r25, r25
     ec0:	88 0f       	add	r24, r24
     ec2:	99 1f       	adc	r25, r25
     ec4:	88 0f       	add	r24, r24
     ec6:	99 1f       	adc	r25, r25
     ec8:	82 0f       	add	r24, r18
     eca:	93 1f       	adc	r25, r19
     ecc:	ac 01       	movw	r20, r24
     ece:	43 5c       	subi	r20, 0xC3	; 195
     ed0:	5e 4f       	sbci	r21, 0xFE	; 254
     ed2:	8b 81       	ldd	r24, Y+3	; 0x03
     ed4:	9c 81       	ldd	r25, Y+4	; 0x04
     ed6:	9c 01       	movw	r18, r24
     ed8:	2e 5f       	subi	r18, 0xFE	; 254
     eda:	3f 4f       	sbci	r19, 0xFF	; 255
     edc:	ca 01       	movw	r24, r20
     ede:	b9 01       	movw	r22, r18
     ee0:	0e 94 21 09 	call	0x1242	; 0x1242 <vListInsertEnd>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
     ee4:	e0 91 61 01 	lds	r30, 0x0161
     ee8:	f0 91 62 01 	lds	r31, 0x0162
     eec:	80 81       	ld	r24, Z
     eee:	88 23       	and	r24, r24
     ef0:	09 f0       	breq	.+2      	; 0xef4 <prvCheckDelayedList+0x130>
     ef2:	a9 cf       	rjmp	.-174    	; 0xe46 <prvCheckDelayedList+0x82>
static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
     ef4:	80 91 3b 01 	lds	r24, 0x013B
     ef8:	90 91 3c 01 	lds	r25, 0x013C
     efc:	00 97       	sbiw	r24, 0x00	; 0
     efe:	09 f0       	breq	.+2      	; 0xf02 <prvCheckDelayedList+0x13e>
     f00:	74 cf       	rjmp	.-280    	; 0xdea <prvCheckDelayedList+0x26>

			prvAddCoRoutineToReadyQueue( pxCRCB );													
		}																									
	}

	xLastTickCount = xCoRoutineTickCount;
     f02:	80 91 37 01 	lds	r24, 0x0137
     f06:	90 91 38 01 	lds	r25, 0x0138
     f0a:	90 93 3a 01 	sts	0x013A, r25
     f0e:	80 93 39 01 	sts	0x0139, r24
}
     f12:	0f 90       	pop	r0
     f14:	0f 90       	pop	r0
     f16:	0f 90       	pop	r0
     f18:	0f 90       	pop	r0
     f1a:	cf 91       	pop	r28
     f1c:	df 91       	pop	r29
     f1e:	08 95       	ret

00000f20 <vCoRoutineSchedule>:
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
     f20:	df 93       	push	r29
     f22:	cf 93       	push	r28
     f24:	00 d0       	rcall	.+0      	; 0xf26 <vCoRoutineSchedule+0x6>
     f26:	cd b7       	in	r28, 0x3d	; 61
     f28:	de b7       	in	r29, 0x3e	; 62
	/* See if any co-routines readied by events need moving to the ready lists. */
	prvCheckPendingReadyList();
     f2a:	0e 94 98 06 	call	0xd30	; 0xd30 <prvCheckPendingReadyList>

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();
     f2e:	0e 94 e2 06 	call	0xdc4	; 0xdc4 <prvCheckDelayedList>
     f32:	0a c0       	rjmp	.+20     	; 0xf48 <vCoRoutineSchedule+0x28>

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
	{
		if( uxTopCoRoutineReadyPriority == 0 )
     f34:	80 91 36 01 	lds	r24, 0x0136
     f38:	88 23       	and	r24, r24
     f3a:	09 f4       	brne	.+2      	; 0xf3e <vCoRoutineSchedule+0x1e>
     f3c:	66 c0       	rjmp	.+204    	; 0x100a <vCoRoutineSchedule+0xea>
		{
			/* No more co-routines to check. */
			return;
		}
		--uxTopCoRoutineReadyPriority;
     f3e:	80 91 36 01 	lds	r24, 0x0136
     f42:	81 50       	subi	r24, 0x01	; 1
     f44:	80 93 36 01 	sts	0x0136, r24

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
     f48:	80 91 36 01 	lds	r24, 0x0136
     f4c:	28 2f       	mov	r18, r24
     f4e:	30 e0       	ldi	r19, 0x00	; 0
     f50:	c9 01       	movw	r24, r18
     f52:	88 0f       	add	r24, r24
     f54:	99 1f       	adc	r25, r25
     f56:	88 0f       	add	r24, r24
     f58:	99 1f       	adc	r25, r25
     f5a:	88 0f       	add	r24, r24
     f5c:	99 1f       	adc	r25, r25
     f5e:	82 0f       	add	r24, r18
     f60:	93 1f       	adc	r25, r19
     f62:	fc 01       	movw	r30, r24
     f64:	e3 5c       	subi	r30, 0xC3	; 195
     f66:	fe 4f       	sbci	r31, 0xFE	; 254
     f68:	80 81       	ld	r24, Z
     f6a:	88 23       	and	r24, r24
     f6c:	19 f3       	breq	.-58     	; 0xf34 <vCoRoutineSchedule+0x14>
		--uxTopCoRoutineReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
     f6e:	80 91 36 01 	lds	r24, 0x0136
     f72:	28 2f       	mov	r18, r24
     f74:	30 e0       	ldi	r19, 0x00	; 0
     f76:	c9 01       	movw	r24, r18
     f78:	88 0f       	add	r24, r24
     f7a:	99 1f       	adc	r25, r25
     f7c:	88 0f       	add	r24, r24
     f7e:	99 1f       	adc	r25, r25
     f80:	88 0f       	add	r24, r24
     f82:	99 1f       	adc	r25, r25
     f84:	82 0f       	add	r24, r18
     f86:	93 1f       	adc	r25, r19
     f88:	83 5c       	subi	r24, 0xC3	; 195
     f8a:	9e 4f       	sbci	r25, 0xFE	; 254
     f8c:	9a 83       	std	Y+2, r25	; 0x02
     f8e:	89 83       	std	Y+1, r24	; 0x01
     f90:	e9 81       	ldd	r30, Y+1	; 0x01
     f92:	fa 81       	ldd	r31, Y+2	; 0x02
     f94:	01 80       	ldd	r0, Z+1	; 0x01
     f96:	f2 81       	ldd	r31, Z+2	; 0x02
     f98:	e0 2d       	mov	r30, r0
     f9a:	82 81       	ldd	r24, Z+2	; 0x02
     f9c:	93 81       	ldd	r25, Z+3	; 0x03
     f9e:	e9 81       	ldd	r30, Y+1	; 0x01
     fa0:	fa 81       	ldd	r31, Y+2	; 0x02
     fa2:	92 83       	std	Z+2, r25	; 0x02
     fa4:	81 83       	std	Z+1, r24	; 0x01
     fa6:	e9 81       	ldd	r30, Y+1	; 0x01
     fa8:	fa 81       	ldd	r31, Y+2	; 0x02
     faa:	21 81       	ldd	r18, Z+1	; 0x01
     fac:	32 81       	ldd	r19, Z+2	; 0x02
     fae:	89 81       	ldd	r24, Y+1	; 0x01
     fb0:	9a 81       	ldd	r25, Y+2	; 0x02
     fb2:	03 96       	adiw	r24, 0x03	; 3
     fb4:	28 17       	cp	r18, r24
     fb6:	39 07       	cpc	r19, r25
     fb8:	59 f4       	brne	.+22     	; 0xfd0 <vCoRoutineSchedule+0xb0>
     fba:	e9 81       	ldd	r30, Y+1	; 0x01
     fbc:	fa 81       	ldd	r31, Y+2	; 0x02
     fbe:	01 80       	ldd	r0, Z+1	; 0x01
     fc0:	f2 81       	ldd	r31, Z+2	; 0x02
     fc2:	e0 2d       	mov	r30, r0
     fc4:	82 81       	ldd	r24, Z+2	; 0x02
     fc6:	93 81       	ldd	r25, Z+3	; 0x03
     fc8:	e9 81       	ldd	r30, Y+1	; 0x01
     fca:	fa 81       	ldd	r31, Y+2	; 0x02
     fcc:	92 83       	std	Z+2, r25	; 0x02
     fce:	81 83       	std	Z+1, r24	; 0x01
     fd0:	e9 81       	ldd	r30, Y+1	; 0x01
     fd2:	fa 81       	ldd	r31, Y+2	; 0x02
     fd4:	01 80       	ldd	r0, Z+1	; 0x01
     fd6:	f2 81       	ldd	r31, Z+2	; 0x02
     fd8:	e0 2d       	mov	r30, r0
     fda:	86 81       	ldd	r24, Z+6	; 0x06
     fdc:	97 81       	ldd	r25, Z+7	; 0x07
     fde:	90 93 35 01 	sts	0x0135, r25
     fe2:	80 93 34 01 	sts	0x0134, r24

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
     fe6:	e0 91 34 01 	lds	r30, 0x0134
     fea:	f0 91 35 01 	lds	r31, 0x0135
     fee:	40 81       	ld	r20, Z
     ff0:	51 81       	ldd	r21, Z+1	; 0x01
     ff2:	80 91 34 01 	lds	r24, 0x0134
     ff6:	90 91 35 01 	lds	r25, 0x0135
     ffa:	e0 91 34 01 	lds	r30, 0x0134
     ffe:	f0 91 35 01 	lds	r31, 0x0135
    1002:	27 89       	ldd	r18, Z+23	; 0x17
    1004:	62 2f       	mov	r22, r18
    1006:	fa 01       	movw	r30, r20
    1008:	09 95       	icall

	return;
}
    100a:	0f 90       	pop	r0
    100c:	0f 90       	pop	r0
    100e:	cf 91       	pop	r28
    1010:	df 91       	pop	r29
    1012:	08 95       	ret

00001014 <prvInitialiseCoRoutineLists>:
/*-----------------------------------------------------------*/

static void prvInitialiseCoRoutineLists( void )
{
    1014:	df 93       	push	r29
    1016:	cf 93       	push	r28
    1018:	0f 92       	push	r0
    101a:	cd b7       	in	r28, 0x3d	; 61
    101c:	de b7       	in	r29, 0x3e	; 62
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
    101e:	19 82       	std	Y+1, r1	; 0x01
    1020:	13 c0       	rjmp	.+38     	; 0x1048 <prvInitialiseCoRoutineLists+0x34>
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
    1022:	89 81       	ldd	r24, Y+1	; 0x01
    1024:	28 2f       	mov	r18, r24
    1026:	30 e0       	ldi	r19, 0x00	; 0
    1028:	c9 01       	movw	r24, r18
    102a:	88 0f       	add	r24, r24
    102c:	99 1f       	adc	r25, r25
    102e:	88 0f       	add	r24, r24
    1030:	99 1f       	adc	r25, r25
    1032:	88 0f       	add	r24, r24
    1034:	99 1f       	adc	r25, r25
    1036:	82 0f       	add	r24, r18
    1038:	93 1f       	adc	r25, r19
    103a:	83 5c       	subi	r24, 0xC3	; 195
    103c:	9e 4f       	sbci	r25, 0xFE	; 254
    103e:	0e 94 e7 08 	call	0x11ce	; 0x11ce <vListInitialise>

static void prvInitialiseCoRoutineLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
    1042:	89 81       	ldd	r24, Y+1	; 0x01
    1044:	8f 5f       	subi	r24, 0xFF	; 255
    1046:	89 83       	std	Y+1, r24	; 0x01
    1048:	89 81       	ldd	r24, Y+1	; 0x01
    104a:	82 30       	cpi	r24, 0x02	; 2
    104c:	50 f3       	brcs	.-44     	; 0x1022 <prvInitialiseCoRoutineLists+0xe>
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedCoRoutineList1 );
    104e:	8f e4       	ldi	r24, 0x4F	; 79
    1050:	91 e0       	ldi	r25, 0x01	; 1
    1052:	0e 94 e7 08 	call	0x11ce	; 0x11ce <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedCoRoutineList2 );
    1056:	88 e5       	ldi	r24, 0x58	; 88
    1058:	91 e0       	ldi	r25, 0x01	; 1
    105a:	0e 94 e7 08 	call	0x11ce	; 0x11ce <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyCoRoutineList );
    105e:	85 e6       	ldi	r24, 0x65	; 101
    1060:	91 e0       	ldi	r25, 0x01	; 1
    1062:	0e 94 e7 08 	call	0x11ce	; 0x11ce <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
    1066:	8f e4       	ldi	r24, 0x4F	; 79
    1068:	91 e0       	ldi	r25, 0x01	; 1
    106a:	90 93 62 01 	sts	0x0162, r25
    106e:	80 93 61 01 	sts	0x0161, r24
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
    1072:	88 e5       	ldi	r24, 0x58	; 88
    1074:	91 e0       	ldi	r25, 0x01	; 1
    1076:	90 93 64 01 	sts	0x0164, r25
    107a:	80 93 63 01 	sts	0x0163, r24
}
    107e:	0f 90       	pop	r0
    1080:	cf 91       	pop	r28
    1082:	df 91       	pop	r29
    1084:	08 95       	ret

00001086 <xCoRoutineRemoveFromEventList>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineRemoveFromEventList( const xList *pxEventList )
{
    1086:	df 93       	push	r29
    1088:	cf 93       	push	r28
    108a:	00 d0       	rcall	.+0      	; 0x108c <xCoRoutineRemoveFromEventList+0x6>
    108c:	00 d0       	rcall	.+0      	; 0x108e <xCoRoutineRemoveFromEventList+0x8>
    108e:	0f 92       	push	r0
    1090:	cd b7       	in	r28, 0x3d	; 61
    1092:	de b7       	in	r29, 0x3e	; 62
    1094:	9d 83       	std	Y+5, r25	; 0x05
    1096:	8c 83       	std	Y+4, r24	; 0x04
signed portBASE_TYPE xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list.  This function assumes that a
	check has already been made to ensure pxEventList is not empty. */
	pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    1098:	ec 81       	ldd	r30, Y+4	; 0x04
    109a:	fd 81       	ldd	r31, Y+5	; 0x05
    109c:	05 80       	ldd	r0, Z+5	; 0x05
    109e:	f6 81       	ldd	r31, Z+6	; 0x06
    10a0:	e0 2d       	mov	r30, r0
    10a2:	86 81       	ldd	r24, Z+6	; 0x06
    10a4:	97 81       	ldd	r25, Z+7	; 0x07
    10a6:	9b 83       	std	Y+3, r25	; 0x03
    10a8:	8a 83       	std	Y+2, r24	; 0x02
	vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    10aa:	8a 81       	ldd	r24, Y+2	; 0x02
    10ac:	9b 81       	ldd	r25, Y+3	; 0x03
    10ae:	0c 96       	adiw	r24, 0x0c	; 12
    10b0:	0e 94 d9 09 	call	0x13b2	; 0x13b2 <vListRemove>
	vListInsertEnd( ( xList * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
    10b4:	8a 81       	ldd	r24, Y+2	; 0x02
    10b6:	9b 81       	ldd	r25, Y+3	; 0x03
    10b8:	9c 01       	movw	r18, r24
    10ba:	24 5f       	subi	r18, 0xF4	; 244
    10bc:	3f 4f       	sbci	r19, 0xFF	; 255
    10be:	85 e6       	ldi	r24, 0x65	; 101
    10c0:	91 e0       	ldi	r25, 0x01	; 1
    10c2:	b9 01       	movw	r22, r18
    10c4:	0e 94 21 09 	call	0x1242	; 0x1242 <vListInsertEnd>

	if( pxUnblockedCRCB->uxPriority >= pxCurrentCoRoutine->uxPriority )
    10c8:	ea 81       	ldd	r30, Y+2	; 0x02
    10ca:	fb 81       	ldd	r31, Y+3	; 0x03
    10cc:	96 89       	ldd	r25, Z+22	; 0x16
    10ce:	e0 91 34 01 	lds	r30, 0x0134
    10d2:	f0 91 35 01 	lds	r31, 0x0135
    10d6:	86 89       	ldd	r24, Z+22	; 0x16
    10d8:	98 17       	cp	r25, r24
    10da:	18 f0       	brcs	.+6      	; 0x10e2 <xCoRoutineRemoveFromEventList+0x5c>
	{
		xReturn = pdTRUE;
    10dc:	81 e0       	ldi	r24, 0x01	; 1
    10de:	89 83       	std	Y+1, r24	; 0x01
    10e0:	01 c0       	rjmp	.+2      	; 0x10e4 <xCoRoutineRemoveFromEventList+0x5e>
	}
	else
	{
		xReturn = pdFALSE;
    10e2:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    10e4:	89 81       	ldd	r24, Y+1	; 0x01
}
    10e6:	0f 90       	pop	r0
    10e8:	0f 90       	pop	r0
    10ea:	0f 90       	pop	r0
    10ec:	0f 90       	pop	r0
    10ee:	0f 90       	pop	r0
    10f0:	cf 91       	pop	r28
    10f2:	df 91       	pop	r29
    10f4:	08 95       	ret

000010f6 <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    10f6:	df 93       	push	r29
    10f8:	cf 93       	push	r28
    10fa:	00 d0       	rcall	.+0      	; 0x10fc <pvPortMalloc+0x6>
    10fc:	00 d0       	rcall	.+0      	; 0x10fe <pvPortMalloc+0x8>
    10fe:	cd b7       	in	r28, 0x3d	; 61
    1100:	de b7       	in	r29, 0x3e	; 62
    1102:	9c 83       	std	Y+4, r25	; 0x04
    1104:	8b 83       	std	Y+3, r24	; 0x03
void *pvReturn = NULL; 
    1106:	1a 82       	std	Y+2, r1	; 0x02
    1108:	19 82       	std	Y+1, r1	; 0x01
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
    110a:	0e 94 49 14 	call	0x2892	; 0x2892 <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
    110e:	80 91 6e 01 	lds	r24, 0x016E
    1112:	90 91 6f 01 	lds	r25, 0x016F
    1116:	2b 81       	ldd	r18, Y+3	; 0x03
    1118:	3c 81       	ldd	r19, Y+4	; 0x04
    111a:	82 0f       	add	r24, r18
    111c:	93 1f       	adc	r25, r19
    111e:	23 e0       	ldi	r18, 0x03	; 3
    1120:	88 3e       	cpi	r24, 0xE8	; 232
    1122:	92 07       	cpc	r25, r18
    1124:	18 f5       	brcc	.+70     	; 0x116c <pvPortMalloc+0x76>
    1126:	20 91 6e 01 	lds	r18, 0x016E
    112a:	30 91 6f 01 	lds	r19, 0x016F
    112e:	8b 81       	ldd	r24, Y+3	; 0x03
    1130:	9c 81       	ldd	r25, Y+4	; 0x04
    1132:	28 0f       	add	r18, r24
    1134:	39 1f       	adc	r19, r25
    1136:	80 91 6e 01 	lds	r24, 0x016E
    113a:	90 91 6f 01 	lds	r25, 0x016F
    113e:	82 17       	cp	r24, r18
    1140:	93 07       	cpc	r25, r19
    1142:	a0 f4       	brcc	.+40     	; 0x116c <pvPortMalloc+0x76>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
    1144:	80 91 6e 01 	lds	r24, 0x016E
    1148:	90 91 6f 01 	lds	r25, 0x016F
    114c:	80 59       	subi	r24, 0x90	; 144
    114e:	9e 4f       	sbci	r25, 0xFE	; 254
    1150:	9a 83       	std	Y+2, r25	; 0x02
    1152:	89 83       	std	Y+1, r24	; 0x01
			xNextFreeByte += xWantedSize;			
    1154:	20 91 6e 01 	lds	r18, 0x016E
    1158:	30 91 6f 01 	lds	r19, 0x016F
    115c:	8b 81       	ldd	r24, Y+3	; 0x03
    115e:	9c 81       	ldd	r25, Y+4	; 0x04
    1160:	82 0f       	add	r24, r18
    1162:	93 1f       	adc	r25, r19
    1164:	90 93 6f 01 	sts	0x016F, r25
    1168:	80 93 6e 01 	sts	0x016E, r24
		}	
	}
	xTaskResumeAll();
    116c:	0e 94 55 14 	call	0x28aa	; 0x28aa <xTaskResumeAll>
			vApplicationMallocFailedHook();
		}
	}
	#endif	

	return pvReturn;
    1170:	89 81       	ldd	r24, Y+1	; 0x01
    1172:	9a 81       	ldd	r25, Y+2	; 0x02
}
    1174:	0f 90       	pop	r0
    1176:	0f 90       	pop	r0
    1178:	0f 90       	pop	r0
    117a:	0f 90       	pop	r0
    117c:	cf 91       	pop	r28
    117e:	df 91       	pop	r29
    1180:	08 95       	ret

00001182 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    1182:	df 93       	push	r29
    1184:	cf 93       	push	r28
    1186:	00 d0       	rcall	.+0      	; 0x1188 <vPortFree+0x6>
    1188:	cd b7       	in	r28, 0x3d	; 61
    118a:	de b7       	in	r29, 0x3e	; 62
    118c:	9a 83       	std	Y+2, r25	; 0x02
    118e:	89 83       	std	Y+1, r24	; 0x01
	/* Memory cannot be freed using this scheme.  See heap_2.c and heap_3.c 
	for alternative implementations, and the memory management pages of 
	http://www.FreeRTOS.org for more information. */
	( void ) pv;
}
    1190:	0f 90       	pop	r0
    1192:	0f 90       	pop	r0
    1194:	cf 91       	pop	r28
    1196:	df 91       	pop	r29
    1198:	08 95       	ret

0000119a <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
    119a:	df 93       	push	r29
    119c:	cf 93       	push	r28
    119e:	cd b7       	in	r28, 0x3d	; 61
    11a0:	de b7       	in	r29, 0x3e	; 62
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
    11a2:	10 92 6f 01 	sts	0x016F, r1
    11a6:	10 92 6e 01 	sts	0x016E, r1
}
    11aa:	cf 91       	pop	r28
    11ac:	df 91       	pop	r29
    11ae:	08 95       	ret

000011b0 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
    11b0:	df 93       	push	r29
    11b2:	cf 93       	push	r28
    11b4:	cd b7       	in	r28, 0x3d	; 61
    11b6:	de b7       	in	r29, 0x3e	; 62
	return ( configTOTAL_HEAP_SIZE - xNextFreeByte );
    11b8:	20 91 6e 01 	lds	r18, 0x016E
    11bc:	30 91 6f 01 	lds	r19, 0x016F
    11c0:	88 ee       	ldi	r24, 0xE8	; 232
    11c2:	93 e0       	ldi	r25, 0x03	; 3
    11c4:	82 1b       	sub	r24, r18
    11c6:	93 0b       	sbc	r25, r19
}
    11c8:	cf 91       	pop	r28
    11ca:	df 91       	pop	r29
    11cc:	08 95       	ret

000011ce <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
    11ce:	df 93       	push	r29
    11d0:	cf 93       	push	r28
    11d2:	00 d0       	rcall	.+0      	; 0x11d4 <vListInitialise+0x6>
    11d4:	cd b7       	in	r28, 0x3d	; 61
    11d6:	de b7       	in	r29, 0x3e	; 62
    11d8:	9a 83       	std	Y+2, r25	; 0x02
    11da:	89 83       	std	Y+1, r24	; 0x01
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
    11dc:	89 81       	ldd	r24, Y+1	; 0x01
    11de:	9a 81       	ldd	r25, Y+2	; 0x02
    11e0:	03 96       	adiw	r24, 0x03	; 3
    11e2:	e9 81       	ldd	r30, Y+1	; 0x01
    11e4:	fa 81       	ldd	r31, Y+2	; 0x02
    11e6:	92 83       	std	Z+2, r25	; 0x02
    11e8:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    11ea:	e9 81       	ldd	r30, Y+1	; 0x01
    11ec:	fa 81       	ldd	r31, Y+2	; 0x02
    11ee:	8f ef       	ldi	r24, 0xFF	; 255
    11f0:	9f ef       	ldi	r25, 0xFF	; 255
    11f2:	94 83       	std	Z+4, r25	; 0x04
    11f4:	83 83       	std	Z+3, r24	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
    11f6:	89 81       	ldd	r24, Y+1	; 0x01
    11f8:	9a 81       	ldd	r25, Y+2	; 0x02
    11fa:	03 96       	adiw	r24, 0x03	; 3
    11fc:	e9 81       	ldd	r30, Y+1	; 0x01
    11fe:	fa 81       	ldd	r31, Y+2	; 0x02
    1200:	96 83       	std	Z+6, r25	; 0x06
    1202:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
    1204:	89 81       	ldd	r24, Y+1	; 0x01
    1206:	9a 81       	ldd	r25, Y+2	; 0x02
    1208:	03 96       	adiw	r24, 0x03	; 3
    120a:	e9 81       	ldd	r30, Y+1	; 0x01
    120c:	fa 81       	ldd	r31, Y+2	; 0x02
    120e:	90 87       	std	Z+8, r25	; 0x08
    1210:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
    1212:	e9 81       	ldd	r30, Y+1	; 0x01
    1214:	fa 81       	ldd	r31, Y+2	; 0x02
    1216:	10 82       	st	Z, r1
}
    1218:	0f 90       	pop	r0
    121a:	0f 90       	pop	r0
    121c:	cf 91       	pop	r28
    121e:	df 91       	pop	r29
    1220:	08 95       	ret

00001222 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
    1222:	df 93       	push	r29
    1224:	cf 93       	push	r28
    1226:	00 d0       	rcall	.+0      	; 0x1228 <vListInitialiseItem+0x6>
    1228:	cd b7       	in	r28, 0x3d	; 61
    122a:	de b7       	in	r29, 0x3e	; 62
    122c:	9a 83       	std	Y+2, r25	; 0x02
    122e:	89 83       	std	Y+1, r24	; 0x01
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    1230:	e9 81       	ldd	r30, Y+1	; 0x01
    1232:	fa 81       	ldd	r31, Y+2	; 0x02
    1234:	11 86       	std	Z+9, r1	; 0x09
    1236:	10 86       	std	Z+8, r1	; 0x08
}
    1238:	0f 90       	pop	r0
    123a:	0f 90       	pop	r0
    123c:	cf 91       	pop	r28
    123e:	df 91       	pop	r29
    1240:	08 95       	ret

00001242 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
    1242:	df 93       	push	r29
    1244:	cf 93       	push	r28
    1246:	00 d0       	rcall	.+0      	; 0x1248 <vListInsertEnd+0x6>
    1248:	00 d0       	rcall	.+0      	; 0x124a <vListInsertEnd+0x8>
    124a:	00 d0       	rcall	.+0      	; 0x124c <vListInsertEnd+0xa>
    124c:	cd b7       	in	r28, 0x3d	; 61
    124e:	de b7       	in	r29, 0x3e	; 62
    1250:	9c 83       	std	Y+4, r25	; 0x04
    1252:	8b 83       	std	Y+3, r24	; 0x03
    1254:	7e 83       	std	Y+6, r23	; 0x06
    1256:	6d 83       	std	Y+5, r22	; 0x05

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
    1258:	eb 81       	ldd	r30, Y+3	; 0x03
    125a:	fc 81       	ldd	r31, Y+4	; 0x04
    125c:	81 81       	ldd	r24, Z+1	; 0x01
    125e:	92 81       	ldd	r25, Z+2	; 0x02
    1260:	9a 83       	std	Y+2, r25	; 0x02
    1262:	89 83       	std	Y+1, r24	; 0x01

	pxNewListItem->pxNext = pxIndex->pxNext;
    1264:	e9 81       	ldd	r30, Y+1	; 0x01
    1266:	fa 81       	ldd	r31, Y+2	; 0x02
    1268:	82 81       	ldd	r24, Z+2	; 0x02
    126a:	93 81       	ldd	r25, Z+3	; 0x03
    126c:	ed 81       	ldd	r30, Y+5	; 0x05
    126e:	fe 81       	ldd	r31, Y+6	; 0x06
    1270:	93 83       	std	Z+3, r25	; 0x03
    1272:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxPrevious = pxList->pxIndex;
    1274:	eb 81       	ldd	r30, Y+3	; 0x03
    1276:	fc 81       	ldd	r31, Y+4	; 0x04
    1278:	81 81       	ldd	r24, Z+1	; 0x01
    127a:	92 81       	ldd	r25, Z+2	; 0x02
    127c:	ed 81       	ldd	r30, Y+5	; 0x05
    127e:	fe 81       	ldd	r31, Y+6	; 0x06
    1280:	95 83       	std	Z+5, r25	; 0x05
    1282:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    1284:	e9 81       	ldd	r30, Y+1	; 0x01
    1286:	fa 81       	ldd	r31, Y+2	; 0x02
    1288:	02 80       	ldd	r0, Z+2	; 0x02
    128a:	f3 81       	ldd	r31, Z+3	; 0x03
    128c:	e0 2d       	mov	r30, r0
    128e:	8d 81       	ldd	r24, Y+5	; 0x05
    1290:	9e 81       	ldd	r25, Y+6	; 0x06
    1292:	95 83       	std	Z+5, r25	; 0x05
    1294:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
    1296:	8d 81       	ldd	r24, Y+5	; 0x05
    1298:	9e 81       	ldd	r25, Y+6	; 0x06
    129a:	e9 81       	ldd	r30, Y+1	; 0x01
    129c:	fa 81       	ldd	r31, Y+2	; 0x02
    129e:	93 83       	std	Z+3, r25	; 0x03
    12a0:	82 83       	std	Z+2, r24	; 0x02
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
    12a2:	8d 81       	ldd	r24, Y+5	; 0x05
    12a4:	9e 81       	ldd	r25, Y+6	; 0x06
    12a6:	eb 81       	ldd	r30, Y+3	; 0x03
    12a8:	fc 81       	ldd	r31, Y+4	; 0x04
    12aa:	92 83       	std	Z+2, r25	; 0x02
    12ac:	81 83       	std	Z+1, r24	; 0x01

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    12ae:	ed 81       	ldd	r30, Y+5	; 0x05
    12b0:	fe 81       	ldd	r31, Y+6	; 0x06
    12b2:	8b 81       	ldd	r24, Y+3	; 0x03
    12b4:	9c 81       	ldd	r25, Y+4	; 0x04
    12b6:	91 87       	std	Z+9, r25	; 0x09
    12b8:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    12ba:	eb 81       	ldd	r30, Y+3	; 0x03
    12bc:	fc 81       	ldd	r31, Y+4	; 0x04
    12be:	80 81       	ld	r24, Z
    12c0:	8f 5f       	subi	r24, 0xFF	; 255
    12c2:	eb 81       	ldd	r30, Y+3	; 0x03
    12c4:	fc 81       	ldd	r31, Y+4	; 0x04
    12c6:	80 83       	st	Z, r24
}
    12c8:	26 96       	adiw	r28, 0x06	; 6
    12ca:	0f b6       	in	r0, 0x3f	; 63
    12cc:	f8 94       	cli
    12ce:	de bf       	out	0x3e, r29	; 62
    12d0:	0f be       	out	0x3f, r0	; 63
    12d2:	cd bf       	out	0x3d, r28	; 61
    12d4:	cf 91       	pop	r28
    12d6:	df 91       	pop	r29
    12d8:	08 95       	ret

000012da <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
    12da:	df 93       	push	r29
    12dc:	cf 93       	push	r28
    12de:	cd b7       	in	r28, 0x3d	; 61
    12e0:	de b7       	in	r29, 0x3e	; 62
    12e2:	28 97       	sbiw	r28, 0x08	; 8
    12e4:	0f b6       	in	r0, 0x3f	; 63
    12e6:	f8 94       	cli
    12e8:	de bf       	out	0x3e, r29	; 62
    12ea:	0f be       	out	0x3f, r0	; 63
    12ec:	cd bf       	out	0x3d, r28	; 61
    12ee:	9e 83       	std	Y+6, r25	; 0x06
    12f0:	8d 83       	std	Y+5, r24	; 0x05
    12f2:	78 87       	std	Y+8, r23	; 0x08
    12f4:	6f 83       	std	Y+7, r22	; 0x07
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
    12f6:	ef 81       	ldd	r30, Y+7	; 0x07
    12f8:	f8 85       	ldd	r31, Y+8	; 0x08
    12fa:	80 81       	ld	r24, Z
    12fc:	91 81       	ldd	r25, Z+1	; 0x01
    12fe:	9a 83       	std	Y+2, r25	; 0x02
    1300:	89 83       	std	Y+1, r24	; 0x01
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    1302:	89 81       	ldd	r24, Y+1	; 0x01
    1304:	9a 81       	ldd	r25, Y+2	; 0x02
    1306:	2f ef       	ldi	r18, 0xFF	; 255
    1308:	8f 3f       	cpi	r24, 0xFF	; 255
    130a:	92 07       	cpc	r25, r18
    130c:	39 f4       	brne	.+14     	; 0x131c <vListInsert+0x42>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    130e:	ed 81       	ldd	r30, Y+5	; 0x05
    1310:	fe 81       	ldd	r31, Y+6	; 0x06
    1312:	87 81       	ldd	r24, Z+7	; 0x07
    1314:	90 85       	ldd	r25, Z+8	; 0x08
    1316:	9c 83       	std	Y+4, r25	; 0x04
    1318:	8b 83       	std	Y+3, r24	; 0x03
    131a:	18 c0       	rjmp	.+48     	; 0x134c <vListInsert+0x72>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
    131c:	8d 81       	ldd	r24, Y+5	; 0x05
    131e:	9e 81       	ldd	r25, Y+6	; 0x06
    1320:	03 96       	adiw	r24, 0x03	; 3
    1322:	9c 83       	std	Y+4, r25	; 0x04
    1324:	8b 83       	std	Y+3, r24	; 0x03
    1326:	06 c0       	rjmp	.+12     	; 0x1334 <vListInsert+0x5a>
    1328:	eb 81       	ldd	r30, Y+3	; 0x03
    132a:	fc 81       	ldd	r31, Y+4	; 0x04
    132c:	82 81       	ldd	r24, Z+2	; 0x02
    132e:	93 81       	ldd	r25, Z+3	; 0x03
    1330:	9c 83       	std	Y+4, r25	; 0x04
    1332:	8b 83       	std	Y+3, r24	; 0x03
    1334:	eb 81       	ldd	r30, Y+3	; 0x03
    1336:	fc 81       	ldd	r31, Y+4	; 0x04
    1338:	02 80       	ldd	r0, Z+2	; 0x02
    133a:	f3 81       	ldd	r31, Z+3	; 0x03
    133c:	e0 2d       	mov	r30, r0
    133e:	20 81       	ld	r18, Z
    1340:	31 81       	ldd	r19, Z+1	; 0x01
    1342:	89 81       	ldd	r24, Y+1	; 0x01
    1344:	9a 81       	ldd	r25, Y+2	; 0x02
    1346:	82 17       	cp	r24, r18
    1348:	93 07       	cpc	r25, r19
    134a:	70 f7       	brcc	.-36     	; 0x1328 <vListInsert+0x4e>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    134c:	eb 81       	ldd	r30, Y+3	; 0x03
    134e:	fc 81       	ldd	r31, Y+4	; 0x04
    1350:	82 81       	ldd	r24, Z+2	; 0x02
    1352:	93 81       	ldd	r25, Z+3	; 0x03
    1354:	ef 81       	ldd	r30, Y+7	; 0x07
    1356:	f8 85       	ldd	r31, Y+8	; 0x08
    1358:	93 83       	std	Z+3, r25	; 0x03
    135a:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    135c:	ef 81       	ldd	r30, Y+7	; 0x07
    135e:	f8 85       	ldd	r31, Y+8	; 0x08
    1360:	02 80       	ldd	r0, Z+2	; 0x02
    1362:	f3 81       	ldd	r31, Z+3	; 0x03
    1364:	e0 2d       	mov	r30, r0
    1366:	8f 81       	ldd	r24, Y+7	; 0x07
    1368:	98 85       	ldd	r25, Y+8	; 0x08
    136a:	95 83       	std	Z+5, r25	; 0x05
    136c:	84 83       	std	Z+4, r24	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    136e:	ef 81       	ldd	r30, Y+7	; 0x07
    1370:	f8 85       	ldd	r31, Y+8	; 0x08
    1372:	8b 81       	ldd	r24, Y+3	; 0x03
    1374:	9c 81       	ldd	r25, Y+4	; 0x04
    1376:	95 83       	std	Z+5, r25	; 0x05
    1378:	84 83       	std	Z+4, r24	; 0x04
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
    137a:	8f 81       	ldd	r24, Y+7	; 0x07
    137c:	98 85       	ldd	r25, Y+8	; 0x08
    137e:	eb 81       	ldd	r30, Y+3	; 0x03
    1380:	fc 81       	ldd	r31, Y+4	; 0x04
    1382:	93 83       	std	Z+3, r25	; 0x03
    1384:	82 83       	std	Z+2, r24	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1386:	ef 81       	ldd	r30, Y+7	; 0x07
    1388:	f8 85       	ldd	r31, Y+8	; 0x08
    138a:	8d 81       	ldd	r24, Y+5	; 0x05
    138c:	9e 81       	ldd	r25, Y+6	; 0x06
    138e:	91 87       	std	Z+9, r25	; 0x09
    1390:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    1392:	ed 81       	ldd	r30, Y+5	; 0x05
    1394:	fe 81       	ldd	r31, Y+6	; 0x06
    1396:	80 81       	ld	r24, Z
    1398:	8f 5f       	subi	r24, 0xFF	; 255
    139a:	ed 81       	ldd	r30, Y+5	; 0x05
    139c:	fe 81       	ldd	r31, Y+6	; 0x06
    139e:	80 83       	st	Z, r24
}
    13a0:	28 96       	adiw	r28, 0x08	; 8
    13a2:	0f b6       	in	r0, 0x3f	; 63
    13a4:	f8 94       	cli
    13a6:	de bf       	out	0x3e, r29	; 62
    13a8:	0f be       	out	0x3f, r0	; 63
    13aa:	cd bf       	out	0x3d, r28	; 61
    13ac:	cf 91       	pop	r28
    13ae:	df 91       	pop	r29
    13b0:	08 95       	ret

000013b2 <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
    13b2:	df 93       	push	r29
    13b4:	cf 93       	push	r28
    13b6:	00 d0       	rcall	.+0      	; 0x13b8 <vListRemove+0x6>
    13b8:	00 d0       	rcall	.+0      	; 0x13ba <vListRemove+0x8>
    13ba:	cd b7       	in	r28, 0x3d	; 61
    13bc:	de b7       	in	r29, 0x3e	; 62
    13be:	9c 83       	std	Y+4, r25	; 0x04
    13c0:	8b 83       	std	Y+3, r24	; 0x03
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    13c2:	eb 81       	ldd	r30, Y+3	; 0x03
    13c4:	fc 81       	ldd	r31, Y+4	; 0x04
    13c6:	a2 81       	ldd	r26, Z+2	; 0x02
    13c8:	b3 81       	ldd	r27, Z+3	; 0x03
    13ca:	eb 81       	ldd	r30, Y+3	; 0x03
    13cc:	fc 81       	ldd	r31, Y+4	; 0x04
    13ce:	84 81       	ldd	r24, Z+4	; 0x04
    13d0:	95 81       	ldd	r25, Z+5	; 0x05
    13d2:	15 96       	adiw	r26, 0x05	; 5
    13d4:	9c 93       	st	X, r25
    13d6:	8e 93       	st	-X, r24
    13d8:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    13da:	eb 81       	ldd	r30, Y+3	; 0x03
    13dc:	fc 81       	ldd	r31, Y+4	; 0x04
    13de:	a4 81       	ldd	r26, Z+4	; 0x04
    13e0:	b5 81       	ldd	r27, Z+5	; 0x05
    13e2:	eb 81       	ldd	r30, Y+3	; 0x03
    13e4:	fc 81       	ldd	r31, Y+4	; 0x04
    13e6:	82 81       	ldd	r24, Z+2	; 0x02
    13e8:	93 81       	ldd	r25, Z+3	; 0x03
    13ea:	13 96       	adiw	r26, 0x03	; 3
    13ec:	9c 93       	st	X, r25
    13ee:	8e 93       	st	-X, r24
    13f0:	12 97       	sbiw	r26, 0x02	; 2
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
    13f2:	eb 81       	ldd	r30, Y+3	; 0x03
    13f4:	fc 81       	ldd	r31, Y+4	; 0x04
    13f6:	80 85       	ldd	r24, Z+8	; 0x08
    13f8:	91 85       	ldd	r25, Z+9	; 0x09
    13fa:	9a 83       	std	Y+2, r25	; 0x02
    13fc:	89 83       	std	Y+1, r24	; 0x01

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    13fe:	e9 81       	ldd	r30, Y+1	; 0x01
    1400:	fa 81       	ldd	r31, Y+2	; 0x02
    1402:	21 81       	ldd	r18, Z+1	; 0x01
    1404:	32 81       	ldd	r19, Z+2	; 0x02
    1406:	8b 81       	ldd	r24, Y+3	; 0x03
    1408:	9c 81       	ldd	r25, Y+4	; 0x04
    140a:	28 17       	cp	r18, r24
    140c:	39 07       	cpc	r19, r25
    140e:	41 f4       	brne	.+16     	; 0x1420 <vListRemove+0x6e>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    1410:	eb 81       	ldd	r30, Y+3	; 0x03
    1412:	fc 81       	ldd	r31, Y+4	; 0x04
    1414:	84 81       	ldd	r24, Z+4	; 0x04
    1416:	95 81       	ldd	r25, Z+5	; 0x05
    1418:	e9 81       	ldd	r30, Y+1	; 0x01
    141a:	fa 81       	ldd	r31, Y+2	; 0x02
    141c:	92 83       	std	Z+2, r25	; 0x02
    141e:	81 83       	std	Z+1, r24	; 0x01
	}

	pxItemToRemove->pvContainer = NULL;
    1420:	eb 81       	ldd	r30, Y+3	; 0x03
    1422:	fc 81       	ldd	r31, Y+4	; 0x04
    1424:	11 86       	std	Z+9, r1	; 0x09
    1426:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    1428:	e9 81       	ldd	r30, Y+1	; 0x01
    142a:	fa 81       	ldd	r31, Y+2	; 0x02
    142c:	80 81       	ld	r24, Z
    142e:	81 50       	subi	r24, 0x01	; 1
    1430:	e9 81       	ldd	r30, Y+1	; 0x01
    1432:	fa 81       	ldd	r31, Y+2	; 0x02
    1434:	80 83       	st	Z, r24
}
    1436:	0f 90       	pop	r0
    1438:	0f 90       	pop	r0
    143a:	0f 90       	pop	r0
    143c:	0f 90       	pop	r0
    143e:	cf 91       	pop	r28
    1440:	df 91       	pop	r29
    1442:	08 95       	ret

00001444 <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
portSTACK_TYPE *pxPortInitialiseStack( portSTACK_TYPE *pxTopOfStack, pdTASK_CODE pxCode, void *pvParameters )
{
    1444:	df 93       	push	r29
    1446:	cf 93       	push	r28
    1448:	cd b7       	in	r28, 0x3d	; 61
    144a:	de b7       	in	r29, 0x3e	; 62
    144c:	28 97       	sbiw	r28, 0x08	; 8
    144e:	0f b6       	in	r0, 0x3f	; 63
    1450:	f8 94       	cli
    1452:	de bf       	out	0x3e, r29	; 62
    1454:	0f be       	out	0x3f, r0	; 63
    1456:	cd bf       	out	0x3d, r28	; 61
    1458:	9c 83       	std	Y+4, r25	; 0x04
    145a:	8b 83       	std	Y+3, r24	; 0x03
    145c:	7e 83       	std	Y+6, r23	; 0x06
    145e:	6d 83       	std	Y+5, r22	; 0x05
    1460:	58 87       	std	Y+8, r21	; 0x08
    1462:	4f 83       	std	Y+7, r20	; 0x07
unsigned short usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    1464:	eb 81       	ldd	r30, Y+3	; 0x03
    1466:	fc 81       	ldd	r31, Y+4	; 0x04
    1468:	81 e1       	ldi	r24, 0x11	; 17
    146a:	80 83       	st	Z, r24
	pxTopOfStack--;
    146c:	8b 81       	ldd	r24, Y+3	; 0x03
    146e:	9c 81       	ldd	r25, Y+4	; 0x04
    1470:	01 97       	sbiw	r24, 0x01	; 1
    1472:	9c 83       	std	Y+4, r25	; 0x04
    1474:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x22;
    1476:	eb 81       	ldd	r30, Y+3	; 0x03
    1478:	fc 81       	ldd	r31, Y+4	; 0x04
    147a:	82 e2       	ldi	r24, 0x22	; 34
    147c:	80 83       	st	Z, r24
	pxTopOfStack--;
    147e:	8b 81       	ldd	r24, Y+3	; 0x03
    1480:	9c 81       	ldd	r25, Y+4	; 0x04
    1482:	01 97       	sbiw	r24, 0x01	; 1
    1484:	9c 83       	std	Y+4, r25	; 0x04
    1486:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x33;
    1488:	eb 81       	ldd	r30, Y+3	; 0x03
    148a:	fc 81       	ldd	r31, Y+4	; 0x04
    148c:	83 e3       	ldi	r24, 0x33	; 51
    148e:	80 83       	st	Z, r24
	pxTopOfStack--;
    1490:	8b 81       	ldd	r24, Y+3	; 0x03
    1492:	9c 81       	ldd	r25, Y+4	; 0x04
    1494:	01 97       	sbiw	r24, 0x01	; 1
    1496:	9c 83       	std	Y+4, r25	; 0x04
    1498:	8b 83       	std	Y+3, r24	; 0x03

	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( unsigned short ) pxCode;
    149a:	8d 81       	ldd	r24, Y+5	; 0x05
    149c:	9e 81       	ldd	r25, Y+6	; 0x06
    149e:	9a 83       	std	Y+2, r25	; 0x02
    14a0:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    14a2:	89 81       	ldd	r24, Y+1	; 0x01
    14a4:	eb 81       	ldd	r30, Y+3	; 0x03
    14a6:	fc 81       	ldd	r31, Y+4	; 0x04
    14a8:	80 83       	st	Z, r24
	pxTopOfStack--;
    14aa:	8b 81       	ldd	r24, Y+3	; 0x03
    14ac:	9c 81       	ldd	r25, Y+4	; 0x04
    14ae:	01 97       	sbiw	r24, 0x01	; 1
    14b0:	9c 83       	std	Y+4, r25	; 0x04
    14b2:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    14b4:	89 81       	ldd	r24, Y+1	; 0x01
    14b6:	9a 81       	ldd	r25, Y+2	; 0x02
    14b8:	89 2f       	mov	r24, r25
    14ba:	99 27       	eor	r25, r25
    14bc:	9a 83       	std	Y+2, r25	; 0x02
    14be:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    14c0:	89 81       	ldd	r24, Y+1	; 0x01
    14c2:	eb 81       	ldd	r30, Y+3	; 0x03
    14c4:	fc 81       	ldd	r31, Y+4	; 0x04
    14c6:	80 83       	st	Z, r24
	pxTopOfStack--;
    14c8:	8b 81       	ldd	r24, Y+3	; 0x03
    14ca:	9c 81       	ldd	r25, Y+4	; 0x04
    14cc:	01 97       	sbiw	r24, 0x01	; 1
    14ce:	9c 83       	std	Y+4, r25	; 0x04
    14d0:	8b 83       	std	Y+3, r24	; 0x03

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R0 */
    14d2:	eb 81       	ldd	r30, Y+3	; 0x03
    14d4:	fc 81       	ldd	r31, Y+4	; 0x04
    14d6:	10 82       	st	Z, r1
	pxTopOfStack--;
    14d8:	8b 81       	ldd	r24, Y+3	; 0x03
    14da:	9c 81       	ldd	r25, Y+4	; 0x04
    14dc:	01 97       	sbiw	r24, 0x01	; 1
    14de:	9c 83       	std	Y+4, r25	; 0x04
    14e0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    14e2:	eb 81       	ldd	r30, Y+3	; 0x03
    14e4:	fc 81       	ldd	r31, Y+4	; 0x04
    14e6:	80 e8       	ldi	r24, 0x80	; 128
    14e8:	80 83       	st	Z, r24
	pxTopOfStack--;
    14ea:	8b 81       	ldd	r24, Y+3	; 0x03
    14ec:	9c 81       	ldd	r25, Y+4	; 0x04
    14ee:	01 97       	sbiw	r24, 0x01	; 1
    14f0:	9c 83       	std	Y+4, r25	; 0x04
    14f2:	8b 83       	std	Y+3, r24	; 0x03


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R1 */
    14f4:	eb 81       	ldd	r30, Y+3	; 0x03
    14f6:	fc 81       	ldd	r31, Y+4	; 0x04
    14f8:	10 82       	st	Z, r1
	pxTopOfStack--;
    14fa:	8b 81       	ldd	r24, Y+3	; 0x03
    14fc:	9c 81       	ldd	r25, Y+4	; 0x04
    14fe:	01 97       	sbiw	r24, 0x01	; 1
    1500:	9c 83       	std	Y+4, r25	; 0x04
    1502:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x02;	/* R2 */
    1504:	eb 81       	ldd	r30, Y+3	; 0x03
    1506:	fc 81       	ldd	r31, Y+4	; 0x04
    1508:	82 e0       	ldi	r24, 0x02	; 2
    150a:	80 83       	st	Z, r24
	pxTopOfStack--;
    150c:	8b 81       	ldd	r24, Y+3	; 0x03
    150e:	9c 81       	ldd	r25, Y+4	; 0x04
    1510:	01 97       	sbiw	r24, 0x01	; 1
    1512:	9c 83       	std	Y+4, r25	; 0x04
    1514:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x03;	/* R3 */
    1516:	eb 81       	ldd	r30, Y+3	; 0x03
    1518:	fc 81       	ldd	r31, Y+4	; 0x04
    151a:	83 e0       	ldi	r24, 0x03	; 3
    151c:	80 83       	st	Z, r24
	pxTopOfStack--;
    151e:	8b 81       	ldd	r24, Y+3	; 0x03
    1520:	9c 81       	ldd	r25, Y+4	; 0x04
    1522:	01 97       	sbiw	r24, 0x01	; 1
    1524:	9c 83       	std	Y+4, r25	; 0x04
    1526:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x04;	/* R4 */
    1528:	eb 81       	ldd	r30, Y+3	; 0x03
    152a:	fc 81       	ldd	r31, Y+4	; 0x04
    152c:	84 e0       	ldi	r24, 0x04	; 4
    152e:	80 83       	st	Z, r24
	pxTopOfStack--;
    1530:	8b 81       	ldd	r24, Y+3	; 0x03
    1532:	9c 81       	ldd	r25, Y+4	; 0x04
    1534:	01 97       	sbiw	r24, 0x01	; 1
    1536:	9c 83       	std	Y+4, r25	; 0x04
    1538:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x05;	/* R5 */
    153a:	eb 81       	ldd	r30, Y+3	; 0x03
    153c:	fc 81       	ldd	r31, Y+4	; 0x04
    153e:	85 e0       	ldi	r24, 0x05	; 5
    1540:	80 83       	st	Z, r24
	pxTopOfStack--;
    1542:	8b 81       	ldd	r24, Y+3	; 0x03
    1544:	9c 81       	ldd	r25, Y+4	; 0x04
    1546:	01 97       	sbiw	r24, 0x01	; 1
    1548:	9c 83       	std	Y+4, r25	; 0x04
    154a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x06;	/* R6 */
    154c:	eb 81       	ldd	r30, Y+3	; 0x03
    154e:	fc 81       	ldd	r31, Y+4	; 0x04
    1550:	86 e0       	ldi	r24, 0x06	; 6
    1552:	80 83       	st	Z, r24
	pxTopOfStack--;
    1554:	8b 81       	ldd	r24, Y+3	; 0x03
    1556:	9c 81       	ldd	r25, Y+4	; 0x04
    1558:	01 97       	sbiw	r24, 0x01	; 1
    155a:	9c 83       	std	Y+4, r25	; 0x04
    155c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x07;	/* R7 */
    155e:	eb 81       	ldd	r30, Y+3	; 0x03
    1560:	fc 81       	ldd	r31, Y+4	; 0x04
    1562:	87 e0       	ldi	r24, 0x07	; 7
    1564:	80 83       	st	Z, r24
	pxTopOfStack--;
    1566:	8b 81       	ldd	r24, Y+3	; 0x03
    1568:	9c 81       	ldd	r25, Y+4	; 0x04
    156a:	01 97       	sbiw	r24, 0x01	; 1
    156c:	9c 83       	std	Y+4, r25	; 0x04
    156e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x08;	/* R8 */
    1570:	eb 81       	ldd	r30, Y+3	; 0x03
    1572:	fc 81       	ldd	r31, Y+4	; 0x04
    1574:	88 e0       	ldi	r24, 0x08	; 8
    1576:	80 83       	st	Z, r24
	pxTopOfStack--;
    1578:	8b 81       	ldd	r24, Y+3	; 0x03
    157a:	9c 81       	ldd	r25, Y+4	; 0x04
    157c:	01 97       	sbiw	r24, 0x01	; 1
    157e:	9c 83       	std	Y+4, r25	; 0x04
    1580:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x09;	/* R9 */
    1582:	eb 81       	ldd	r30, Y+3	; 0x03
    1584:	fc 81       	ldd	r31, Y+4	; 0x04
    1586:	89 e0       	ldi	r24, 0x09	; 9
    1588:	80 83       	st	Z, r24
	pxTopOfStack--;
    158a:	8b 81       	ldd	r24, Y+3	; 0x03
    158c:	9c 81       	ldd	r25, Y+4	; 0x04
    158e:	01 97       	sbiw	r24, 0x01	; 1
    1590:	9c 83       	std	Y+4, r25	; 0x04
    1592:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x10;	/* R10 */
    1594:	eb 81       	ldd	r30, Y+3	; 0x03
    1596:	fc 81       	ldd	r31, Y+4	; 0x04
    1598:	80 e1       	ldi	r24, 0x10	; 16
    159a:	80 83       	st	Z, r24
	pxTopOfStack--;
    159c:	8b 81       	ldd	r24, Y+3	; 0x03
    159e:	9c 81       	ldd	r25, Y+4	; 0x04
    15a0:	01 97       	sbiw	r24, 0x01	; 1
    15a2:	9c 83       	std	Y+4, r25	; 0x04
    15a4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x11;	/* R11 */
    15a6:	eb 81       	ldd	r30, Y+3	; 0x03
    15a8:	fc 81       	ldd	r31, Y+4	; 0x04
    15aa:	81 e1       	ldi	r24, 0x11	; 17
    15ac:	80 83       	st	Z, r24
	pxTopOfStack--;
    15ae:	8b 81       	ldd	r24, Y+3	; 0x03
    15b0:	9c 81       	ldd	r25, Y+4	; 0x04
    15b2:	01 97       	sbiw	r24, 0x01	; 1
    15b4:	9c 83       	std	Y+4, r25	; 0x04
    15b6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x12;	/* R12 */
    15b8:	eb 81       	ldd	r30, Y+3	; 0x03
    15ba:	fc 81       	ldd	r31, Y+4	; 0x04
    15bc:	82 e1       	ldi	r24, 0x12	; 18
    15be:	80 83       	st	Z, r24
	pxTopOfStack--;
    15c0:	8b 81       	ldd	r24, Y+3	; 0x03
    15c2:	9c 81       	ldd	r25, Y+4	; 0x04
    15c4:	01 97       	sbiw	r24, 0x01	; 1
    15c6:	9c 83       	std	Y+4, r25	; 0x04
    15c8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x13;	/* R13 */
    15ca:	eb 81       	ldd	r30, Y+3	; 0x03
    15cc:	fc 81       	ldd	r31, Y+4	; 0x04
    15ce:	83 e1       	ldi	r24, 0x13	; 19
    15d0:	80 83       	st	Z, r24
	pxTopOfStack--;
    15d2:	8b 81       	ldd	r24, Y+3	; 0x03
    15d4:	9c 81       	ldd	r25, Y+4	; 0x04
    15d6:	01 97       	sbiw	r24, 0x01	; 1
    15d8:	9c 83       	std	Y+4, r25	; 0x04
    15da:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x14;	/* R14 */
    15dc:	eb 81       	ldd	r30, Y+3	; 0x03
    15de:	fc 81       	ldd	r31, Y+4	; 0x04
    15e0:	84 e1       	ldi	r24, 0x14	; 20
    15e2:	80 83       	st	Z, r24
	pxTopOfStack--;
    15e4:	8b 81       	ldd	r24, Y+3	; 0x03
    15e6:	9c 81       	ldd	r25, Y+4	; 0x04
    15e8:	01 97       	sbiw	r24, 0x01	; 1
    15ea:	9c 83       	std	Y+4, r25	; 0x04
    15ec:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x15;	/* R15 */
    15ee:	eb 81       	ldd	r30, Y+3	; 0x03
    15f0:	fc 81       	ldd	r31, Y+4	; 0x04
    15f2:	85 e1       	ldi	r24, 0x15	; 21
    15f4:	80 83       	st	Z, r24
	pxTopOfStack--;
    15f6:	8b 81       	ldd	r24, Y+3	; 0x03
    15f8:	9c 81       	ldd	r25, Y+4	; 0x04
    15fa:	01 97       	sbiw	r24, 0x01	; 1
    15fc:	9c 83       	std	Y+4, r25	; 0x04
    15fe:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x16;	/* R16 */
    1600:	eb 81       	ldd	r30, Y+3	; 0x03
    1602:	fc 81       	ldd	r31, Y+4	; 0x04
    1604:	86 e1       	ldi	r24, 0x16	; 22
    1606:	80 83       	st	Z, r24
	pxTopOfStack--;
    1608:	8b 81       	ldd	r24, Y+3	; 0x03
    160a:	9c 81       	ldd	r25, Y+4	; 0x04
    160c:	01 97       	sbiw	r24, 0x01	; 1
    160e:	9c 83       	std	Y+4, r25	; 0x04
    1610:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x17;	/* R17 */
    1612:	eb 81       	ldd	r30, Y+3	; 0x03
    1614:	fc 81       	ldd	r31, Y+4	; 0x04
    1616:	87 e1       	ldi	r24, 0x17	; 23
    1618:	80 83       	st	Z, r24
	pxTopOfStack--;
    161a:	8b 81       	ldd	r24, Y+3	; 0x03
    161c:	9c 81       	ldd	r25, Y+4	; 0x04
    161e:	01 97       	sbiw	r24, 0x01	; 1
    1620:	9c 83       	std	Y+4, r25	; 0x04
    1622:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x18;	/* R18 */
    1624:	eb 81       	ldd	r30, Y+3	; 0x03
    1626:	fc 81       	ldd	r31, Y+4	; 0x04
    1628:	88 e1       	ldi	r24, 0x18	; 24
    162a:	80 83       	st	Z, r24
	pxTopOfStack--;
    162c:	8b 81       	ldd	r24, Y+3	; 0x03
    162e:	9c 81       	ldd	r25, Y+4	; 0x04
    1630:	01 97       	sbiw	r24, 0x01	; 1
    1632:	9c 83       	std	Y+4, r25	; 0x04
    1634:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x19;	/* R19 */
    1636:	eb 81       	ldd	r30, Y+3	; 0x03
    1638:	fc 81       	ldd	r31, Y+4	; 0x04
    163a:	89 e1       	ldi	r24, 0x19	; 25
    163c:	80 83       	st	Z, r24
	pxTopOfStack--;
    163e:	8b 81       	ldd	r24, Y+3	; 0x03
    1640:	9c 81       	ldd	r25, Y+4	; 0x04
    1642:	01 97       	sbiw	r24, 0x01	; 1
    1644:	9c 83       	std	Y+4, r25	; 0x04
    1646:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x20;	/* R20 */
    1648:	eb 81       	ldd	r30, Y+3	; 0x03
    164a:	fc 81       	ldd	r31, Y+4	; 0x04
    164c:	80 e2       	ldi	r24, 0x20	; 32
    164e:	80 83       	st	Z, r24
	pxTopOfStack--;
    1650:	8b 81       	ldd	r24, Y+3	; 0x03
    1652:	9c 81       	ldd	r25, Y+4	; 0x04
    1654:	01 97       	sbiw	r24, 0x01	; 1
    1656:	9c 83       	std	Y+4, r25	; 0x04
    1658:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x21;	/* R21 */
    165a:	eb 81       	ldd	r30, Y+3	; 0x03
    165c:	fc 81       	ldd	r31, Y+4	; 0x04
    165e:	81 e2       	ldi	r24, 0x21	; 33
    1660:	80 83       	st	Z, r24
	pxTopOfStack--;
    1662:	8b 81       	ldd	r24, Y+3	; 0x03
    1664:	9c 81       	ldd	r25, Y+4	; 0x04
    1666:	01 97       	sbiw	r24, 0x01	; 1
    1668:	9c 83       	std	Y+4, r25	; 0x04
    166a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x22;	/* R22 */
    166c:	eb 81       	ldd	r30, Y+3	; 0x03
    166e:	fc 81       	ldd	r31, Y+4	; 0x04
    1670:	82 e2       	ldi	r24, 0x22	; 34
    1672:	80 83       	st	Z, r24
	pxTopOfStack--;
    1674:	8b 81       	ldd	r24, Y+3	; 0x03
    1676:	9c 81       	ldd	r25, Y+4	; 0x04
    1678:	01 97       	sbiw	r24, 0x01	; 1
    167a:	9c 83       	std	Y+4, r25	; 0x04
    167c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x23;	/* R23 */
    167e:	eb 81       	ldd	r30, Y+3	; 0x03
    1680:	fc 81       	ldd	r31, Y+4	; 0x04
    1682:	83 e2       	ldi	r24, 0x23	; 35
    1684:	80 83       	st	Z, r24
	pxTopOfStack--;
    1686:	8b 81       	ldd	r24, Y+3	; 0x03
    1688:	9c 81       	ldd	r25, Y+4	; 0x04
    168a:	01 97       	sbiw	r24, 0x01	; 1
    168c:	9c 83       	std	Y+4, r25	; 0x04
    168e:	8b 83       	std	Y+3, r24	; 0x03

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( unsigned short ) pvParameters;
    1690:	8f 81       	ldd	r24, Y+7	; 0x07
    1692:	98 85       	ldd	r25, Y+8	; 0x08
    1694:	9a 83       	std	Y+2, r25	; 0x02
    1696:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    1698:	89 81       	ldd	r24, Y+1	; 0x01
    169a:	eb 81       	ldd	r30, Y+3	; 0x03
    169c:	fc 81       	ldd	r31, Y+4	; 0x04
    169e:	80 83       	st	Z, r24
	pxTopOfStack--;
    16a0:	8b 81       	ldd	r24, Y+3	; 0x03
    16a2:	9c 81       	ldd	r25, Y+4	; 0x04
    16a4:	01 97       	sbiw	r24, 0x01	; 1
    16a6:	9c 83       	std	Y+4, r25	; 0x04
    16a8:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    16aa:	89 81       	ldd	r24, Y+1	; 0x01
    16ac:	9a 81       	ldd	r25, Y+2	; 0x02
    16ae:	89 2f       	mov	r24, r25
    16b0:	99 27       	eor	r25, r25
    16b2:	9a 83       	std	Y+2, r25	; 0x02
    16b4:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    16b6:	89 81       	ldd	r24, Y+1	; 0x01
    16b8:	eb 81       	ldd	r30, Y+3	; 0x03
    16ba:	fc 81       	ldd	r31, Y+4	; 0x04
    16bc:	80 83       	st	Z, r24
	pxTopOfStack--;
    16be:	8b 81       	ldd	r24, Y+3	; 0x03
    16c0:	9c 81       	ldd	r25, Y+4	; 0x04
    16c2:	01 97       	sbiw	r24, 0x01	; 1
    16c4:	9c 83       	std	Y+4, r25	; 0x04
    16c6:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = ( portSTACK_TYPE ) 0x26;	/* R26 X */
    16c8:	eb 81       	ldd	r30, Y+3	; 0x03
    16ca:	fc 81       	ldd	r31, Y+4	; 0x04
    16cc:	86 e2       	ldi	r24, 0x26	; 38
    16ce:	80 83       	st	Z, r24
	pxTopOfStack--;
    16d0:	8b 81       	ldd	r24, Y+3	; 0x03
    16d2:	9c 81       	ldd	r25, Y+4	; 0x04
    16d4:	01 97       	sbiw	r24, 0x01	; 1
    16d6:	9c 83       	std	Y+4, r25	; 0x04
    16d8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x27;	/* R27 */
    16da:	eb 81       	ldd	r30, Y+3	; 0x03
    16dc:	fc 81       	ldd	r31, Y+4	; 0x04
    16de:	87 e2       	ldi	r24, 0x27	; 39
    16e0:	80 83       	st	Z, r24
	pxTopOfStack--;
    16e2:	8b 81       	ldd	r24, Y+3	; 0x03
    16e4:	9c 81       	ldd	r25, Y+4	; 0x04
    16e6:	01 97       	sbiw	r24, 0x01	; 1
    16e8:	9c 83       	std	Y+4, r25	; 0x04
    16ea:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x28;	/* R28 Y */
    16ec:	eb 81       	ldd	r30, Y+3	; 0x03
    16ee:	fc 81       	ldd	r31, Y+4	; 0x04
    16f0:	88 e2       	ldi	r24, 0x28	; 40
    16f2:	80 83       	st	Z, r24
	pxTopOfStack--;
    16f4:	8b 81       	ldd	r24, Y+3	; 0x03
    16f6:	9c 81       	ldd	r25, Y+4	; 0x04
    16f8:	01 97       	sbiw	r24, 0x01	; 1
    16fa:	9c 83       	std	Y+4, r25	; 0x04
    16fc:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x29;	/* R29 */
    16fe:	eb 81       	ldd	r30, Y+3	; 0x03
    1700:	fc 81       	ldd	r31, Y+4	; 0x04
    1702:	89 e2       	ldi	r24, 0x29	; 41
    1704:	80 83       	st	Z, r24
	pxTopOfStack--;
    1706:	8b 81       	ldd	r24, Y+3	; 0x03
    1708:	9c 81       	ldd	r25, Y+4	; 0x04
    170a:	01 97       	sbiw	r24, 0x01	; 1
    170c:	9c 83       	std	Y+4, r25	; 0x04
    170e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x30;	/* R30 Z */
    1710:	eb 81       	ldd	r30, Y+3	; 0x03
    1712:	fc 81       	ldd	r31, Y+4	; 0x04
    1714:	80 e3       	ldi	r24, 0x30	; 48
    1716:	80 83       	st	Z, r24
	pxTopOfStack--;
    1718:	8b 81       	ldd	r24, Y+3	; 0x03
    171a:	9c 81       	ldd	r25, Y+4	; 0x04
    171c:	01 97       	sbiw	r24, 0x01	; 1
    171e:	9c 83       	std	Y+4, r25	; 0x04
    1720:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x031;	/* R31 */
    1722:	eb 81       	ldd	r30, Y+3	; 0x03
    1724:	fc 81       	ldd	r31, Y+4	; 0x04
    1726:	81 e3       	ldi	r24, 0x31	; 49
    1728:	80 83       	st	Z, r24
	pxTopOfStack--;
    172a:	8b 81       	ldd	r24, Y+3	; 0x03
    172c:	9c 81       	ldd	r25, Y+4	; 0x04
    172e:	01 97       	sbiw	r24, 0x01	; 1
    1730:	9c 83       	std	Y+4, r25	; 0x04
    1732:	8b 83       	std	Y+3, r24	; 0x03

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
    1734:	8b 81       	ldd	r24, Y+3	; 0x03
    1736:	9c 81       	ldd	r25, Y+4	; 0x04
}
    1738:	28 96       	adiw	r28, 0x08	; 8
    173a:	0f b6       	in	r0, 0x3f	; 63
    173c:	f8 94       	cli
    173e:	de bf       	out	0x3e, r29	; 62
    1740:	0f be       	out	0x3f, r0	; 63
    1742:	cd bf       	out	0x3d, r28	; 61
    1744:	cf 91       	pop	r28
    1746:	df 91       	pop	r29
    1748:	08 95       	ret

0000174a <xPortStartScheduler>:
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
    174a:	df 93       	push	r29
    174c:	cf 93       	push	r28
    174e:	cd b7       	in	r28, 0x3d	; 61
    1750:	de b7       	in	r29, 0x3e	; 62
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();
    1752:	0e 94 95 0c 	call	0x192a	; 0x192a <prvSetupTimerInterrupt>

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    1756:	a0 91 58 05 	lds	r26, 0x0558
    175a:	b0 91 59 05 	lds	r27, 0x0559
    175e:	cd 91       	ld	r28, X+
    1760:	cd bf       	out	0x3d, r28	; 61
    1762:	dd 91       	ld	r29, X+
    1764:	de bf       	out	0x3e, r29	; 62
    1766:	ff 91       	pop	r31
    1768:	ef 91       	pop	r30
    176a:	df 91       	pop	r29
    176c:	cf 91       	pop	r28
    176e:	bf 91       	pop	r27
    1770:	af 91       	pop	r26
    1772:	9f 91       	pop	r25
    1774:	8f 91       	pop	r24
    1776:	7f 91       	pop	r23
    1778:	6f 91       	pop	r22
    177a:	5f 91       	pop	r21
    177c:	4f 91       	pop	r20
    177e:	3f 91       	pop	r19
    1780:	2f 91       	pop	r18
    1782:	1f 91       	pop	r17
    1784:	0f 91       	pop	r16
    1786:	ff 90       	pop	r15
    1788:	ef 90       	pop	r14
    178a:	df 90       	pop	r13
    178c:	cf 90       	pop	r12
    178e:	bf 90       	pop	r11
    1790:	af 90       	pop	r10
    1792:	9f 90       	pop	r9
    1794:	8f 90       	pop	r8
    1796:	7f 90       	pop	r7
    1798:	6f 90       	pop	r6
    179a:	5f 90       	pop	r5
    179c:	4f 90       	pop	r4
    179e:	3f 90       	pop	r3
    17a0:	2f 90       	pop	r2
    17a2:	1f 90       	pop	r1
    17a4:	0f 90       	pop	r0
    17a6:	0f be       	out	0x3f, r0	; 63
    17a8:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    17aa:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
    17ac:	81 e0       	ldi	r24, 0x01	; 1
}
    17ae:	cf 91       	pop	r28
    17b0:	df 91       	pop	r29
    17b2:	08 95       	ret

000017b4 <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    17b4:	df 93       	push	r29
    17b6:	cf 93       	push	r28
    17b8:	cd b7       	in	r28, 0x3d	; 61
    17ba:	de b7       	in	r29, 0x3e	; 62
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    17bc:	cf 91       	pop	r28
    17be:	df 91       	pop	r29
    17c0:	08 95       	ret

000017c2 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    17c2:	0f 92       	push	r0
    17c4:	0f b6       	in	r0, 0x3f	; 63
    17c6:	f8 94       	cli
    17c8:	0f 92       	push	r0
    17ca:	1f 92       	push	r1
    17cc:	11 24       	eor	r1, r1
    17ce:	2f 92       	push	r2
    17d0:	3f 92       	push	r3
    17d2:	4f 92       	push	r4
    17d4:	5f 92       	push	r5
    17d6:	6f 92       	push	r6
    17d8:	7f 92       	push	r7
    17da:	8f 92       	push	r8
    17dc:	9f 92       	push	r9
    17de:	af 92       	push	r10
    17e0:	bf 92       	push	r11
    17e2:	cf 92       	push	r12
    17e4:	df 92       	push	r13
    17e6:	ef 92       	push	r14
    17e8:	ff 92       	push	r15
    17ea:	0f 93       	push	r16
    17ec:	1f 93       	push	r17
    17ee:	2f 93       	push	r18
    17f0:	3f 93       	push	r19
    17f2:	4f 93       	push	r20
    17f4:	5f 93       	push	r21
    17f6:	6f 93       	push	r22
    17f8:	7f 93       	push	r23
    17fa:	8f 93       	push	r24
    17fc:	9f 93       	push	r25
    17fe:	af 93       	push	r26
    1800:	bf 93       	push	r27
    1802:	cf 93       	push	r28
    1804:	df 93       	push	r29
    1806:	ef 93       	push	r30
    1808:	ff 93       	push	r31
    180a:	a0 91 58 05 	lds	r26, 0x0558
    180e:	b0 91 59 05 	lds	r27, 0x0559
    1812:	0d b6       	in	r0, 0x3d	; 61
    1814:	0d 92       	st	X+, r0
    1816:	0e b6       	in	r0, 0x3e	; 62
    1818:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    181a:	0e 94 e9 15 	call	0x2bd2	; 0x2bd2 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    181e:	a0 91 58 05 	lds	r26, 0x0558
    1822:	b0 91 59 05 	lds	r27, 0x0559
    1826:	cd 91       	ld	r28, X+
    1828:	cd bf       	out	0x3d, r28	; 61
    182a:	dd 91       	ld	r29, X+
    182c:	de bf       	out	0x3e, r29	; 62
    182e:	ff 91       	pop	r31
    1830:	ef 91       	pop	r30
    1832:	df 91       	pop	r29
    1834:	cf 91       	pop	r28
    1836:	bf 91       	pop	r27
    1838:	af 91       	pop	r26
    183a:	9f 91       	pop	r25
    183c:	8f 91       	pop	r24
    183e:	7f 91       	pop	r23
    1840:	6f 91       	pop	r22
    1842:	5f 91       	pop	r21
    1844:	4f 91       	pop	r20
    1846:	3f 91       	pop	r19
    1848:	2f 91       	pop	r18
    184a:	1f 91       	pop	r17
    184c:	0f 91       	pop	r16
    184e:	ff 90       	pop	r15
    1850:	ef 90       	pop	r14
    1852:	df 90       	pop	r13
    1854:	cf 90       	pop	r12
    1856:	bf 90       	pop	r11
    1858:	af 90       	pop	r10
    185a:	9f 90       	pop	r9
    185c:	8f 90       	pop	r8
    185e:	7f 90       	pop	r7
    1860:	6f 90       	pop	r6
    1862:	5f 90       	pop	r5
    1864:	4f 90       	pop	r4
    1866:	3f 90       	pop	r3
    1868:	2f 90       	pop	r2
    186a:	1f 90       	pop	r1
    186c:	0f 90       	pop	r0
    186e:	0f be       	out	0x3f, r0	; 63
    1870:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1872:	08 95       	ret

00001874 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    1874:	0f 92       	push	r0
    1876:	0f b6       	in	r0, 0x3f	; 63
    1878:	f8 94       	cli
    187a:	0f 92       	push	r0
    187c:	1f 92       	push	r1
    187e:	11 24       	eor	r1, r1
    1880:	2f 92       	push	r2
    1882:	3f 92       	push	r3
    1884:	4f 92       	push	r4
    1886:	5f 92       	push	r5
    1888:	6f 92       	push	r6
    188a:	7f 92       	push	r7
    188c:	8f 92       	push	r8
    188e:	9f 92       	push	r9
    1890:	af 92       	push	r10
    1892:	bf 92       	push	r11
    1894:	cf 92       	push	r12
    1896:	df 92       	push	r13
    1898:	ef 92       	push	r14
    189a:	ff 92       	push	r15
    189c:	0f 93       	push	r16
    189e:	1f 93       	push	r17
    18a0:	2f 93       	push	r18
    18a2:	3f 93       	push	r19
    18a4:	4f 93       	push	r20
    18a6:	5f 93       	push	r21
    18a8:	6f 93       	push	r22
    18aa:	7f 93       	push	r23
    18ac:	8f 93       	push	r24
    18ae:	9f 93       	push	r25
    18b0:	af 93       	push	r26
    18b2:	bf 93       	push	r27
    18b4:	cf 93       	push	r28
    18b6:	df 93       	push	r29
    18b8:	ef 93       	push	r30
    18ba:	ff 93       	push	r31
    18bc:	a0 91 58 05 	lds	r26, 0x0558
    18c0:	b0 91 59 05 	lds	r27, 0x0559
    18c4:	0d b6       	in	r0, 0x3d	; 61
    18c6:	0d 92       	st	X+, r0
    18c8:	0e b6       	in	r0, 0x3e	; 62
    18ca:	0d 92       	st	X+, r0
	vTaskIncrementTick();
    18cc:	0e 94 14 15 	call	0x2a28	; 0x2a28 <vTaskIncrementTick>
	vTaskSwitchContext();
    18d0:	0e 94 e9 15 	call	0x2bd2	; 0x2bd2 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    18d4:	a0 91 58 05 	lds	r26, 0x0558
    18d8:	b0 91 59 05 	lds	r27, 0x0559
    18dc:	cd 91       	ld	r28, X+
    18de:	cd bf       	out	0x3d, r28	; 61
    18e0:	dd 91       	ld	r29, X+
    18e2:	de bf       	out	0x3e, r29	; 62
    18e4:	ff 91       	pop	r31
    18e6:	ef 91       	pop	r30
    18e8:	df 91       	pop	r29
    18ea:	cf 91       	pop	r28
    18ec:	bf 91       	pop	r27
    18ee:	af 91       	pop	r26
    18f0:	9f 91       	pop	r25
    18f2:	8f 91       	pop	r24
    18f4:	7f 91       	pop	r23
    18f6:	6f 91       	pop	r22
    18f8:	5f 91       	pop	r21
    18fa:	4f 91       	pop	r20
    18fc:	3f 91       	pop	r19
    18fe:	2f 91       	pop	r18
    1900:	1f 91       	pop	r17
    1902:	0f 91       	pop	r16
    1904:	ff 90       	pop	r15
    1906:	ef 90       	pop	r14
    1908:	df 90       	pop	r13
    190a:	cf 90       	pop	r12
    190c:	bf 90       	pop	r11
    190e:	af 90       	pop	r10
    1910:	9f 90       	pop	r9
    1912:	8f 90       	pop	r8
    1914:	7f 90       	pop	r7
    1916:	6f 90       	pop	r6
    1918:	5f 90       	pop	r5
    191a:	4f 90       	pop	r4
    191c:	3f 90       	pop	r3
    191e:	2f 90       	pop	r2
    1920:	1f 90       	pop	r1
    1922:	0f 90       	pop	r0
    1924:	0f be       	out	0x3f, r0	; 63
    1926:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1928:	08 95       	ret

0000192a <prvSetupTimerInterrupt>:

/*
 * Setup timer 1 compare match A to generate a tick interrupt.
 */
static void prvSetupTimerInterrupt( void )
{
    192a:	df 93       	push	r29
    192c:	cf 93       	push	r28
    192e:	00 d0       	rcall	.+0      	; 0x1930 <prvSetupTimerInterrupt+0x6>
    1930:	00 d0       	rcall	.+0      	; 0x1932 <prvSetupTimerInterrupt+0x8>
    1932:	00 d0       	rcall	.+0      	; 0x1934 <prvSetupTimerInterrupt+0xa>
    1934:	cd b7       	in	r28, 0x3d	; 61
    1936:	de b7       	in	r29, 0x3e	; 62
unsigned char ucHighByte, ucLowByte;

	/* Using 16bit timer 1 to generate the tick.  Correct fuses must be
	selected for the configCPU_CLOCK_HZ clock. */

	ulCompareMatch = configCPU_CLOCK_HZ / configTICK_RATE_HZ;
    1938:	80 e4       	ldi	r24, 0x40	; 64
    193a:	9f e1       	ldi	r25, 0x1F	; 31
    193c:	a0 e0       	ldi	r26, 0x00	; 0
    193e:	b0 e0       	ldi	r27, 0x00	; 0
    1940:	8b 83       	std	Y+3, r24	; 0x03
    1942:	9c 83       	std	Y+4, r25	; 0x04
    1944:	ad 83       	std	Y+5, r26	; 0x05
    1946:	be 83       	std	Y+6, r27	; 0x06

	/* We only have 16 bits so have to scale to get our required tick rate. */
	ulCompareMatch /= portCLOCK_PRESCALER;
    1948:	8b 81       	ldd	r24, Y+3	; 0x03
    194a:	9c 81       	ldd	r25, Y+4	; 0x04
    194c:	ad 81       	ldd	r26, Y+5	; 0x05
    194e:	be 81       	ldd	r27, Y+6	; 0x06
    1950:	68 94       	set
    1952:	15 f8       	bld	r1, 5
    1954:	b6 95       	lsr	r27
    1956:	a7 95       	ror	r26
    1958:	97 95       	ror	r25
    195a:	87 95       	ror	r24
    195c:	16 94       	lsr	r1
    195e:	d1 f7       	brne	.-12     	; 0x1954 <prvSetupTimerInterrupt+0x2a>
    1960:	8b 83       	std	Y+3, r24	; 0x03
    1962:	9c 83       	std	Y+4, r25	; 0x04
    1964:	ad 83       	std	Y+5, r26	; 0x05
    1966:	be 83       	std	Y+6, r27	; 0x06

	/* Adjust for correct value. */
	ulCompareMatch -= ( unsigned long ) 1;
    1968:	8b 81       	ldd	r24, Y+3	; 0x03
    196a:	9c 81       	ldd	r25, Y+4	; 0x04
    196c:	ad 81       	ldd	r26, Y+5	; 0x05
    196e:	be 81       	ldd	r27, Y+6	; 0x06
    1970:	01 97       	sbiw	r24, 0x01	; 1
    1972:	a1 09       	sbc	r26, r1
    1974:	b1 09       	sbc	r27, r1
    1976:	8b 83       	std	Y+3, r24	; 0x03
    1978:	9c 83       	std	Y+4, r25	; 0x04
    197a:	ad 83       	std	Y+5, r26	; 0x05
    197c:	be 83       	std	Y+6, r27	; 0x06

	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
    197e:	8b 81       	ldd	r24, Y+3	; 0x03
    1980:	89 83       	std	Y+1, r24	; 0x01
	ulCompareMatch >>= 8;
    1982:	8b 81       	ldd	r24, Y+3	; 0x03
    1984:	9c 81       	ldd	r25, Y+4	; 0x04
    1986:	ad 81       	ldd	r26, Y+5	; 0x05
    1988:	be 81       	ldd	r27, Y+6	; 0x06
    198a:	89 2f       	mov	r24, r25
    198c:	9a 2f       	mov	r25, r26
    198e:	ab 2f       	mov	r26, r27
    1990:	bb 27       	eor	r27, r27
    1992:	8b 83       	std	Y+3, r24	; 0x03
    1994:	9c 83       	std	Y+4, r25	; 0x04
    1996:	ad 83       	std	Y+5, r26	; 0x05
    1998:	be 83       	std	Y+6, r27	; 0x06
	ucHighByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
    199a:	8b 81       	ldd	r24, Y+3	; 0x03
    199c:	8a 83       	std	Y+2, r24	; 0x02
	OCR1AH = ucHighByte;
    199e:	eb e4       	ldi	r30, 0x4B	; 75
    19a0:	f0 e0       	ldi	r31, 0x00	; 0
    19a2:	8a 81       	ldd	r24, Y+2	; 0x02
    19a4:	80 83       	st	Z, r24
	OCR1AL = ucLowByte;
    19a6:	ea e4       	ldi	r30, 0x4A	; 74
    19a8:	f0 e0       	ldi	r31, 0x00	; 0
    19aa:	89 81       	ldd	r24, Y+1	; 0x01
    19ac:	80 83       	st	Z, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
    19ae:	8b e0       	ldi	r24, 0x0B	; 11
    19b0:	89 83       	std	Y+1, r24	; 0x01
	TCCR1B = ucLowByte;
    19b2:	ee e4       	ldi	r30, 0x4E	; 78
    19b4:	f0 e0       	ldi	r31, 0x00	; 0
    19b6:	89 81       	ldd	r24, Y+1	; 0x01
    19b8:	80 83       	st	Z, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
    19ba:	e9 e5       	ldi	r30, 0x59	; 89
    19bc:	f0 e0       	ldi	r31, 0x00	; 0
    19be:	80 81       	ld	r24, Z
    19c0:	89 83       	std	Y+1, r24	; 0x01
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    19c2:	89 81       	ldd	r24, Y+1	; 0x01
    19c4:	80 61       	ori	r24, 0x10	; 16
    19c6:	89 83       	std	Y+1, r24	; 0x01
	TIMSK = ucLowByte;
    19c8:	e9 e5       	ldi	r30, 0x59	; 89
    19ca:	f0 e0       	ldi	r31, 0x00	; 0
    19cc:	89 81       	ldd	r24, Y+1	; 0x01
    19ce:	80 83       	st	Z, r24
}
    19d0:	26 96       	adiw	r28, 0x06	; 6
    19d2:	0f b6       	in	r0, 0x3f	; 63
    19d4:	f8 94       	cli
    19d6:	de bf       	out	0x3e, r29	; 62
    19d8:	0f be       	out	0x3f, r0	; 63
    19da:	cd bf       	out	0x3d, r28	; 61
    19dc:	cf 91       	pop	r28
    19de:	df 91       	pop	r29
    19e0:	08 95       	ret

000019e2 <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void SIG_OUTPUT_COMPARE1A( void ) __attribute__ ( ( signal, naked ) );
	void SIG_OUTPUT_COMPARE1A( void )
	{
		vPortYieldFromTick();
    19e2:	0e 94 3a 0c 	call	0x1874	; 0x1874 <vPortYieldFromTick>
		asm volatile ( "reti" );
    19e6:	18 95       	reti

000019e8 <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
    19e8:	df 93       	push	r29
    19ea:	cf 93       	push	r28
    19ec:	cd b7       	in	r28, 0x3d	; 61
    19ee:	de b7       	in	r29, 0x3e	; 62
    19f0:	28 97       	sbiw	r28, 0x08	; 8
    19f2:	0f b6       	in	r0, 0x3f	; 63
    19f4:	f8 94       	cli
    19f6:	de bf       	out	0x3e, r29	; 62
    19f8:	0f be       	out	0x3f, r0	; 63
    19fa:	cd bf       	out	0x3d, r28	; 61
    19fc:	8f 83       	std	Y+7, r24	; 0x07
    19fe:	68 87       	std	Y+8, r22	; 0x08
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;
    1a00:	1a 82       	std	Y+2, r1	; 0x02
    1a02:	19 82       	std	Y+1, r1	; 0x01

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
    1a04:	8f 81       	ldd	r24, Y+7	; 0x07
    1a06:	88 23       	and	r24, r24
    1a08:	09 f4       	brne	.+2      	; 0x1a0c <xQueueCreate+0x24>
    1a0a:	8c c0       	rjmp	.+280    	; 0x1b24 <xQueueCreate+0x13c>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
    1a0c:	8f e1       	ldi	r24, 0x1F	; 31
    1a0e:	90 e0       	ldi	r25, 0x00	; 0
    1a10:	0e 94 7b 08 	call	0x10f6	; 0x10f6 <pvPortMalloc>
    1a14:	9e 83       	std	Y+6, r25	; 0x06
    1a16:	8d 83       	std	Y+5, r24	; 0x05
		if( pxNewQueue != NULL )
    1a18:	8d 81       	ldd	r24, Y+5	; 0x05
    1a1a:	9e 81       	ldd	r25, Y+6	; 0x06
    1a1c:	00 97       	sbiw	r24, 0x00	; 0
    1a1e:	09 f4       	brne	.+2      	; 0x1a22 <xQueueCreate+0x3a>
    1a20:	81 c0       	rjmp	.+258    	; 0x1b24 <xQueueCreate+0x13c>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
    1a22:	8f 81       	ldd	r24, Y+7	; 0x07
    1a24:	28 2f       	mov	r18, r24
    1a26:	30 e0       	ldi	r19, 0x00	; 0
    1a28:	88 85       	ldd	r24, Y+8	; 0x08
    1a2a:	88 2f       	mov	r24, r24
    1a2c:	90 e0       	ldi	r25, 0x00	; 0
    1a2e:	ac 01       	movw	r20, r24
    1a30:	24 9f       	mul	r18, r20
    1a32:	c0 01       	movw	r24, r0
    1a34:	25 9f       	mul	r18, r21
    1a36:	90 0d       	add	r25, r0
    1a38:	34 9f       	mul	r19, r20
    1a3a:	90 0d       	add	r25, r0
    1a3c:	11 24       	eor	r1, r1
    1a3e:	01 96       	adiw	r24, 0x01	; 1
    1a40:	9c 83       	std	Y+4, r25	; 0x04
    1a42:	8b 83       	std	Y+3, r24	; 0x03

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
    1a44:	8b 81       	ldd	r24, Y+3	; 0x03
    1a46:	9c 81       	ldd	r25, Y+4	; 0x04
    1a48:	0e 94 7b 08 	call	0x10f6	; 0x10f6 <pvPortMalloc>
    1a4c:	ed 81       	ldd	r30, Y+5	; 0x05
    1a4e:	fe 81       	ldd	r31, Y+6	; 0x06
    1a50:	91 83       	std	Z+1, r25	; 0x01
    1a52:	80 83       	st	Z, r24
			if( pxNewQueue->pcHead != NULL )
    1a54:	ed 81       	ldd	r30, Y+5	; 0x05
    1a56:	fe 81       	ldd	r31, Y+6	; 0x06
    1a58:	80 81       	ld	r24, Z
    1a5a:	91 81       	ldd	r25, Z+1	; 0x01
    1a5c:	00 97       	sbiw	r24, 0x00	; 0
    1a5e:	09 f4       	brne	.+2      	; 0x1a62 <xQueueCreate+0x7a>
    1a60:	5d c0       	rjmp	.+186    	; 0x1b1c <xQueueCreate+0x134>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
    1a62:	ed 81       	ldd	r30, Y+5	; 0x05
    1a64:	fe 81       	ldd	r31, Y+6	; 0x06
    1a66:	40 81       	ld	r20, Z
    1a68:	51 81       	ldd	r21, Z+1	; 0x01
    1a6a:	8f 81       	ldd	r24, Y+7	; 0x07
    1a6c:	28 2f       	mov	r18, r24
    1a6e:	30 e0       	ldi	r19, 0x00	; 0
    1a70:	88 85       	ldd	r24, Y+8	; 0x08
    1a72:	88 2f       	mov	r24, r24
    1a74:	90 e0       	ldi	r25, 0x00	; 0
    1a76:	bc 01       	movw	r22, r24
    1a78:	26 9f       	mul	r18, r22
    1a7a:	c0 01       	movw	r24, r0
    1a7c:	27 9f       	mul	r18, r23
    1a7e:	90 0d       	add	r25, r0
    1a80:	36 9f       	mul	r19, r22
    1a82:	90 0d       	add	r25, r0
    1a84:	11 24       	eor	r1, r1
    1a86:	84 0f       	add	r24, r20
    1a88:	95 1f       	adc	r25, r21
    1a8a:	ed 81       	ldd	r30, Y+5	; 0x05
    1a8c:	fe 81       	ldd	r31, Y+6	; 0x06
    1a8e:	93 83       	std	Z+3, r25	; 0x03
    1a90:	82 83       	std	Z+2, r24	; 0x02
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
    1a92:	ed 81       	ldd	r30, Y+5	; 0x05
    1a94:	fe 81       	ldd	r31, Y+6	; 0x06
    1a96:	12 8e       	std	Z+26, r1	; 0x1a
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
    1a98:	ed 81       	ldd	r30, Y+5	; 0x05
    1a9a:	fe 81       	ldd	r31, Y+6	; 0x06
    1a9c:	80 81       	ld	r24, Z
    1a9e:	91 81       	ldd	r25, Z+1	; 0x01
    1aa0:	ed 81       	ldd	r30, Y+5	; 0x05
    1aa2:	fe 81       	ldd	r31, Y+6	; 0x06
    1aa4:	95 83       	std	Z+5, r25	; 0x05
    1aa6:	84 83       	std	Z+4, r24	; 0x04
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
    1aa8:	ed 81       	ldd	r30, Y+5	; 0x05
    1aaa:	fe 81       	ldd	r31, Y+6	; 0x06
    1aac:	40 81       	ld	r20, Z
    1aae:	51 81       	ldd	r21, Z+1	; 0x01
    1ab0:	8f 81       	ldd	r24, Y+7	; 0x07
    1ab2:	88 2f       	mov	r24, r24
    1ab4:	90 e0       	ldi	r25, 0x00	; 0
    1ab6:	9c 01       	movw	r18, r24
    1ab8:	21 50       	subi	r18, 0x01	; 1
    1aba:	30 40       	sbci	r19, 0x00	; 0
    1abc:	88 85       	ldd	r24, Y+8	; 0x08
    1abe:	88 2f       	mov	r24, r24
    1ac0:	90 e0       	ldi	r25, 0x00	; 0
    1ac2:	bc 01       	movw	r22, r24
    1ac4:	26 9f       	mul	r18, r22
    1ac6:	c0 01       	movw	r24, r0
    1ac8:	27 9f       	mul	r18, r23
    1aca:	90 0d       	add	r25, r0
    1acc:	36 9f       	mul	r19, r22
    1ace:	90 0d       	add	r25, r0
    1ad0:	11 24       	eor	r1, r1
    1ad2:	84 0f       	add	r24, r20
    1ad4:	95 1f       	adc	r25, r21
    1ad6:	ed 81       	ldd	r30, Y+5	; 0x05
    1ad8:	fe 81       	ldd	r31, Y+6	; 0x06
    1ada:	97 83       	std	Z+7, r25	; 0x07
    1adc:	86 83       	std	Z+6, r24	; 0x06
				pxNewQueue->uxLength = uxQueueLength;
    1ade:	ed 81       	ldd	r30, Y+5	; 0x05
    1ae0:	fe 81       	ldd	r31, Y+6	; 0x06
    1ae2:	8f 81       	ldd	r24, Y+7	; 0x07
    1ae4:	83 8f       	std	Z+27, r24	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
    1ae6:	ed 81       	ldd	r30, Y+5	; 0x05
    1ae8:	fe 81       	ldd	r31, Y+6	; 0x06
    1aea:	88 85       	ldd	r24, Y+8	; 0x08
    1aec:	84 8f       	std	Z+28, r24	; 0x1c
				pxNewQueue->xRxLock = queueUNLOCKED;
    1aee:	ed 81       	ldd	r30, Y+5	; 0x05
    1af0:	fe 81       	ldd	r31, Y+6	; 0x06
    1af2:	8f ef       	ldi	r24, 0xFF	; 255
    1af4:	85 8f       	std	Z+29, r24	; 0x1d
				pxNewQueue->xTxLock = queueUNLOCKED;
    1af6:	ed 81       	ldd	r30, Y+5	; 0x05
    1af8:	fe 81       	ldd	r31, Y+6	; 0x06
    1afa:	8f ef       	ldi	r24, 0xFF	; 255
    1afc:	86 8f       	std	Z+30, r24	; 0x1e

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
    1afe:	8d 81       	ldd	r24, Y+5	; 0x05
    1b00:	9e 81       	ldd	r25, Y+6	; 0x06
    1b02:	08 96       	adiw	r24, 0x08	; 8
    1b04:	0e 94 e7 08 	call	0x11ce	; 0x11ce <vListInitialise>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
    1b08:	8d 81       	ldd	r24, Y+5	; 0x05
    1b0a:	9e 81       	ldd	r25, Y+6	; 0x06
    1b0c:	41 96       	adiw	r24, 0x11	; 17
    1b0e:	0e 94 e7 08 	call	0x11ce	; 0x11ce <vListInitialise>

				traceQUEUE_CREATE( pxNewQueue );
				xReturn = pxNewQueue;
    1b12:	8d 81       	ldd	r24, Y+5	; 0x05
    1b14:	9e 81       	ldd	r25, Y+6	; 0x06
    1b16:	9a 83       	std	Y+2, r25	; 0x02
    1b18:	89 83       	std	Y+1, r24	; 0x01
    1b1a:	04 c0       	rjmp	.+8      	; 0x1b24 <xQueueCreate+0x13c>
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
    1b1c:	8d 81       	ldd	r24, Y+5	; 0x05
    1b1e:	9e 81       	ldd	r25, Y+6	; 0x06
    1b20:	0e 94 c1 08 	call	0x1182	; 0x1182 <vPortFree>
		}
	}

	configASSERT( xReturn );

	return xReturn;
    1b24:	89 81       	ldd	r24, Y+1	; 0x01
    1b26:	9a 81       	ldd	r25, Y+2	; 0x02
}
    1b28:	28 96       	adiw	r28, 0x08	; 8
    1b2a:	0f b6       	in	r0, 0x3f	; 63
    1b2c:	f8 94       	cli
    1b2e:	de bf       	out	0x3e, r29	; 62
    1b30:	0f be       	out	0x3f, r0	; 63
    1b32:	cd bf       	out	0x3d, r28	; 61
    1b34:	cf 91       	pop	r28
    1b36:	df 91       	pop	r29
    1b38:	08 95       	ret

00001b3a <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	xQueueHandle xQueueCreateMutex( void )
	{
    1b3a:	df 93       	push	r29
    1b3c:	cf 93       	push	r28
    1b3e:	00 d0       	rcall	.+0      	; 0x1b40 <xQueueCreateMutex+0x6>
    1b40:	cd b7       	in	r28, 0x3d	; 61
    1b42:	de b7       	in	r29, 0x3e	; 62
	xQUEUE *pxNewQueue;

		/* Allocate the new queue structure. */
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
    1b44:	8f e1       	ldi	r24, 0x1F	; 31
    1b46:	90 e0       	ldi	r25, 0x00	; 0
    1b48:	0e 94 7b 08 	call	0x10f6	; 0x10f6 <pvPortMalloc>
    1b4c:	9a 83       	std	Y+2, r25	; 0x02
    1b4e:	89 83       	std	Y+1, r24	; 0x01
		if( pxNewQueue != NULL )
    1b50:	89 81       	ldd	r24, Y+1	; 0x01
    1b52:	9a 81       	ldd	r25, Y+2	; 0x02
    1b54:	00 97       	sbiw	r24, 0x00	; 0
    1b56:	a9 f1       	breq	.+106    	; 0x1bc2 <xQueueCreateMutex+0x88>
		{
			/* Information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
    1b58:	e9 81       	ldd	r30, Y+1	; 0x01
    1b5a:	fa 81       	ldd	r31, Y+2	; 0x02
    1b5c:	13 82       	std	Z+3, r1	; 0x03
    1b5e:	12 82       	std	Z+2, r1	; 0x02
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
    1b60:	e9 81       	ldd	r30, Y+1	; 0x01
    1b62:	fa 81       	ldd	r31, Y+2	; 0x02
    1b64:	11 82       	std	Z+1, r1	; 0x01
    1b66:	10 82       	st	Z, r1

			/* Queues used as a mutex no data is actually copied into or out
			of the queue. */
			pxNewQueue->pcWriteTo = NULL;
    1b68:	e9 81       	ldd	r30, Y+1	; 0x01
    1b6a:	fa 81       	ldd	r31, Y+2	; 0x02
    1b6c:	15 82       	std	Z+5, r1	; 0x05
    1b6e:	14 82       	std	Z+4, r1	; 0x04
			pxNewQueue->pcReadFrom = NULL;
    1b70:	e9 81       	ldd	r30, Y+1	; 0x01
    1b72:	fa 81       	ldd	r31, Y+2	; 0x02
    1b74:	17 82       	std	Z+7, r1	; 0x07
    1b76:	16 82       	std	Z+6, r1	; 0x06

			/* Each mutex has a length of 1 (like a binary semaphore) and
			an item size of 0 as nothing is actually copied into or out
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
    1b78:	e9 81       	ldd	r30, Y+1	; 0x01
    1b7a:	fa 81       	ldd	r31, Y+2	; 0x02
    1b7c:	12 8e       	std	Z+26, r1	; 0x1a
			pxNewQueue->uxLength = ( unsigned portBASE_TYPE ) 1U;
    1b7e:	e9 81       	ldd	r30, Y+1	; 0x01
    1b80:	fa 81       	ldd	r31, Y+2	; 0x02
    1b82:	81 e0       	ldi	r24, 0x01	; 1
    1b84:	83 8f       	std	Z+27, r24	; 0x1b
			pxNewQueue->uxItemSize = ( unsigned portBASE_TYPE ) 0U;
    1b86:	e9 81       	ldd	r30, Y+1	; 0x01
    1b88:	fa 81       	ldd	r31, Y+2	; 0x02
    1b8a:	14 8e       	std	Z+28, r1	; 0x1c
			pxNewQueue->xRxLock = queueUNLOCKED;
    1b8c:	e9 81       	ldd	r30, Y+1	; 0x01
    1b8e:	fa 81       	ldd	r31, Y+2	; 0x02
    1b90:	8f ef       	ldi	r24, 0xFF	; 255
    1b92:	85 8f       	std	Z+29, r24	; 0x1d
			pxNewQueue->xTxLock = queueUNLOCKED;
    1b94:	e9 81       	ldd	r30, Y+1	; 0x01
    1b96:	fa 81       	ldd	r31, Y+2	; 0x02
    1b98:	8f ef       	ldi	r24, 0xFF	; 255
    1b9a:	86 8f       	std	Z+30, r24	; 0x1e

			/* Ensure the event queues start with the correct state. */
			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
    1b9c:	89 81       	ldd	r24, Y+1	; 0x01
    1b9e:	9a 81       	ldd	r25, Y+2	; 0x02
    1ba0:	08 96       	adiw	r24, 0x08	; 8
    1ba2:	0e 94 e7 08 	call	0x11ce	; 0x11ce <vListInitialise>
			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
    1ba6:	89 81       	ldd	r24, Y+1	; 0x01
    1ba8:	9a 81       	ldd	r25, Y+2	; 0x02
    1baa:	41 96       	adiw	r24, 0x11	; 17
    1bac:	0e 94 e7 08 	call	0x11ce	; 0x11ce <vListInitialise>

			/* Start with the semaphore in the expected state. */
			xQueueGenericSend( pxNewQueue, NULL, ( portTickType ) 0U, queueSEND_TO_BACK );
    1bb0:	89 81       	ldd	r24, Y+1	; 0x01
    1bb2:	9a 81       	ldd	r25, Y+2	; 0x02
    1bb4:	60 e0       	ldi	r22, 0x00	; 0
    1bb6:	70 e0       	ldi	r23, 0x00	; 0
    1bb8:	40 e0       	ldi	r20, 0x00	; 0
    1bba:	50 e0       	ldi	r21, 0x00	; 0
    1bbc:	20 e0       	ldi	r18, 0x00	; 0
    1bbe:	0e 94 07 0e 	call	0x1c0e	; 0x1c0e <xQueueGenericSend>
		{
			traceCREATE_MUTEX_FAILED();
		}

		configASSERT( pxNewQueue );
		return pxNewQueue;
    1bc2:	89 81       	ldd	r24, Y+1	; 0x01
    1bc4:	9a 81       	ldd	r25, Y+2	; 0x02
	}
    1bc6:	0f 90       	pop	r0
    1bc8:	0f 90       	pop	r0
    1bca:	cf 91       	pop	r28
    1bcc:	df 91       	pop	r29
    1bce:	08 95       	ret

00001bd0 <xQueueCreateCountingSemaphore>:
/*-----------------------------------------------------------*/

#if configUSE_COUNTING_SEMAPHORES == 1

	xQueueHandle xQueueCreateCountingSemaphore( unsigned portBASE_TYPE uxCountValue, unsigned portBASE_TYPE uxInitialCount )
	{
    1bd0:	df 93       	push	r29
    1bd2:	cf 93       	push	r28
    1bd4:	00 d0       	rcall	.+0      	; 0x1bd6 <xQueueCreateCountingSemaphore+0x6>
    1bd6:	00 d0       	rcall	.+0      	; 0x1bd8 <xQueueCreateCountingSemaphore+0x8>
    1bd8:	cd b7       	in	r28, 0x3d	; 61
    1bda:	de b7       	in	r29, 0x3e	; 62
    1bdc:	8b 83       	std	Y+3, r24	; 0x03
    1bde:	6c 83       	std	Y+4, r22	; 0x04
	xQueueHandle pxHandle;

		pxHandle = xQueueCreate( ( unsigned portBASE_TYPE ) uxCountValue, queueSEMAPHORE_QUEUE_ITEM_LENGTH );
    1be0:	8b 81       	ldd	r24, Y+3	; 0x03
    1be2:	60 e0       	ldi	r22, 0x00	; 0
    1be4:	0e 94 f4 0c 	call	0x19e8	; 0x19e8 <xQueueCreate>
    1be8:	9a 83       	std	Y+2, r25	; 0x02
    1bea:	89 83       	std	Y+1, r24	; 0x01

		if( pxHandle != NULL )
    1bec:	89 81       	ldd	r24, Y+1	; 0x01
    1bee:	9a 81       	ldd	r25, Y+2	; 0x02
    1bf0:	00 97       	sbiw	r24, 0x00	; 0
    1bf2:	21 f0       	breq	.+8      	; 0x1bfc <xQueueCreateCountingSemaphore+0x2c>
		{
			pxHandle->uxMessagesWaiting = uxInitialCount;
    1bf4:	e9 81       	ldd	r30, Y+1	; 0x01
    1bf6:	fa 81       	ldd	r31, Y+2	; 0x02
    1bf8:	8c 81       	ldd	r24, Y+4	; 0x04
    1bfa:	82 8f       	std	Z+26, r24	; 0x1a
		{
			traceCREATE_COUNTING_SEMAPHORE_FAILED();
		}

		configASSERT( pxHandle );
		return pxHandle;
    1bfc:	89 81       	ldd	r24, Y+1	; 0x01
    1bfe:	9a 81       	ldd	r25, Y+2	; 0x02
	}
    1c00:	0f 90       	pop	r0
    1c02:	0f 90       	pop	r0
    1c04:	0f 90       	pop	r0
    1c06:	0f 90       	pop	r0
    1c08:	cf 91       	pop	r28
    1c0a:	df 91       	pop	r29
    1c0c:	08 95       	ret

00001c0e <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
    1c0e:	df 93       	push	r29
    1c10:	cf 93       	push	r28
    1c12:	cd b7       	in	r28, 0x3d	; 61
    1c14:	de b7       	in	r29, 0x3e	; 62
    1c16:	2c 97       	sbiw	r28, 0x0c	; 12
    1c18:	0f b6       	in	r0, 0x3f	; 63
    1c1a:	f8 94       	cli
    1c1c:	de bf       	out	0x3e, r29	; 62
    1c1e:	0f be       	out	0x3f, r0	; 63
    1c20:	cd bf       	out	0x3d, r28	; 61
    1c22:	9e 83       	std	Y+6, r25	; 0x06
    1c24:	8d 83       	std	Y+5, r24	; 0x05
    1c26:	78 87       	std	Y+8, r23	; 0x08
    1c28:	6f 83       	std	Y+7, r22	; 0x07
    1c2a:	5a 87       	std	Y+10, r21	; 0x0a
    1c2c:	49 87       	std	Y+9, r20	; 0x09
    1c2e:	2b 87       	std	Y+11, r18	; 0x0b
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    1c30:	19 82       	std	Y+1, r1	; 0x01
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    1c32:	0f b6       	in	r0, 0x3f	; 63
    1c34:	f8 94       	cli
    1c36:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    1c38:	ed 81       	ldd	r30, Y+5	; 0x05
    1c3a:	fe 81       	ldd	r31, Y+6	; 0x06
    1c3c:	92 8d       	ldd	r25, Z+26	; 0x1a
    1c3e:	ed 81       	ldd	r30, Y+5	; 0x05
    1c40:	fe 81       	ldd	r31, Y+6	; 0x06
    1c42:	83 8d       	ldd	r24, Z+27	; 0x1b
    1c44:	98 17       	cp	r25, r24
    1c46:	d8 f4       	brcc	.+54     	; 0x1c7e <xQueueGenericSend+0x70>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    1c48:	8d 81       	ldd	r24, Y+5	; 0x05
    1c4a:	9e 81       	ldd	r25, Y+6	; 0x06
    1c4c:	2f 81       	ldd	r18, Y+7	; 0x07
    1c4e:	38 85       	ldd	r19, Y+8	; 0x08
    1c50:	b9 01       	movw	r22, r18
    1c52:	4b 85       	ldd	r20, Y+11	; 0x0b
    1c54:	0e 94 5f 10 	call	0x20be	; 0x20be <prvCopyDataToQueue>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1c58:	ed 81       	ldd	r30, Y+5	; 0x05
    1c5a:	fe 81       	ldd	r31, Y+6	; 0x06
    1c5c:	81 89       	ldd	r24, Z+17	; 0x11
    1c5e:	88 23       	and	r24, r24
    1c60:	49 f0       	breq	.+18     	; 0x1c74 <xQueueGenericSend+0x66>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    1c62:	8d 81       	ldd	r24, Y+5	; 0x05
    1c64:	9e 81       	ldd	r25, Y+6	; 0x06
    1c66:	41 96       	adiw	r24, 0x11	; 17
    1c68:	0e 94 85 16 	call	0x2d0a	; 0x2d0a <xTaskRemoveFromEventList>
    1c6c:	81 30       	cpi	r24, 0x01	; 1
    1c6e:	11 f4       	brne	.+4      	; 0x1c74 <xQueueGenericSend+0x66>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
    1c70:	0e 94 e1 0b 	call	0x17c2	; 0x17c2 <vPortYield>
					}
				}

				taskEXIT_CRITICAL();
    1c74:	0f 90       	pop	r0
    1c76:	0f be       	out	0x3f, r0	; 63

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
    1c78:	81 e0       	ldi	r24, 0x01	; 1
    1c7a:	8c 87       	std	Y+12, r24	; 0x0c
    1c7c:	5c c0       	rjmp	.+184    	; 0x1d36 <xQueueGenericSend+0x128>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    1c7e:	89 85       	ldd	r24, Y+9	; 0x09
    1c80:	9a 85       	ldd	r25, Y+10	; 0x0a
    1c82:	00 97       	sbiw	r24, 0x00	; 0
    1c84:	21 f4       	brne	.+8      	; 0x1c8e <xQueueGenericSend+0x80>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1c86:	0f 90       	pop	r0
    1c88:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    1c8a:	1c 86       	std	Y+12, r1	; 0x0c
    1c8c:	54 c0       	rjmp	.+168    	; 0x1d36 <xQueueGenericSend+0x128>
				}
				else if( xEntryTimeSet == pdFALSE )
    1c8e:	89 81       	ldd	r24, Y+1	; 0x01
    1c90:	88 23       	and	r24, r24
    1c92:	31 f4       	brne	.+12     	; 0x1ca0 <xQueueGenericSend+0x92>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1c94:	ce 01       	movw	r24, r28
    1c96:	02 96       	adiw	r24, 0x02	; 2
    1c98:	0e 94 ed 16 	call	0x2dda	; 0x2dda <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1c9c:	81 e0       	ldi	r24, 0x01	; 1
    1c9e:	89 83       	std	Y+1, r24	; 0x01
				}
			}
		}
		taskEXIT_CRITICAL();
    1ca0:	0f 90       	pop	r0
    1ca2:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1ca4:	0e 94 49 14 	call	0x2892	; 0x2892 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1ca8:	0f b6       	in	r0, 0x3f	; 63
    1caa:	f8 94       	cli
    1cac:	0f 92       	push	r0
    1cae:	ed 81       	ldd	r30, Y+5	; 0x05
    1cb0:	fe 81       	ldd	r31, Y+6	; 0x06
    1cb2:	85 8d       	ldd	r24, Z+29	; 0x1d
    1cb4:	8f 3f       	cpi	r24, 0xFF	; 255
    1cb6:	19 f4       	brne	.+6      	; 0x1cbe <xQueueGenericSend+0xb0>
    1cb8:	ed 81       	ldd	r30, Y+5	; 0x05
    1cba:	fe 81       	ldd	r31, Y+6	; 0x06
    1cbc:	15 8e       	std	Z+29, r1	; 0x1d
    1cbe:	ed 81       	ldd	r30, Y+5	; 0x05
    1cc0:	fe 81       	ldd	r31, Y+6	; 0x06
    1cc2:	86 8d       	ldd	r24, Z+30	; 0x1e
    1cc4:	8f 3f       	cpi	r24, 0xFF	; 255
    1cc6:	19 f4       	brne	.+6      	; 0x1cce <xQueueGenericSend+0xc0>
    1cc8:	ed 81       	ldd	r30, Y+5	; 0x05
    1cca:	fe 81       	ldd	r31, Y+6	; 0x06
    1ccc:	16 8e       	std	Z+30, r1	; 0x1e
    1cce:	0f 90       	pop	r0
    1cd0:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1cd2:	ce 01       	movw	r24, r28
    1cd4:	02 96       	adiw	r24, 0x02	; 2
    1cd6:	9e 01       	movw	r18, r28
    1cd8:	27 5f       	subi	r18, 0xF7	; 247
    1cda:	3f 4f       	sbci	r19, 0xFF	; 255
    1cdc:	b9 01       	movw	r22, r18
    1cde:	0e 94 06 17 	call	0x2e0c	; 0x2e0c <xTaskCheckForTimeOut>
    1ce2:	88 23       	and	r24, r24
    1ce4:	09 f5       	brne	.+66     	; 0x1d28 <xQueueGenericSend+0x11a>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    1ce6:	8d 81       	ldd	r24, Y+5	; 0x05
    1ce8:	9e 81       	ldd	r25, Y+6	; 0x06
    1cea:	0e 94 d4 11 	call	0x23a8	; 0x23a8 <prvIsQueueFull>
    1cee:	88 23       	and	r24, r24
    1cf0:	a1 f0       	breq	.+40     	; 0x1d1a <xQueueGenericSend+0x10c>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    1cf2:	8d 81       	ldd	r24, Y+5	; 0x05
    1cf4:	9e 81       	ldd	r25, Y+6	; 0x06
    1cf6:	08 96       	adiw	r24, 0x08	; 8
    1cf8:	29 85       	ldd	r18, Y+9	; 0x09
    1cfa:	3a 85       	ldd	r19, Y+10	; 0x0a
    1cfc:	b9 01       	movw	r22, r18
    1cfe:	0e 94 4f 16 	call	0x2c9e	; 0x2c9e <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    1d02:	8d 81       	ldd	r24, Y+5	; 0x05
    1d04:	9e 81       	ldd	r25, Y+6	; 0x06
    1d06:	0e 94 4d 11 	call	0x229a	; 0x229a <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    1d0a:	0e 94 55 14 	call	0x28aa	; 0x28aa <xTaskResumeAll>
    1d0e:	88 23       	and	r24, r24
    1d10:	09 f0       	breq	.+2      	; 0x1d14 <xQueueGenericSend+0x106>
    1d12:	8f cf       	rjmp	.-226    	; 0x1c32 <xQueueGenericSend+0x24>
				{
					portYIELD_WITHIN_API();
    1d14:	0e 94 e1 0b 	call	0x17c2	; 0x17c2 <vPortYield>
    1d18:	8c cf       	rjmp	.-232    	; 0x1c32 <xQueueGenericSend+0x24>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1d1a:	8d 81       	ldd	r24, Y+5	; 0x05
    1d1c:	9e 81       	ldd	r25, Y+6	; 0x06
    1d1e:	0e 94 4d 11 	call	0x229a	; 0x229a <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1d22:	0e 94 55 14 	call	0x28aa	; 0x28aa <xTaskResumeAll>
    1d26:	85 cf       	rjmp	.-246    	; 0x1c32 <xQueueGenericSend+0x24>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    1d28:	8d 81       	ldd	r24, Y+5	; 0x05
    1d2a:	9e 81       	ldd	r25, Y+6	; 0x06
    1d2c:	0e 94 4d 11 	call	0x229a	; 0x229a <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1d30:	0e 94 55 14 	call	0x28aa	; 0x28aa <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    1d34:	1c 86       	std	Y+12, r1	; 0x0c
    1d36:	8c 85       	ldd	r24, Y+12	; 0x0c
		}
	}
}
    1d38:	2c 96       	adiw	r28, 0x0c	; 12
    1d3a:	0f b6       	in	r0, 0x3f	; 63
    1d3c:	f8 94       	cli
    1d3e:	de bf       	out	0x3e, r29	; 62
    1d40:	0f be       	out	0x3f, r0	; 63
    1d42:	cd bf       	out	0x3d, r28	; 61
    1d44:	cf 91       	pop	r28
    1d46:	df 91       	pop	r29
    1d48:	08 95       	ret

00001d4a <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
    1d4a:	df 93       	push	r29
    1d4c:	cf 93       	push	r28
    1d4e:	cd b7       	in	r28, 0x3d	; 61
    1d50:	de b7       	in	r29, 0x3e	; 62
    1d52:	29 97       	sbiw	r28, 0x09	; 9
    1d54:	0f b6       	in	r0, 0x3f	; 63
    1d56:	f8 94       	cli
    1d58:	de bf       	out	0x3e, r29	; 62
    1d5a:	0f be       	out	0x3f, r0	; 63
    1d5c:	cd bf       	out	0x3d, r28	; 61
    1d5e:	9c 83       	std	Y+4, r25	; 0x04
    1d60:	8b 83       	std	Y+3, r24	; 0x03
    1d62:	7e 83       	std	Y+6, r23	; 0x06
    1d64:	6d 83       	std	Y+5, r22	; 0x05
    1d66:	58 87       	std	Y+8, r21	; 0x08
    1d68:	4f 83       	std	Y+7, r20	; 0x07
    1d6a:	29 87       	std	Y+9, r18	; 0x09
	/* Similar to xQueueGenericSend, except we don't block if there is no room
	in the queue.  Also we don't directly wake a task that was blocked on a
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    1d6c:	19 82       	std	Y+1, r1	; 0x01
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    1d6e:	eb 81       	ldd	r30, Y+3	; 0x03
    1d70:	fc 81       	ldd	r31, Y+4	; 0x04
    1d72:	92 8d       	ldd	r25, Z+26	; 0x1a
    1d74:	eb 81       	ldd	r30, Y+3	; 0x03
    1d76:	fc 81       	ldd	r31, Y+4	; 0x04
    1d78:	83 8d       	ldd	r24, Z+27	; 0x1b
    1d7a:	98 17       	cp	r25, r24
    1d7c:	40 f5       	brcc	.+80     	; 0x1dce <xQueueGenericSendFromISR+0x84>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    1d7e:	8b 81       	ldd	r24, Y+3	; 0x03
    1d80:	9c 81       	ldd	r25, Y+4	; 0x04
    1d82:	2d 81       	ldd	r18, Y+5	; 0x05
    1d84:	3e 81       	ldd	r19, Y+6	; 0x06
    1d86:	b9 01       	movw	r22, r18
    1d88:	49 85       	ldd	r20, Y+9	; 0x09
    1d8a:	0e 94 5f 10 	call	0x20be	; 0x20be <prvCopyDataToQueue>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    1d8e:	eb 81       	ldd	r30, Y+3	; 0x03
    1d90:	fc 81       	ldd	r31, Y+4	; 0x04
    1d92:	86 8d       	ldd	r24, Z+30	; 0x1e
    1d94:	8f 3f       	cpi	r24, 0xFF	; 255
    1d96:	89 f4       	brne	.+34     	; 0x1dba <xQueueGenericSendFromISR+0x70>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1d98:	eb 81       	ldd	r30, Y+3	; 0x03
    1d9a:	fc 81       	ldd	r31, Y+4	; 0x04
    1d9c:	81 89       	ldd	r24, Z+17	; 0x11
    1d9e:	88 23       	and	r24, r24
    1da0:	99 f0       	breq	.+38     	; 0x1dc8 <xQueueGenericSendFromISR+0x7e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1da2:	8b 81       	ldd	r24, Y+3	; 0x03
    1da4:	9c 81       	ldd	r25, Y+4	; 0x04
    1da6:	41 96       	adiw	r24, 0x11	; 17
    1da8:	0e 94 85 16 	call	0x2d0a	; 0x2d0a <xTaskRemoveFromEventList>
    1dac:	88 23       	and	r24, r24
    1dae:	61 f0       	breq	.+24     	; 0x1dc8 <xQueueGenericSendFromISR+0x7e>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
    1db0:	ef 81       	ldd	r30, Y+7	; 0x07
    1db2:	f8 85       	ldd	r31, Y+8	; 0x08
    1db4:	81 e0       	ldi	r24, 0x01	; 1
    1db6:	80 83       	st	Z, r24
    1db8:	07 c0       	rjmp	.+14     	; 0x1dc8 <xQueueGenericSendFromISR+0x7e>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    1dba:	eb 81       	ldd	r30, Y+3	; 0x03
    1dbc:	fc 81       	ldd	r31, Y+4	; 0x04
    1dbe:	86 8d       	ldd	r24, Z+30	; 0x1e
    1dc0:	8f 5f       	subi	r24, 0xFF	; 255
    1dc2:	eb 81       	ldd	r30, Y+3	; 0x03
    1dc4:	fc 81       	ldd	r31, Y+4	; 0x04
    1dc6:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    1dc8:	81 e0       	ldi	r24, 0x01	; 1
    1dca:	8a 83       	std	Y+2, r24	; 0x02
    1dcc:	01 c0       	rjmp	.+2      	; 0x1dd0 <xQueueGenericSendFromISR+0x86>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    1dce:	1a 82       	std	Y+2, r1	; 0x02
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    1dd0:	8a 81       	ldd	r24, Y+2	; 0x02
}
    1dd2:	29 96       	adiw	r28, 0x09	; 9
    1dd4:	0f b6       	in	r0, 0x3f	; 63
    1dd6:	f8 94       	cli
    1dd8:	de bf       	out	0x3e, r29	; 62
    1dda:	0f be       	out	0x3f, r0	; 63
    1ddc:	cd bf       	out	0x3d, r28	; 61
    1dde:	cf 91       	pop	r28
    1de0:	df 91       	pop	r29
    1de2:	08 95       	ret

00001de4 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
    1de4:	df 93       	push	r29
    1de6:	cf 93       	push	r28
    1de8:	cd b7       	in	r28, 0x3d	; 61
    1dea:	de b7       	in	r29, 0x3e	; 62
    1dec:	2e 97       	sbiw	r28, 0x0e	; 14
    1dee:	0f b6       	in	r0, 0x3f	; 63
    1df0:	f8 94       	cli
    1df2:	de bf       	out	0x3e, r29	; 62
    1df4:	0f be       	out	0x3f, r0	; 63
    1df6:	cd bf       	out	0x3d, r28	; 61
    1df8:	98 87       	std	Y+8, r25	; 0x08
    1dfa:	8f 83       	std	Y+7, r24	; 0x07
    1dfc:	7a 87       	std	Y+10, r23	; 0x0a
    1dfe:	69 87       	std	Y+9, r22	; 0x09
    1e00:	5c 87       	std	Y+12, r21	; 0x0c
    1e02:	4b 87       	std	Y+11, r20	; 0x0b
    1e04:	2d 87       	std	Y+13, r18	; 0x0d
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    1e06:	1b 82       	std	Y+3, r1	; 0x03
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    1e08:	0f b6       	in	r0, 0x3f	; 63
    1e0a:	f8 94       	cli
    1e0c:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    1e0e:	ef 81       	ldd	r30, Y+7	; 0x07
    1e10:	f8 85       	ldd	r31, Y+8	; 0x08
    1e12:	82 8d       	ldd	r24, Z+26	; 0x1a
    1e14:	88 23       	and	r24, r24
    1e16:	09 f4       	brne	.+2      	; 0x1e1a <xQueueGenericReceive+0x36>
    1e18:	4b c0       	rjmp	.+150    	; 0x1eb0 <xQueueGenericReceive+0xcc>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
    1e1a:	ef 81       	ldd	r30, Y+7	; 0x07
    1e1c:	f8 85       	ldd	r31, Y+8	; 0x08
    1e1e:	86 81       	ldd	r24, Z+6	; 0x06
    1e20:	97 81       	ldd	r25, Z+7	; 0x07
    1e22:	9a 83       	std	Y+2, r25	; 0x02
    1e24:	89 83       	std	Y+1, r24	; 0x01

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    1e26:	8f 81       	ldd	r24, Y+7	; 0x07
    1e28:	98 85       	ldd	r25, Y+8	; 0x08
    1e2a:	29 85       	ldd	r18, Y+9	; 0x09
    1e2c:	3a 85       	ldd	r19, Y+10	; 0x0a
    1e2e:	b9 01       	movw	r22, r18
    1e30:	0e 94 05 11 	call	0x220a	; 0x220a <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    1e34:	8d 85       	ldd	r24, Y+13	; 0x0d
    1e36:	88 23       	and	r24, r24
    1e38:	11 f5       	brne	.+68     	; 0x1e7e <xQueueGenericReceive+0x9a>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
    1e3a:	ef 81       	ldd	r30, Y+7	; 0x07
    1e3c:	f8 85       	ldd	r31, Y+8	; 0x08
    1e3e:	82 8d       	ldd	r24, Z+26	; 0x1a
    1e40:	81 50       	subi	r24, 0x01	; 1
    1e42:	ef 81       	ldd	r30, Y+7	; 0x07
    1e44:	f8 85       	ldd	r31, Y+8	; 0x08
    1e46:	82 8f       	std	Z+26, r24	; 0x1a

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    1e48:	ef 81       	ldd	r30, Y+7	; 0x07
    1e4a:	f8 85       	ldd	r31, Y+8	; 0x08
    1e4c:	80 81       	ld	r24, Z
    1e4e:	91 81       	ldd	r25, Z+1	; 0x01
    1e50:	00 97       	sbiw	r24, 0x00	; 0
    1e52:	31 f4       	brne	.+12     	; 0x1e60 <xQueueGenericReceive+0x7c>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
    1e54:	0e 94 fc 18 	call	0x31f8	; 0x31f8 <xTaskGetCurrentTaskHandle>
    1e58:	ef 81       	ldd	r30, Y+7	; 0x07
    1e5a:	f8 85       	ldd	r31, Y+8	; 0x08
    1e5c:	93 83       	std	Z+3, r25	; 0x03
    1e5e:	82 83       	std	Z+2, r24	; 0x02
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1e60:	ef 81       	ldd	r30, Y+7	; 0x07
    1e62:	f8 85       	ldd	r31, Y+8	; 0x08
    1e64:	80 85       	ldd	r24, Z+8	; 0x08
    1e66:	88 23       	and	r24, r24
    1e68:	f1 f0       	breq	.+60     	; 0x1ea6 <xQueueGenericReceive+0xc2>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    1e6a:	8f 81       	ldd	r24, Y+7	; 0x07
    1e6c:	98 85       	ldd	r25, Y+8	; 0x08
    1e6e:	08 96       	adiw	r24, 0x08	; 8
    1e70:	0e 94 85 16 	call	0x2d0a	; 0x2d0a <xTaskRemoveFromEventList>
    1e74:	81 30       	cpi	r24, 0x01	; 1
    1e76:	b9 f4       	brne	.+46     	; 0x1ea6 <xQueueGenericReceive+0xc2>
						{
							portYIELD_WITHIN_API();
    1e78:	0e 94 e1 0b 	call	0x17c2	; 0x17c2 <vPortYield>
    1e7c:	14 c0       	rjmp	.+40     	; 0x1ea6 <xQueueGenericReceive+0xc2>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
    1e7e:	ef 81       	ldd	r30, Y+7	; 0x07
    1e80:	f8 85       	ldd	r31, Y+8	; 0x08
    1e82:	89 81       	ldd	r24, Y+1	; 0x01
    1e84:	9a 81       	ldd	r25, Y+2	; 0x02
    1e86:	97 83       	std	Z+7, r25	; 0x07
    1e88:	86 83       	std	Z+6, r24	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1e8a:	ef 81       	ldd	r30, Y+7	; 0x07
    1e8c:	f8 85       	ldd	r31, Y+8	; 0x08
    1e8e:	81 89       	ldd	r24, Z+17	; 0x11
    1e90:	88 23       	and	r24, r24
    1e92:	49 f0       	breq	.+18     	; 0x1ea6 <xQueueGenericReceive+0xc2>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1e94:	8f 81       	ldd	r24, Y+7	; 0x07
    1e96:	98 85       	ldd	r25, Y+8	; 0x08
    1e98:	41 96       	adiw	r24, 0x11	; 17
    1e9a:	0e 94 85 16 	call	0x2d0a	; 0x2d0a <xTaskRemoveFromEventList>
    1e9e:	88 23       	and	r24, r24
    1ea0:	11 f0       	breq	.+4      	; 0x1ea6 <xQueueGenericReceive+0xc2>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
    1ea2:	0e 94 e1 0b 	call	0x17c2	; 0x17c2 <vPortYield>
						}
					}

				}

				taskEXIT_CRITICAL();
    1ea6:	0f 90       	pop	r0
    1ea8:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1eaa:	81 e0       	ldi	r24, 0x01	; 1
    1eac:	8e 87       	std	Y+14, r24	; 0x0e
    1eae:	6d c0       	rjmp	.+218    	; 0x1f8a <xQueueGenericReceive+0x1a6>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    1eb0:	8b 85       	ldd	r24, Y+11	; 0x0b
    1eb2:	9c 85       	ldd	r25, Y+12	; 0x0c
    1eb4:	00 97       	sbiw	r24, 0x00	; 0
    1eb6:	21 f4       	brne	.+8      	; 0x1ec0 <xQueueGenericReceive+0xdc>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1eb8:	0f 90       	pop	r0
    1eba:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    1ebc:	1e 86       	std	Y+14, r1	; 0x0e
    1ebe:	65 c0       	rjmp	.+202    	; 0x1f8a <xQueueGenericReceive+0x1a6>
				}
				else if( xEntryTimeSet == pdFALSE )
    1ec0:	8b 81       	ldd	r24, Y+3	; 0x03
    1ec2:	88 23       	and	r24, r24
    1ec4:	31 f4       	brne	.+12     	; 0x1ed2 <xQueueGenericReceive+0xee>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1ec6:	ce 01       	movw	r24, r28
    1ec8:	04 96       	adiw	r24, 0x04	; 4
    1eca:	0e 94 ed 16 	call	0x2dda	; 0x2dda <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1ece:	81 e0       	ldi	r24, 0x01	; 1
    1ed0:	8b 83       	std	Y+3, r24	; 0x03
				}
			}
		}
		taskEXIT_CRITICAL();
    1ed2:	0f 90       	pop	r0
    1ed4:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1ed6:	0e 94 49 14 	call	0x2892	; 0x2892 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1eda:	0f b6       	in	r0, 0x3f	; 63
    1edc:	f8 94       	cli
    1ede:	0f 92       	push	r0
    1ee0:	ef 81       	ldd	r30, Y+7	; 0x07
    1ee2:	f8 85       	ldd	r31, Y+8	; 0x08
    1ee4:	85 8d       	ldd	r24, Z+29	; 0x1d
    1ee6:	8f 3f       	cpi	r24, 0xFF	; 255
    1ee8:	19 f4       	brne	.+6      	; 0x1ef0 <xQueueGenericReceive+0x10c>
    1eea:	ef 81       	ldd	r30, Y+7	; 0x07
    1eec:	f8 85       	ldd	r31, Y+8	; 0x08
    1eee:	15 8e       	std	Z+29, r1	; 0x1d
    1ef0:	ef 81       	ldd	r30, Y+7	; 0x07
    1ef2:	f8 85       	ldd	r31, Y+8	; 0x08
    1ef4:	86 8d       	ldd	r24, Z+30	; 0x1e
    1ef6:	8f 3f       	cpi	r24, 0xFF	; 255
    1ef8:	19 f4       	brne	.+6      	; 0x1f00 <xQueueGenericReceive+0x11c>
    1efa:	ef 81       	ldd	r30, Y+7	; 0x07
    1efc:	f8 85       	ldd	r31, Y+8	; 0x08
    1efe:	16 8e       	std	Z+30, r1	; 0x1e
    1f00:	0f 90       	pop	r0
    1f02:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1f04:	ce 01       	movw	r24, r28
    1f06:	04 96       	adiw	r24, 0x04	; 4
    1f08:	9e 01       	movw	r18, r28
    1f0a:	25 5f       	subi	r18, 0xF5	; 245
    1f0c:	3f 4f       	sbci	r19, 0xFF	; 255
    1f0e:	b9 01       	movw	r22, r18
    1f10:	0e 94 06 17 	call	0x2e0c	; 0x2e0c <xTaskCheckForTimeOut>
    1f14:	88 23       	and	r24, r24
    1f16:	91 f5       	brne	.+100    	; 0x1f7c <xQueueGenericReceive+0x198>
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1f18:	8f 81       	ldd	r24, Y+7	; 0x07
    1f1a:	98 85       	ldd	r25, Y+8	; 0x08
    1f1c:	0e 94 a1 11 	call	0x2342	; 0x2342 <prvIsQueueEmpty>
    1f20:	88 23       	and	r24, r24
    1f22:	29 f1       	breq	.+74     	; 0x1f6e <xQueueGenericReceive+0x18a>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    1f24:	ef 81       	ldd	r30, Y+7	; 0x07
    1f26:	f8 85       	ldd	r31, Y+8	; 0x08
    1f28:	80 81       	ld	r24, Z
    1f2a:	91 81       	ldd	r25, Z+1	; 0x01
    1f2c:	00 97       	sbiw	r24, 0x00	; 0
    1f2e:	59 f4       	brne	.+22     	; 0x1f46 <xQueueGenericReceive+0x162>
					{
						portENTER_CRITICAL();
    1f30:	0f b6       	in	r0, 0x3f	; 63
    1f32:	f8 94       	cli
    1f34:	0f 92       	push	r0
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
    1f36:	ef 81       	ldd	r30, Y+7	; 0x07
    1f38:	f8 85       	ldd	r31, Y+8	; 0x08
    1f3a:	82 81       	ldd	r24, Z+2	; 0x02
    1f3c:	93 81       	ldd	r25, Z+3	; 0x03
    1f3e:	0e 94 0e 19 	call	0x321c	; 0x321c <vTaskPriorityInherit>
						}
						portEXIT_CRITICAL();
    1f42:	0f 90       	pop	r0
    1f44:	0f be       	out	0x3f, r0	; 63
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1f46:	8f 81       	ldd	r24, Y+7	; 0x07
    1f48:	98 85       	ldd	r25, Y+8	; 0x08
    1f4a:	41 96       	adiw	r24, 0x11	; 17
    1f4c:	2b 85       	ldd	r18, Y+11	; 0x0b
    1f4e:	3c 85       	ldd	r19, Y+12	; 0x0c
    1f50:	b9 01       	movw	r22, r18
    1f52:	0e 94 4f 16 	call	0x2c9e	; 0x2c9e <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    1f56:	8f 81       	ldd	r24, Y+7	; 0x07
    1f58:	98 85       	ldd	r25, Y+8	; 0x08
    1f5a:	0e 94 4d 11 	call	0x229a	; 0x229a <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    1f5e:	0e 94 55 14 	call	0x28aa	; 0x28aa <xTaskResumeAll>
    1f62:	88 23       	and	r24, r24
    1f64:	09 f0       	breq	.+2      	; 0x1f68 <xQueueGenericReceive+0x184>
    1f66:	50 cf       	rjmp	.-352    	; 0x1e08 <xQueueGenericReceive+0x24>
				{
					portYIELD_WITHIN_API();
    1f68:	0e 94 e1 0b 	call	0x17c2	; 0x17c2 <vPortYield>
    1f6c:	4d cf       	rjmp	.-358    	; 0x1e08 <xQueueGenericReceive+0x24>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1f6e:	8f 81       	ldd	r24, Y+7	; 0x07
    1f70:	98 85       	ldd	r25, Y+8	; 0x08
    1f72:	0e 94 4d 11 	call	0x229a	; 0x229a <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1f76:	0e 94 55 14 	call	0x28aa	; 0x28aa <xTaskResumeAll>
    1f7a:	46 cf       	rjmp	.-372    	; 0x1e08 <xQueueGenericReceive+0x24>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    1f7c:	8f 81       	ldd	r24, Y+7	; 0x07
    1f7e:	98 85       	ldd	r25, Y+8	; 0x08
    1f80:	0e 94 4d 11 	call	0x229a	; 0x229a <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1f84:	0e 94 55 14 	call	0x28aa	; 0x28aa <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    1f88:	1e 86       	std	Y+14, r1	; 0x0e
    1f8a:	8e 85       	ldd	r24, Y+14	; 0x0e
		}
	}
}
    1f8c:	2e 96       	adiw	r28, 0x0e	; 14
    1f8e:	0f b6       	in	r0, 0x3f	; 63
    1f90:	f8 94       	cli
    1f92:	de bf       	out	0x3e, r29	; 62
    1f94:	0f be       	out	0x3f, r0	; 63
    1f96:	cd bf       	out	0x3d, r28	; 61
    1f98:	cf 91       	pop	r28
    1f9a:	df 91       	pop	r29
    1f9c:	08 95       	ret

00001f9e <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
    1f9e:	df 93       	push	r29
    1fa0:	cf 93       	push	r28
    1fa2:	cd b7       	in	r28, 0x3d	; 61
    1fa4:	de b7       	in	r29, 0x3e	; 62
    1fa6:	28 97       	sbiw	r28, 0x08	; 8
    1fa8:	0f b6       	in	r0, 0x3f	; 63
    1faa:	f8 94       	cli
    1fac:	de bf       	out	0x3e, r29	; 62
    1fae:	0f be       	out	0x3f, r0	; 63
    1fb0:	cd bf       	out	0x3d, r28	; 61
    1fb2:	9c 83       	std	Y+4, r25	; 0x04
    1fb4:	8b 83       	std	Y+3, r24	; 0x03
    1fb6:	7e 83       	std	Y+6, r23	; 0x06
    1fb8:	6d 83       	std	Y+5, r22	; 0x05
    1fba:	58 87       	std	Y+8, r21	; 0x08
    1fbc:	4f 83       	std	Y+7, r20	; 0x07

	configASSERT( pxQueue );
	configASSERT( pxTaskWoken );
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    1fbe:	19 82       	std	Y+1, r1	; 0x01
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    1fc0:	eb 81       	ldd	r30, Y+3	; 0x03
    1fc2:	fc 81       	ldd	r31, Y+4	; 0x04
    1fc4:	82 8d       	ldd	r24, Z+26	; 0x1a
    1fc6:	88 23       	and	r24, r24
    1fc8:	71 f1       	breq	.+92     	; 0x2026 <xQueueReceiveFromISR+0x88>
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    1fca:	8b 81       	ldd	r24, Y+3	; 0x03
    1fcc:	9c 81       	ldd	r25, Y+4	; 0x04
    1fce:	2d 81       	ldd	r18, Y+5	; 0x05
    1fd0:	3e 81       	ldd	r19, Y+6	; 0x06
    1fd2:	b9 01       	movw	r22, r18
    1fd4:	0e 94 05 11 	call	0x220a	; 0x220a <prvCopyDataFromQueue>
			--( pxQueue->uxMessagesWaiting );
    1fd8:	eb 81       	ldd	r30, Y+3	; 0x03
    1fda:	fc 81       	ldd	r31, Y+4	; 0x04
    1fdc:	82 8d       	ldd	r24, Z+26	; 0x1a
    1fde:	81 50       	subi	r24, 0x01	; 1
    1fe0:	eb 81       	ldd	r30, Y+3	; 0x03
    1fe2:	fc 81       	ldd	r31, Y+4	; 0x04
    1fe4:	82 8f       	std	Z+26, r24	; 0x1a

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
    1fe6:	eb 81       	ldd	r30, Y+3	; 0x03
    1fe8:	fc 81       	ldd	r31, Y+4	; 0x04
    1fea:	85 8d       	ldd	r24, Z+29	; 0x1d
    1fec:	8f 3f       	cpi	r24, 0xFF	; 255
    1fee:	89 f4       	brne	.+34     	; 0x2012 <xQueueReceiveFromISR+0x74>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1ff0:	eb 81       	ldd	r30, Y+3	; 0x03
    1ff2:	fc 81       	ldd	r31, Y+4	; 0x04
    1ff4:	80 85       	ldd	r24, Z+8	; 0x08
    1ff6:	88 23       	and	r24, r24
    1ff8:	99 f0       	breq	.+38     	; 0x2020 <xQueueReceiveFromISR+0x82>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1ffa:	8b 81       	ldd	r24, Y+3	; 0x03
    1ffc:	9c 81       	ldd	r25, Y+4	; 0x04
    1ffe:	08 96       	adiw	r24, 0x08	; 8
    2000:	0e 94 85 16 	call	0x2d0a	; 0x2d0a <xTaskRemoveFromEventList>
    2004:	88 23       	and	r24, r24
    2006:	61 f0       	breq	.+24     	; 0x2020 <xQueueReceiveFromISR+0x82>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
    2008:	ef 81       	ldd	r30, Y+7	; 0x07
    200a:	f8 85       	ldd	r31, Y+8	; 0x08
    200c:	81 e0       	ldi	r24, 0x01	; 1
    200e:	80 83       	st	Z, r24
    2010:	07 c0       	rjmp	.+14     	; 0x2020 <xQueueReceiveFromISR+0x82>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    2012:	eb 81       	ldd	r30, Y+3	; 0x03
    2014:	fc 81       	ldd	r31, Y+4	; 0x04
    2016:	85 8d       	ldd	r24, Z+29	; 0x1d
    2018:	8f 5f       	subi	r24, 0xFF	; 255
    201a:	eb 81       	ldd	r30, Y+3	; 0x03
    201c:	fc 81       	ldd	r31, Y+4	; 0x04
    201e:	85 8f       	std	Z+29, r24	; 0x1d
			}

			xReturn = pdPASS;
    2020:	81 e0       	ldi	r24, 0x01	; 1
    2022:	8a 83       	std	Y+2, r24	; 0x02
    2024:	01 c0       	rjmp	.+2      	; 0x2028 <xQueueReceiveFromISR+0x8a>
		}
		else
		{
			xReturn = pdFAIL;
    2026:	1a 82       	std	Y+2, r1	; 0x02
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    2028:	8a 81       	ldd	r24, Y+2	; 0x02
}
    202a:	28 96       	adiw	r28, 0x08	; 8
    202c:	0f b6       	in	r0, 0x3f	; 63
    202e:	f8 94       	cli
    2030:	de bf       	out	0x3e, r29	; 62
    2032:	0f be       	out	0x3f, r0	; 63
    2034:	cd bf       	out	0x3d, r28	; 61
    2036:	cf 91       	pop	r28
    2038:	df 91       	pop	r29
    203a:	08 95       	ret

0000203c <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaiting( const xQueueHandle pxQueue )
{
    203c:	df 93       	push	r29
    203e:	cf 93       	push	r28
    2040:	00 d0       	rcall	.+0      	; 0x2042 <uxQueueMessagesWaiting+0x6>
    2042:	0f 92       	push	r0
    2044:	cd b7       	in	r28, 0x3d	; 61
    2046:	de b7       	in	r29, 0x3e	; 62
    2048:	9b 83       	std	Y+3, r25	; 0x03
    204a:	8a 83       	std	Y+2, r24	; 0x02
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    204c:	0f b6       	in	r0, 0x3f	; 63
    204e:	f8 94       	cli
    2050:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
    2052:	ea 81       	ldd	r30, Y+2	; 0x02
    2054:	fb 81       	ldd	r31, Y+3	; 0x03
    2056:	82 8d       	ldd	r24, Z+26	; 0x1a
    2058:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    205a:	0f 90       	pop	r0
    205c:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    205e:	89 81       	ldd	r24, Y+1	; 0x01
}
    2060:	0f 90       	pop	r0
    2062:	0f 90       	pop	r0
    2064:	0f 90       	pop	r0
    2066:	cf 91       	pop	r28
    2068:	df 91       	pop	r29
    206a:	08 95       	ret

0000206c <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaitingFromISR( const xQueueHandle pxQueue )
{
    206c:	df 93       	push	r29
    206e:	cf 93       	push	r28
    2070:	00 d0       	rcall	.+0      	; 0x2072 <uxQueueMessagesWaitingFromISR+0x6>
    2072:	0f 92       	push	r0
    2074:	cd b7       	in	r28, 0x3d	; 61
    2076:	de b7       	in	r29, 0x3e	; 62
    2078:	9b 83       	std	Y+3, r25	; 0x03
    207a:	8a 83       	std	Y+2, r24	; 0x02
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	uxReturn = pxQueue->uxMessagesWaiting;
    207c:	ea 81       	ldd	r30, Y+2	; 0x02
    207e:	fb 81       	ldd	r31, Y+3	; 0x03
    2080:	82 8d       	ldd	r24, Z+26	; 0x1a
    2082:	89 83       	std	Y+1, r24	; 0x01

	return uxReturn;
    2084:	89 81       	ldd	r24, Y+1	; 0x01
}
    2086:	0f 90       	pop	r0
    2088:	0f 90       	pop	r0
    208a:	0f 90       	pop	r0
    208c:	cf 91       	pop	r28
    208e:	df 91       	pop	r29
    2090:	08 95       	ret

00002092 <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( xQueueHandle pxQueue )
{
    2092:	df 93       	push	r29
    2094:	cf 93       	push	r28
    2096:	00 d0       	rcall	.+0      	; 0x2098 <vQueueDelete+0x6>
    2098:	cd b7       	in	r28, 0x3d	; 61
    209a:	de b7       	in	r29, 0x3e	; 62
    209c:	9a 83       	std	Y+2, r25	; 0x02
    209e:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxQueue );

	traceQUEUE_DELETE( pxQueue );
	vQueueUnregisterQueue( pxQueue );
	vPortFree( pxQueue->pcHead );
    20a0:	e9 81       	ldd	r30, Y+1	; 0x01
    20a2:	fa 81       	ldd	r31, Y+2	; 0x02
    20a4:	80 81       	ld	r24, Z
    20a6:	91 81       	ldd	r25, Z+1	; 0x01
    20a8:	0e 94 c1 08 	call	0x1182	; 0x1182 <vPortFree>
	vPortFree( pxQueue );
    20ac:	89 81       	ldd	r24, Y+1	; 0x01
    20ae:	9a 81       	ldd	r25, Y+2	; 0x02
    20b0:	0e 94 c1 08 	call	0x1182	; 0x1182 <vPortFree>
}
    20b4:	0f 90       	pop	r0
    20b6:	0f 90       	pop	r0
    20b8:	cf 91       	pop	r28
    20ba:	df 91       	pop	r29
    20bc:	08 95       	ret

000020be <prvCopyDataToQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
    20be:	df 93       	push	r29
    20c0:	cf 93       	push	r28
    20c2:	00 d0       	rcall	.+0      	; 0x20c4 <prvCopyDataToQueue+0x6>
    20c4:	00 d0       	rcall	.+0      	; 0x20c6 <prvCopyDataToQueue+0x8>
    20c6:	0f 92       	push	r0
    20c8:	cd b7       	in	r28, 0x3d	; 61
    20ca:	de b7       	in	r29, 0x3e	; 62
    20cc:	9a 83       	std	Y+2, r25	; 0x02
    20ce:	89 83       	std	Y+1, r24	; 0x01
    20d0:	7c 83       	std	Y+4, r23	; 0x04
    20d2:	6b 83       	std	Y+3, r22	; 0x03
    20d4:	4d 83       	std	Y+5, r20	; 0x05
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
    20d6:	e9 81       	ldd	r30, Y+1	; 0x01
    20d8:	fa 81       	ldd	r31, Y+2	; 0x02
    20da:	84 8d       	ldd	r24, Z+28	; 0x1c
    20dc:	88 23       	and	r24, r24
    20de:	91 f4       	brne	.+36     	; 0x2104 <prvCopyDataToQueue+0x46>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    20e0:	e9 81       	ldd	r30, Y+1	; 0x01
    20e2:	fa 81       	ldd	r31, Y+2	; 0x02
    20e4:	80 81       	ld	r24, Z
    20e6:	91 81       	ldd	r25, Z+1	; 0x01
    20e8:	00 97       	sbiw	r24, 0x00	; 0
    20ea:	09 f0       	breq	.+2      	; 0x20ee <prvCopyDataToQueue+0x30>
    20ec:	7f c0       	rjmp	.+254    	; 0x21ec <prvCopyDataToQueue+0x12e>
			{
				/* The mutex is no longer being held. */
				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
    20ee:	e9 81       	ldd	r30, Y+1	; 0x01
    20f0:	fa 81       	ldd	r31, Y+2	; 0x02
    20f2:	82 81       	ldd	r24, Z+2	; 0x02
    20f4:	93 81       	ldd	r25, Z+3	; 0x03
    20f6:	0e 94 8e 19 	call	0x331c	; 0x331c <vTaskPriorityDisinherit>
				pxQueue->pxMutexHolder = NULL;
    20fa:	e9 81       	ldd	r30, Y+1	; 0x01
    20fc:	fa 81       	ldd	r31, Y+2	; 0x02
    20fe:	13 82       	std	Z+3, r1	; 0x03
    2100:	12 82       	std	Z+2, r1	; 0x02
    2102:	74 c0       	rjmp	.+232    	; 0x21ec <prvCopyDataToQueue+0x12e>
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
    2104:	8d 81       	ldd	r24, Y+5	; 0x05
    2106:	88 23       	and	r24, r24
    2108:	99 f5       	brne	.+102    	; 0x2170 <prvCopyDataToQueue+0xb2>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    210a:	e9 81       	ldd	r30, Y+1	; 0x01
    210c:	fa 81       	ldd	r31, Y+2	; 0x02
    210e:	64 81       	ldd	r22, Z+4	; 0x04
    2110:	75 81       	ldd	r23, Z+5	; 0x05
    2112:	e9 81       	ldd	r30, Y+1	; 0x01
    2114:	fa 81       	ldd	r31, Y+2	; 0x02
    2116:	84 8d       	ldd	r24, Z+28	; 0x1c
    2118:	48 2f       	mov	r20, r24
    211a:	50 e0       	ldi	r21, 0x00	; 0
    211c:	2b 81       	ldd	r18, Y+3	; 0x03
    211e:	3c 81       	ldd	r19, Y+4	; 0x04
    2120:	cb 01       	movw	r24, r22
    2122:	b9 01       	movw	r22, r18
    2124:	0e 94 27 2c 	call	0x584e	; 0x584e <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    2128:	e9 81       	ldd	r30, Y+1	; 0x01
    212a:	fa 81       	ldd	r31, Y+2	; 0x02
    212c:	24 81       	ldd	r18, Z+4	; 0x04
    212e:	35 81       	ldd	r19, Z+5	; 0x05
    2130:	e9 81       	ldd	r30, Y+1	; 0x01
    2132:	fa 81       	ldd	r31, Y+2	; 0x02
    2134:	84 8d       	ldd	r24, Z+28	; 0x1c
    2136:	88 2f       	mov	r24, r24
    2138:	90 e0       	ldi	r25, 0x00	; 0
    213a:	82 0f       	add	r24, r18
    213c:	93 1f       	adc	r25, r19
    213e:	e9 81       	ldd	r30, Y+1	; 0x01
    2140:	fa 81       	ldd	r31, Y+2	; 0x02
    2142:	95 83       	std	Z+5, r25	; 0x05
    2144:	84 83       	std	Z+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
    2146:	e9 81       	ldd	r30, Y+1	; 0x01
    2148:	fa 81       	ldd	r31, Y+2	; 0x02
    214a:	24 81       	ldd	r18, Z+4	; 0x04
    214c:	35 81       	ldd	r19, Z+5	; 0x05
    214e:	e9 81       	ldd	r30, Y+1	; 0x01
    2150:	fa 81       	ldd	r31, Y+2	; 0x02
    2152:	82 81       	ldd	r24, Z+2	; 0x02
    2154:	93 81       	ldd	r25, Z+3	; 0x03
    2156:	28 17       	cp	r18, r24
    2158:	39 07       	cpc	r19, r25
    215a:	08 f4       	brcc	.+2      	; 0x215e <prvCopyDataToQueue+0xa0>
    215c:	47 c0       	rjmp	.+142    	; 0x21ec <prvCopyDataToQueue+0x12e>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    215e:	e9 81       	ldd	r30, Y+1	; 0x01
    2160:	fa 81       	ldd	r31, Y+2	; 0x02
    2162:	80 81       	ld	r24, Z
    2164:	91 81       	ldd	r25, Z+1	; 0x01
    2166:	e9 81       	ldd	r30, Y+1	; 0x01
    2168:	fa 81       	ldd	r31, Y+2	; 0x02
    216a:	95 83       	std	Z+5, r25	; 0x05
    216c:	84 83       	std	Z+4, r24	; 0x04
    216e:	3e c0       	rjmp	.+124    	; 0x21ec <prvCopyDataToQueue+0x12e>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    2170:	e9 81       	ldd	r30, Y+1	; 0x01
    2172:	fa 81       	ldd	r31, Y+2	; 0x02
    2174:	66 81       	ldd	r22, Z+6	; 0x06
    2176:	77 81       	ldd	r23, Z+7	; 0x07
    2178:	e9 81       	ldd	r30, Y+1	; 0x01
    217a:	fa 81       	ldd	r31, Y+2	; 0x02
    217c:	84 8d       	ldd	r24, Z+28	; 0x1c
    217e:	48 2f       	mov	r20, r24
    2180:	50 e0       	ldi	r21, 0x00	; 0
    2182:	2b 81       	ldd	r18, Y+3	; 0x03
    2184:	3c 81       	ldd	r19, Y+4	; 0x04
    2186:	cb 01       	movw	r24, r22
    2188:	b9 01       	movw	r22, r18
    218a:	0e 94 27 2c 	call	0x584e	; 0x584e <memcpy>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
    218e:	e9 81       	ldd	r30, Y+1	; 0x01
    2190:	fa 81       	ldd	r31, Y+2	; 0x02
    2192:	26 81       	ldd	r18, Z+6	; 0x06
    2194:	37 81       	ldd	r19, Z+7	; 0x07
    2196:	e9 81       	ldd	r30, Y+1	; 0x01
    2198:	fa 81       	ldd	r31, Y+2	; 0x02
    219a:	84 8d       	ldd	r24, Z+28	; 0x1c
    219c:	88 2f       	mov	r24, r24
    219e:	90 e0       	ldi	r25, 0x00	; 0
    21a0:	90 95       	com	r25
    21a2:	81 95       	neg	r24
    21a4:	9f 4f       	sbci	r25, 0xFF	; 255
    21a6:	82 0f       	add	r24, r18
    21a8:	93 1f       	adc	r25, r19
    21aa:	e9 81       	ldd	r30, Y+1	; 0x01
    21ac:	fa 81       	ldd	r31, Y+2	; 0x02
    21ae:	97 83       	std	Z+7, r25	; 0x07
    21b0:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
    21b2:	e9 81       	ldd	r30, Y+1	; 0x01
    21b4:	fa 81       	ldd	r31, Y+2	; 0x02
    21b6:	26 81       	ldd	r18, Z+6	; 0x06
    21b8:	37 81       	ldd	r19, Z+7	; 0x07
    21ba:	e9 81       	ldd	r30, Y+1	; 0x01
    21bc:	fa 81       	ldd	r31, Y+2	; 0x02
    21be:	80 81       	ld	r24, Z
    21c0:	91 81       	ldd	r25, Z+1	; 0x01
    21c2:	28 17       	cp	r18, r24
    21c4:	39 07       	cpc	r19, r25
    21c6:	90 f4       	brcc	.+36     	; 0x21ec <prvCopyDataToQueue+0x12e>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    21c8:	e9 81       	ldd	r30, Y+1	; 0x01
    21ca:	fa 81       	ldd	r31, Y+2	; 0x02
    21cc:	22 81       	ldd	r18, Z+2	; 0x02
    21ce:	33 81       	ldd	r19, Z+3	; 0x03
    21d0:	e9 81       	ldd	r30, Y+1	; 0x01
    21d2:	fa 81       	ldd	r31, Y+2	; 0x02
    21d4:	84 8d       	ldd	r24, Z+28	; 0x1c
    21d6:	88 2f       	mov	r24, r24
    21d8:	90 e0       	ldi	r25, 0x00	; 0
    21da:	90 95       	com	r25
    21dc:	81 95       	neg	r24
    21de:	9f 4f       	sbci	r25, 0xFF	; 255
    21e0:	82 0f       	add	r24, r18
    21e2:	93 1f       	adc	r25, r19
    21e4:	e9 81       	ldd	r30, Y+1	; 0x01
    21e6:	fa 81       	ldd	r31, Y+2	; 0x02
    21e8:	97 83       	std	Z+7, r25	; 0x07
    21ea:	86 83       	std	Z+6, r24	; 0x06
		}
	}

	++( pxQueue->uxMessagesWaiting );
    21ec:	e9 81       	ldd	r30, Y+1	; 0x01
    21ee:	fa 81       	ldd	r31, Y+2	; 0x02
    21f0:	82 8d       	ldd	r24, Z+26	; 0x1a
    21f2:	8f 5f       	subi	r24, 0xFF	; 255
    21f4:	e9 81       	ldd	r30, Y+1	; 0x01
    21f6:	fa 81       	ldd	r31, Y+2	; 0x02
    21f8:	82 8f       	std	Z+26, r24	; 0x1a
}
    21fa:	0f 90       	pop	r0
    21fc:	0f 90       	pop	r0
    21fe:	0f 90       	pop	r0
    2200:	0f 90       	pop	r0
    2202:	0f 90       	pop	r0
    2204:	cf 91       	pop	r28
    2206:	df 91       	pop	r29
    2208:	08 95       	ret

0000220a <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
    220a:	df 93       	push	r29
    220c:	cf 93       	push	r28
    220e:	00 d0       	rcall	.+0      	; 0x2210 <prvCopyDataFromQueue+0x6>
    2210:	00 d0       	rcall	.+0      	; 0x2212 <prvCopyDataFromQueue+0x8>
    2212:	cd b7       	in	r28, 0x3d	; 61
    2214:	de b7       	in	r29, 0x3e	; 62
    2216:	9a 83       	std	Y+2, r25	; 0x02
    2218:	89 83       	std	Y+1, r24	; 0x01
    221a:	7c 83       	std	Y+4, r23	; 0x04
    221c:	6b 83       	std	Y+3, r22	; 0x03
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
    221e:	e9 81       	ldd	r30, Y+1	; 0x01
    2220:	fa 81       	ldd	r31, Y+2	; 0x02
    2222:	80 81       	ld	r24, Z
    2224:	91 81       	ldd	r25, Z+1	; 0x01
    2226:	00 97       	sbiw	r24, 0x00	; 0
    2228:	89 f1       	breq	.+98     	; 0x228c <prvCopyDataFromQueue+0x82>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
    222a:	e9 81       	ldd	r30, Y+1	; 0x01
    222c:	fa 81       	ldd	r31, Y+2	; 0x02
    222e:	26 81       	ldd	r18, Z+6	; 0x06
    2230:	37 81       	ldd	r19, Z+7	; 0x07
    2232:	e9 81       	ldd	r30, Y+1	; 0x01
    2234:	fa 81       	ldd	r31, Y+2	; 0x02
    2236:	84 8d       	ldd	r24, Z+28	; 0x1c
    2238:	88 2f       	mov	r24, r24
    223a:	90 e0       	ldi	r25, 0x00	; 0
    223c:	82 0f       	add	r24, r18
    223e:	93 1f       	adc	r25, r19
    2240:	e9 81       	ldd	r30, Y+1	; 0x01
    2242:	fa 81       	ldd	r31, Y+2	; 0x02
    2244:	97 83       	std	Z+7, r25	; 0x07
    2246:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
    2248:	e9 81       	ldd	r30, Y+1	; 0x01
    224a:	fa 81       	ldd	r31, Y+2	; 0x02
    224c:	26 81       	ldd	r18, Z+6	; 0x06
    224e:	37 81       	ldd	r19, Z+7	; 0x07
    2250:	e9 81       	ldd	r30, Y+1	; 0x01
    2252:	fa 81       	ldd	r31, Y+2	; 0x02
    2254:	82 81       	ldd	r24, Z+2	; 0x02
    2256:	93 81       	ldd	r25, Z+3	; 0x03
    2258:	28 17       	cp	r18, r24
    225a:	39 07       	cpc	r19, r25
    225c:	40 f0       	brcs	.+16     	; 0x226e <prvCopyDataFromQueue+0x64>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
    225e:	e9 81       	ldd	r30, Y+1	; 0x01
    2260:	fa 81       	ldd	r31, Y+2	; 0x02
    2262:	80 81       	ld	r24, Z
    2264:	91 81       	ldd	r25, Z+1	; 0x01
    2266:	e9 81       	ldd	r30, Y+1	; 0x01
    2268:	fa 81       	ldd	r31, Y+2	; 0x02
    226a:	97 83       	std	Z+7, r25	; 0x07
    226c:	86 83       	std	Z+6, r24	; 0x06
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    226e:	e9 81       	ldd	r30, Y+1	; 0x01
    2270:	fa 81       	ldd	r31, Y+2	; 0x02
    2272:	46 81       	ldd	r20, Z+6	; 0x06
    2274:	57 81       	ldd	r21, Z+7	; 0x07
    2276:	e9 81       	ldd	r30, Y+1	; 0x01
    2278:	fa 81       	ldd	r31, Y+2	; 0x02
    227a:	84 8d       	ldd	r24, Z+28	; 0x1c
    227c:	28 2f       	mov	r18, r24
    227e:	30 e0       	ldi	r19, 0x00	; 0
    2280:	8b 81       	ldd	r24, Y+3	; 0x03
    2282:	9c 81       	ldd	r25, Y+4	; 0x04
    2284:	ba 01       	movw	r22, r20
    2286:	a9 01       	movw	r20, r18
    2288:	0e 94 27 2c 	call	0x584e	; 0x584e <memcpy>
	}
}
    228c:	0f 90       	pop	r0
    228e:	0f 90       	pop	r0
    2290:	0f 90       	pop	r0
    2292:	0f 90       	pop	r0
    2294:	cf 91       	pop	r28
    2296:	df 91       	pop	r29
    2298:	08 95       	ret

0000229a <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
    229a:	df 93       	push	r29
    229c:	cf 93       	push	r28
    229e:	00 d0       	rcall	.+0      	; 0x22a0 <prvUnlockQueue+0x6>
    22a0:	cd b7       	in	r28, 0x3d	; 61
    22a2:	de b7       	in	r29, 0x3e	; 62
    22a4:	9a 83       	std	Y+2, r25	; 0x02
    22a6:	89 83       	std	Y+1, r24	; 0x01

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    22a8:	0f b6       	in	r0, 0x3f	; 63
    22aa:	f8 94       	cli
    22ac:	0f 92       	push	r0
    22ae:	15 c0       	rjmp	.+42     	; 0x22da <prvUnlockQueue+0x40>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    22b0:	e9 81       	ldd	r30, Y+1	; 0x01
    22b2:	fa 81       	ldd	r31, Y+2	; 0x02
    22b4:	81 89       	ldd	r24, Z+17	; 0x11
    22b6:	88 23       	and	r24, r24
    22b8:	a9 f0       	breq	.+42     	; 0x22e4 <prvUnlockQueue+0x4a>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    22ba:	89 81       	ldd	r24, Y+1	; 0x01
    22bc:	9a 81       	ldd	r25, Y+2	; 0x02
    22be:	41 96       	adiw	r24, 0x11	; 17
    22c0:	0e 94 85 16 	call	0x2d0a	; 0x2d0a <xTaskRemoveFromEventList>
    22c4:	88 23       	and	r24, r24
    22c6:	11 f0       	breq	.+4      	; 0x22cc <prvUnlockQueue+0x32>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
    22c8:	0e 94 63 17 	call	0x2ec6	; 0x2ec6 <vTaskMissedYield>
				}

				--( pxQueue->xTxLock );
    22cc:	e9 81       	ldd	r30, Y+1	; 0x01
    22ce:	fa 81       	ldd	r31, Y+2	; 0x02
    22d0:	86 8d       	ldd	r24, Z+30	; 0x1e
    22d2:	81 50       	subi	r24, 0x01	; 1
    22d4:	e9 81       	ldd	r30, Y+1	; 0x01
    22d6:	fa 81       	ldd	r31, Y+2	; 0x02
    22d8:	86 8f       	std	Z+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    22da:	e9 81       	ldd	r30, Y+1	; 0x01
    22dc:	fa 81       	ldd	r31, Y+2	; 0x02
    22de:	86 8d       	ldd	r24, Z+30	; 0x1e
    22e0:	18 16       	cp	r1, r24
    22e2:	34 f3       	brlt	.-52     	; 0x22b0 <prvUnlockQueue+0x16>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
    22e4:	e9 81       	ldd	r30, Y+1	; 0x01
    22e6:	fa 81       	ldd	r31, Y+2	; 0x02
    22e8:	8f ef       	ldi	r24, 0xFF	; 255
    22ea:	86 8f       	std	Z+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    22ec:	0f 90       	pop	r0
    22ee:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    22f0:	0f b6       	in	r0, 0x3f	; 63
    22f2:	f8 94       	cli
    22f4:	0f 92       	push	r0
    22f6:	15 c0       	rjmp	.+42     	; 0x2322 <prvUnlockQueue+0x88>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    22f8:	e9 81       	ldd	r30, Y+1	; 0x01
    22fa:	fa 81       	ldd	r31, Y+2	; 0x02
    22fc:	80 85       	ldd	r24, Z+8	; 0x08
    22fe:	88 23       	and	r24, r24
    2300:	a9 f0       	breq	.+42     	; 0x232c <prvUnlockQueue+0x92>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2302:	89 81       	ldd	r24, Y+1	; 0x01
    2304:	9a 81       	ldd	r25, Y+2	; 0x02
    2306:	08 96       	adiw	r24, 0x08	; 8
    2308:	0e 94 85 16 	call	0x2d0a	; 0x2d0a <xTaskRemoveFromEventList>
    230c:	88 23       	and	r24, r24
    230e:	11 f0       	breq	.+4      	; 0x2314 <prvUnlockQueue+0x7a>
				{
					vTaskMissedYield();
    2310:	0e 94 63 17 	call	0x2ec6	; 0x2ec6 <vTaskMissedYield>
				}

				--( pxQueue->xRxLock );
    2314:	e9 81       	ldd	r30, Y+1	; 0x01
    2316:	fa 81       	ldd	r31, Y+2	; 0x02
    2318:	85 8d       	ldd	r24, Z+29	; 0x1d
    231a:	81 50       	subi	r24, 0x01	; 1
    231c:	e9 81       	ldd	r30, Y+1	; 0x01
    231e:	fa 81       	ldd	r31, Y+2	; 0x02
    2320:	85 8f       	std	Z+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    2322:	e9 81       	ldd	r30, Y+1	; 0x01
    2324:	fa 81       	ldd	r31, Y+2	; 0x02
    2326:	85 8d       	ldd	r24, Z+29	; 0x1d
    2328:	18 16       	cp	r1, r24
    232a:	34 f3       	brlt	.-52     	; 0x22f8 <prvUnlockQueue+0x5e>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    232c:	e9 81       	ldd	r30, Y+1	; 0x01
    232e:	fa 81       	ldd	r31, Y+2	; 0x02
    2330:	8f ef       	ldi	r24, 0xFF	; 255
    2332:	85 8f       	std	Z+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    2334:	0f 90       	pop	r0
    2336:	0f be       	out	0x3f, r0	; 63
}
    2338:	0f 90       	pop	r0
    233a:	0f 90       	pop	r0
    233c:	cf 91       	pop	r28
    233e:	df 91       	pop	r29
    2340:	08 95       	ret

00002342 <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
    2342:	df 93       	push	r29
    2344:	cf 93       	push	r28
    2346:	00 d0       	rcall	.+0      	; 0x2348 <prvIsQueueEmpty+0x6>
    2348:	0f 92       	push	r0
    234a:	cd b7       	in	r28, 0x3d	; 61
    234c:	de b7       	in	r29, 0x3e	; 62
    234e:	9b 83       	std	Y+3, r25	; 0x03
    2350:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    2352:	0f b6       	in	r0, 0x3f	; 63
    2354:	f8 94       	cli
    2356:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    2358:	ea 81       	ldd	r30, Y+2	; 0x02
    235a:	fb 81       	ldd	r31, Y+3	; 0x03
    235c:	82 8d       	ldd	r24, Z+26	; 0x1a
    235e:	19 82       	std	Y+1, r1	; 0x01
    2360:	88 23       	and	r24, r24
    2362:	11 f4       	brne	.+4      	; 0x2368 <prvIsQueueEmpty+0x26>
    2364:	81 e0       	ldi	r24, 0x01	; 1
    2366:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    2368:	0f 90       	pop	r0
    236a:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    236c:	89 81       	ldd	r24, Y+1	; 0x01
}
    236e:	0f 90       	pop	r0
    2370:	0f 90       	pop	r0
    2372:	0f 90       	pop	r0
    2374:	cf 91       	pop	r28
    2376:	df 91       	pop	r29
    2378:	08 95       	ret

0000237a <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle pxQueue )
{
    237a:	df 93       	push	r29
    237c:	cf 93       	push	r28
    237e:	00 d0       	rcall	.+0      	; 0x2380 <xQueueIsQueueEmptyFromISR+0x6>
    2380:	0f 92       	push	r0
    2382:	cd b7       	in	r28, 0x3d	; 61
    2384:	de b7       	in	r29, 0x3e	; 62
    2386:	9b 83       	std	Y+3, r25	; 0x03
    2388:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    238a:	ea 81       	ldd	r30, Y+2	; 0x02
    238c:	fb 81       	ldd	r31, Y+3	; 0x03
    238e:	82 8d       	ldd	r24, Z+26	; 0x1a
    2390:	19 82       	std	Y+1, r1	; 0x01
    2392:	88 23       	and	r24, r24
    2394:	11 f4       	brne	.+4      	; 0x239a <xQueueIsQueueEmptyFromISR+0x20>
    2396:	81 e0       	ldi	r24, 0x01	; 1
    2398:	89 83       	std	Y+1, r24	; 0x01

	return xReturn;
    239a:	89 81       	ldd	r24, Y+1	; 0x01
}
    239c:	0f 90       	pop	r0
    239e:	0f 90       	pop	r0
    23a0:	0f 90       	pop	r0
    23a2:	cf 91       	pop	r28
    23a4:	df 91       	pop	r29
    23a6:	08 95       	ret

000023a8 <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
    23a8:	df 93       	push	r29
    23aa:	cf 93       	push	r28
    23ac:	00 d0       	rcall	.+0      	; 0x23ae <prvIsQueueFull+0x6>
    23ae:	0f 92       	push	r0
    23b0:	cd b7       	in	r28, 0x3d	; 61
    23b2:	de b7       	in	r29, 0x3e	; 62
    23b4:	9b 83       	std	Y+3, r25	; 0x03
    23b6:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    23b8:	0f b6       	in	r0, 0x3f	; 63
    23ba:	f8 94       	cli
    23bc:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    23be:	ea 81       	ldd	r30, Y+2	; 0x02
    23c0:	fb 81       	ldd	r31, Y+3	; 0x03
    23c2:	92 8d       	ldd	r25, Z+26	; 0x1a
    23c4:	ea 81       	ldd	r30, Y+2	; 0x02
    23c6:	fb 81       	ldd	r31, Y+3	; 0x03
    23c8:	83 8d       	ldd	r24, Z+27	; 0x1b
    23ca:	19 82       	std	Y+1, r1	; 0x01
    23cc:	98 17       	cp	r25, r24
    23ce:	11 f4       	brne	.+4      	; 0x23d4 <prvIsQueueFull+0x2c>
    23d0:	81 e0       	ldi	r24, 0x01	; 1
    23d2:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    23d4:	0f 90       	pop	r0
    23d6:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    23d8:	89 81       	ldd	r24, Y+1	; 0x01
}
    23da:	0f 90       	pop	r0
    23dc:	0f 90       	pop	r0
    23de:	0f 90       	pop	r0
    23e0:	cf 91       	pop	r28
    23e2:	df 91       	pop	r29
    23e4:	08 95       	ret

000023e6 <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle pxQueue )
{
    23e6:	df 93       	push	r29
    23e8:	cf 93       	push	r28
    23ea:	00 d0       	rcall	.+0      	; 0x23ec <xQueueIsQueueFullFromISR+0x6>
    23ec:	0f 92       	push	r0
    23ee:	cd b7       	in	r28, 0x3d	; 61
    23f0:	de b7       	in	r29, 0x3e	; 62
    23f2:	9b 83       	std	Y+3, r25	; 0x03
    23f4:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    23f6:	ea 81       	ldd	r30, Y+2	; 0x02
    23f8:	fb 81       	ldd	r31, Y+3	; 0x03
    23fa:	92 8d       	ldd	r25, Z+26	; 0x1a
    23fc:	ea 81       	ldd	r30, Y+2	; 0x02
    23fe:	fb 81       	ldd	r31, Y+3	; 0x03
    2400:	83 8d       	ldd	r24, Z+27	; 0x1b
    2402:	19 82       	std	Y+1, r1	; 0x01
    2404:	98 17       	cp	r25, r24
    2406:	11 f4       	brne	.+4      	; 0x240c <xQueueIsQueueFullFromISR+0x26>
    2408:	81 e0       	ldi	r24, 0x01	; 1
    240a:	89 83       	std	Y+1, r24	; 0x01

	return xReturn;
    240c:	89 81       	ldd	r24, Y+1	; 0x01
}
    240e:	0f 90       	pop	r0
    2410:	0f 90       	pop	r0
    2412:	0f 90       	pop	r0
    2414:	cf 91       	pop	r28
    2416:	df 91       	pop	r29
    2418:	08 95       	ret

0000241a <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
    241a:	af 92       	push	r10
    241c:	bf 92       	push	r11
    241e:	cf 92       	push	r12
    2420:	df 92       	push	r13
    2422:	ef 92       	push	r14
    2424:	ff 92       	push	r15
    2426:	0f 93       	push	r16
    2428:	1f 93       	push	r17
    242a:	df 93       	push	r29
    242c:	cf 93       	push	r28
    242e:	cd b7       	in	r28, 0x3d	; 61
    2430:	de b7       	in	r29, 0x3e	; 62
    2432:	64 97       	sbiw	r28, 0x14	; 20
    2434:	0f b6       	in	r0, 0x3f	; 63
    2436:	f8 94       	cli
    2438:	de bf       	out	0x3e, r29	; 62
    243a:	0f be       	out	0x3f, r0	; 63
    243c:	cd bf       	out	0x3d, r28	; 61
    243e:	9f 83       	std	Y+7, r25	; 0x07
    2440:	8e 83       	std	Y+6, r24	; 0x06
    2442:	79 87       	std	Y+9, r23	; 0x09
    2444:	68 87       	std	Y+8, r22	; 0x08
    2446:	5b 87       	std	Y+11, r21	; 0x0b
    2448:	4a 87       	std	Y+10, r20	; 0x0a
    244a:	3d 87       	std	Y+13, r19	; 0x0d
    244c:	2c 87       	std	Y+12, r18	; 0x0c
    244e:	0e 87       	std	Y+14, r16	; 0x0e
    2450:	f8 8a       	std	Y+16, r15	; 0x10
    2452:	ef 86       	std	Y+15, r14	; 0x0f
    2454:	da 8a       	std	Y+18, r13	; 0x12
    2456:	c9 8a       	std	Y+17, r12	; 0x11
    2458:	bc 8a       	std	Y+20, r11	; 0x14
    245a:	ab 8a       	std	Y+19, r10	; 0x13
	configASSERT( pxTaskCode );
	configASSERT( ( uxPriority < configMAX_PRIORITIES ) );

	/* Allocate the memory required by the TCB and stack for the new task,
	checking that the allocation was successful. */
	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
    245c:	8a 85       	ldd	r24, Y+10	; 0x0a
    245e:	9b 85       	ldd	r25, Y+11	; 0x0b
    2460:	29 89       	ldd	r18, Y+17	; 0x11
    2462:	3a 89       	ldd	r19, Y+18	; 0x12
    2464:	b9 01       	movw	r22, r18
    2466:	0e 94 96 18 	call	0x312c	; 0x312c <prvAllocateTCBAndStack>
    246a:	9c 83       	std	Y+4, r25	; 0x04
    246c:	8b 83       	std	Y+3, r24	; 0x03

	if( pxNewTCB != NULL )
    246e:	8b 81       	ldd	r24, Y+3	; 0x03
    2470:	9c 81       	ldd	r25, Y+4	; 0x04
    2472:	00 97       	sbiw	r24, 0x00	; 0
    2474:	09 f4       	brne	.+2      	; 0x2478 <xTaskGenericCreate+0x5e>
    2476:	99 c0       	rjmp	.+306    	; 0x25aa <xTaskGenericCreate+0x190>
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
    2478:	eb 81       	ldd	r30, Y+3	; 0x03
    247a:	fc 81       	ldd	r31, Y+4	; 0x04
    247c:	27 89       	ldd	r18, Z+23	; 0x17
    247e:	30 8d       	ldd	r19, Z+24	; 0x18
    2480:	8a 85       	ldd	r24, Y+10	; 0x0a
    2482:	9b 85       	ldd	r25, Y+11	; 0x0b
    2484:	01 97       	sbiw	r24, 0x01	; 1
    2486:	82 0f       	add	r24, r18
    2488:	93 1f       	adc	r25, r19
    248a:	9a 83       	std	Y+2, r25	; 0x02
    248c:	89 83       	std	Y+1, r24	; 0x01
			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
		}
		#endif

		/* Setup the newly allocated TCB with the initial state of the task. */
		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
    248e:	8b 81       	ldd	r24, Y+3	; 0x03
    2490:	9c 81       	ldd	r25, Y+4	; 0x04
    2492:	28 85       	ldd	r18, Y+8	; 0x08
    2494:	39 85       	ldd	r19, Y+9	; 0x09
    2496:	eb 89       	ldd	r30, Y+19	; 0x13
    2498:	fc 89       	ldd	r31, Y+20	; 0x14
    249a:	aa 85       	ldd	r26, Y+10	; 0x0a
    249c:	bb 85       	ldd	r27, Y+11	; 0x0b
    249e:	b9 01       	movw	r22, r18
    24a0:	4e 85       	ldd	r20, Y+14	; 0x0e
    24a2:	9f 01       	movw	r18, r30
    24a4:	8d 01       	movw	r16, r26
    24a6:	0e 94 77 17 	call	0x2eee	; 0x2eee <prvInitialiseTCBVariables>
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    24aa:	89 81       	ldd	r24, Y+1	; 0x01
    24ac:	9a 81       	ldd	r25, Y+2	; 0x02
    24ae:	2e 81       	ldd	r18, Y+6	; 0x06
    24b0:	3f 81       	ldd	r19, Y+7	; 0x07
    24b2:	4c 85       	ldd	r20, Y+12	; 0x0c
    24b4:	5d 85       	ldd	r21, Y+13	; 0x0d
    24b6:	b9 01       	movw	r22, r18
    24b8:	0e 94 22 0a 	call	0x1444	; 0x1444 <pxPortInitialiseStack>
    24bc:	eb 81       	ldd	r30, Y+3	; 0x03
    24be:	fc 81       	ldd	r31, Y+4	; 0x04
    24c0:	91 83       	std	Z+1, r25	; 0x01
    24c2:	80 83       	st	Z, r24
		#endif

		/* Check the alignment of the initialised stack. */
		configASSERT( ( ( ( unsigned long ) pxNewTCB->pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );

		if( ( void * ) pxCreatedTask != NULL )
    24c4:	8f 85       	ldd	r24, Y+15	; 0x0f
    24c6:	98 89       	ldd	r25, Y+16	; 0x10
    24c8:	00 97       	sbiw	r24, 0x00	; 0
    24ca:	31 f0       	breq	.+12     	; 0x24d8 <xTaskGenericCreate+0xbe>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
    24cc:	ef 85       	ldd	r30, Y+15	; 0x0f
    24ce:	f8 89       	ldd	r31, Y+16	; 0x10
    24d0:	8b 81       	ldd	r24, Y+3	; 0x03
    24d2:	9c 81       	ldd	r25, Y+4	; 0x04
    24d4:	91 83       	std	Z+1, r25	; 0x01
    24d6:	80 83       	st	Z, r24
		}
		
		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
    24d8:	0f b6       	in	r0, 0x3f	; 63
    24da:	f8 94       	cli
    24dc:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
    24de:	80 91 5b 05 	lds	r24, 0x055B
    24e2:	8f 5f       	subi	r24, 0xFF	; 255
    24e4:	80 93 5b 05 	sts	0x055B, r24
			if( pxCurrentTCB == NULL )
    24e8:	80 91 58 05 	lds	r24, 0x0558
    24ec:	90 91 59 05 	lds	r25, 0x0559
    24f0:	00 97       	sbiw	r24, 0x00	; 0
    24f2:	69 f4       	brne	.+26     	; 0x250e <xTaskGenericCreate+0xf4>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
    24f4:	8b 81       	ldd	r24, Y+3	; 0x03
    24f6:	9c 81       	ldd	r25, Y+4	; 0x04
    24f8:	90 93 59 05 	sts	0x0559, r25
    24fc:	80 93 58 05 	sts	0x0558, r24

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
    2500:	80 91 5b 05 	lds	r24, 0x055B
    2504:	81 30       	cpi	r24, 0x01	; 1
    2506:	a9 f4       	brne	.+42     	; 0x2532 <xTaskGenericCreate+0x118>
				{
					/* This is the first task to be created so do the preliminary
					initialisation required.  We will not recover if this call
					fails, but we will report the failure. */
					prvInitialiseTaskLists();
    2508:	0e 94 d2 17 	call	0x2fa4	; 0x2fa4 <prvInitialiseTaskLists>
    250c:	12 c0       	rjmp	.+36     	; 0x2532 <xTaskGenericCreate+0x118>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
    250e:	80 91 60 05 	lds	r24, 0x0560
    2512:	88 23       	and	r24, r24
    2514:	71 f4       	brne	.+28     	; 0x2532 <xTaskGenericCreate+0x118>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
    2516:	e0 91 58 05 	lds	r30, 0x0558
    251a:	f0 91 59 05 	lds	r31, 0x0559
    251e:	96 89       	ldd	r25, Z+22	; 0x16
    2520:	8e 85       	ldd	r24, Y+14	; 0x0e
    2522:	89 17       	cp	r24, r25
    2524:	30 f0       	brcs	.+12     	; 0x2532 <xTaskGenericCreate+0x118>
					{
						pxCurrentTCB = pxNewTCB;
    2526:	8b 81       	ldd	r24, Y+3	; 0x03
    2528:	9c 81       	ldd	r25, Y+4	; 0x04
    252a:	90 93 59 05 	sts	0x0559, r25
    252e:	80 93 58 05 	sts	0x0558, r24
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
    2532:	eb 81       	ldd	r30, Y+3	; 0x03
    2534:	fc 81       	ldd	r31, Y+4	; 0x04
    2536:	96 89       	ldd	r25, Z+22	; 0x16
    2538:	80 91 5e 05 	lds	r24, 0x055E
    253c:	89 17       	cp	r24, r25
    253e:	28 f4       	brcc	.+10     	; 0x254a <xTaskGenericCreate+0x130>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
    2540:	eb 81       	ldd	r30, Y+3	; 0x03
    2542:	fc 81       	ldd	r31, Y+4	; 0x04
    2544:	86 89       	ldd	r24, Z+22	; 0x16
    2546:	80 93 5e 05 	sts	0x055E, r24
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
    254a:	80 91 65 05 	lds	r24, 0x0565
    254e:	8f 5f       	subi	r24, 0xFF	; 255
    2550:	80 93 65 05 	sts	0x0565, r24

			prvAddTaskToReadyQueue( pxNewTCB );
    2554:	eb 81       	ldd	r30, Y+3	; 0x03
    2556:	fc 81       	ldd	r31, Y+4	; 0x04
    2558:	96 89       	ldd	r25, Z+22	; 0x16
    255a:	80 91 5f 05 	lds	r24, 0x055F
    255e:	89 17       	cp	r24, r25
    2560:	28 f4       	brcc	.+10     	; 0x256c <xTaskGenericCreate+0x152>
    2562:	eb 81       	ldd	r30, Y+3	; 0x03
    2564:	fc 81       	ldd	r31, Y+4	; 0x04
    2566:	86 89       	ldd	r24, Z+22	; 0x16
    2568:	80 93 5f 05 	sts	0x055F, r24
    256c:	eb 81       	ldd	r30, Y+3	; 0x03
    256e:	fc 81       	ldd	r31, Y+4	; 0x04
    2570:	86 89       	ldd	r24, Z+22	; 0x16
    2572:	28 2f       	mov	r18, r24
    2574:	30 e0       	ldi	r19, 0x00	; 0
    2576:	c9 01       	movw	r24, r18
    2578:	88 0f       	add	r24, r24
    257a:	99 1f       	adc	r25, r25
    257c:	88 0f       	add	r24, r24
    257e:	99 1f       	adc	r25, r25
    2580:	88 0f       	add	r24, r24
    2582:	99 1f       	adc	r25, r25
    2584:	82 0f       	add	r24, r18
    2586:	93 1f       	adc	r25, r19
    2588:	ac 01       	movw	r20, r24
    258a:	4a 59       	subi	r20, 0x9A	; 154
    258c:	5a 4f       	sbci	r21, 0xFA	; 250
    258e:	8b 81       	ldd	r24, Y+3	; 0x03
    2590:	9c 81       	ldd	r25, Y+4	; 0x04
    2592:	9c 01       	movw	r18, r24
    2594:	2e 5f       	subi	r18, 0xFE	; 254
    2596:	3f 4f       	sbci	r19, 0xFF	; 255
    2598:	ca 01       	movw	r24, r20
    259a:	b9 01       	movw	r22, r18
    259c:	0e 94 21 09 	call	0x1242	; 0x1242 <vListInsertEnd>

			xReturn = pdPASS;
    25a0:	81 e0       	ldi	r24, 0x01	; 1
    25a2:	8d 83       	std	Y+5, r24	; 0x05
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
    25a4:	0f 90       	pop	r0
    25a6:	0f be       	out	0x3f, r0	; 63
    25a8:	02 c0       	rjmp	.+4      	; 0x25ae <xTaskGenericCreate+0x194>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    25aa:	8f ef       	ldi	r24, 0xFF	; 255
    25ac:	8d 83       	std	Y+5, r24	; 0x05
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
    25ae:	8d 81       	ldd	r24, Y+5	; 0x05
    25b0:	81 30       	cpi	r24, 0x01	; 1
    25b2:	71 f4       	brne	.+28     	; 0x25d0 <xTaskGenericCreate+0x1b6>
	{
		if( xSchedulerRunning != pdFALSE )
    25b4:	80 91 60 05 	lds	r24, 0x0560
    25b8:	88 23       	and	r24, r24
    25ba:	51 f0       	breq	.+20     	; 0x25d0 <xTaskGenericCreate+0x1b6>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
    25bc:	e0 91 58 05 	lds	r30, 0x0558
    25c0:	f0 91 59 05 	lds	r31, 0x0559
    25c4:	96 89       	ldd	r25, Z+22	; 0x16
    25c6:	8e 85       	ldd	r24, Y+14	; 0x0e
    25c8:	98 17       	cp	r25, r24
    25ca:	10 f4       	brcc	.+4      	; 0x25d0 <xTaskGenericCreate+0x1b6>
			{
				portYIELD_WITHIN_API();
    25cc:	0e 94 e1 0b 	call	0x17c2	; 0x17c2 <vPortYield>
			}
		}
	}

	return xReturn;
    25d0:	8d 81       	ldd	r24, Y+5	; 0x05
}
    25d2:	64 96       	adiw	r28, 0x14	; 20
    25d4:	0f b6       	in	r0, 0x3f	; 63
    25d6:	f8 94       	cli
    25d8:	de bf       	out	0x3e, r29	; 62
    25da:	0f be       	out	0x3f, r0	; 63
    25dc:	cd bf       	out	0x3d, r28	; 61
    25de:	cf 91       	pop	r28
    25e0:	df 91       	pop	r29
    25e2:	1f 91       	pop	r17
    25e4:	0f 91       	pop	r16
    25e6:	ff 90       	pop	r15
    25e8:	ef 90       	pop	r14
    25ea:	df 90       	pop	r13
    25ec:	cf 90       	pop	r12
    25ee:	bf 90       	pop	r11
    25f0:	af 90       	pop	r10
    25f2:	08 95       	ret

000025f4 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( xTaskHandle pxTaskToDelete )
	{
    25f4:	df 93       	push	r29
    25f6:	cf 93       	push	r28
    25f8:	00 d0       	rcall	.+0      	; 0x25fa <vTaskDelete+0x6>
    25fa:	00 d0       	rcall	.+0      	; 0x25fc <vTaskDelete+0x8>
    25fc:	00 d0       	rcall	.+0      	; 0x25fe <vTaskDelete+0xa>
    25fe:	cd b7       	in	r28, 0x3d	; 61
    2600:	de b7       	in	r29, 0x3e	; 62
    2602:	9c 83       	std	Y+4, r25	; 0x04
    2604:	8b 83       	std	Y+3, r24	; 0x03
	tskTCB *pxTCB;

		taskENTER_CRITICAL();
    2606:	0f b6       	in	r0, 0x3f	; 63
    2608:	f8 94       	cli
    260a:	0f 92       	push	r0
		{
			/* Ensure a yield is performed if the current task is being
			deleted. */
			if( pxTaskToDelete == pxCurrentTCB )
    260c:	20 91 58 05 	lds	r18, 0x0558
    2610:	30 91 59 05 	lds	r19, 0x0559
    2614:	8b 81       	ldd	r24, Y+3	; 0x03
    2616:	9c 81       	ldd	r25, Y+4	; 0x04
    2618:	82 17       	cp	r24, r18
    261a:	93 07       	cpc	r25, r19
    261c:	11 f4       	brne	.+4      	; 0x2622 <vTaskDelete+0x2e>
			{
				pxTaskToDelete = NULL;
    261e:	1c 82       	std	Y+4, r1	; 0x04
    2620:	1b 82       	std	Y+3, r1	; 0x03
			}

			/* If null is passed in here then we are deleting ourselves. */
			pxTCB = prvGetTCBFromHandle( pxTaskToDelete );
    2622:	8b 81       	ldd	r24, Y+3	; 0x03
    2624:	9c 81       	ldd	r25, Y+4	; 0x04
    2626:	00 97       	sbiw	r24, 0x00	; 0
    2628:	39 f4       	brne	.+14     	; 0x2638 <vTaskDelete+0x44>
    262a:	80 91 58 05 	lds	r24, 0x0558
    262e:	90 91 59 05 	lds	r25, 0x0559
    2632:	9e 83       	std	Y+6, r25	; 0x06
    2634:	8d 83       	std	Y+5, r24	; 0x05
    2636:	04 c0       	rjmp	.+8      	; 0x2640 <vTaskDelete+0x4c>
    2638:	8b 81       	ldd	r24, Y+3	; 0x03
    263a:	9c 81       	ldd	r25, Y+4	; 0x04
    263c:	9e 83       	std	Y+6, r25	; 0x06
    263e:	8d 83       	std	Y+5, r24	; 0x05
    2640:	8d 81       	ldd	r24, Y+5	; 0x05
    2642:	9e 81       	ldd	r25, Y+6	; 0x06
    2644:	9a 83       	std	Y+2, r25	; 0x02
    2646:	89 83       	std	Y+1, r24	; 0x01

			/* Remove task from the ready list and place in the	termination list.
			This will stop the task from be scheduled.  The idle task will check
			the termination list and free up any memory allocated by the
			scheduler for the TCB and stack. */
			vListRemove( &( pxTCB->xGenericListItem ) );
    2648:	89 81       	ldd	r24, Y+1	; 0x01
    264a:	9a 81       	ldd	r25, Y+2	; 0x02
    264c:	02 96       	adiw	r24, 0x02	; 2
    264e:	0e 94 d9 09 	call	0x13b2	; 0x13b2 <vListRemove>

			/* Is the task waiting on an event also? */
			if( pxTCB->xEventListItem.pvContainer != NULL )
    2652:	e9 81       	ldd	r30, Y+1	; 0x01
    2654:	fa 81       	ldd	r31, Y+2	; 0x02
    2656:	84 89       	ldd	r24, Z+20	; 0x14
    2658:	95 89       	ldd	r25, Z+21	; 0x15
    265a:	00 97       	sbiw	r24, 0x00	; 0
    265c:	29 f0       	breq	.+10     	; 0x2668 <vTaskDelete+0x74>
			{
				vListRemove( &( pxTCB->xEventListItem ) );
    265e:	89 81       	ldd	r24, Y+1	; 0x01
    2660:	9a 81       	ldd	r25, Y+2	; 0x02
    2662:	0c 96       	adiw	r24, 0x0c	; 12
    2664:	0e 94 d9 09 	call	0x13b2	; 0x13b2 <vListRemove>
			}

			vListInsertEnd( ( xList * ) &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
    2668:	89 81       	ldd	r24, Y+1	; 0x01
    266a:	9a 81       	ldd	r25, Y+2	; 0x02
    266c:	9c 01       	movw	r18, r24
    266e:	2e 5f       	subi	r18, 0xFE	; 254
    2670:	3f 4f       	sbci	r19, 0xFF	; 255
    2672:	82 eb       	ldi	r24, 0xB2	; 178
    2674:	95 e0       	ldi	r25, 0x05	; 5
    2676:	b9 01       	movw	r22, r18
    2678:	0e 94 21 09 	call	0x1242	; 0x1242 <vListInsertEnd>

			/* Increment the ucTasksDeleted variable so the idle task knows
			there is a task that has been deleted and that it should therefore
			check the xTasksWaitingTermination list. */
			++uxTasksDeleted;
    267c:	80 91 5a 05 	lds	r24, 0x055A
    2680:	8f 5f       	subi	r24, 0xFF	; 255
    2682:	80 93 5a 05 	sts	0x055A, r24

			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
			can detect that the task lists need re-generating. */
			uxTaskNumber++;
    2686:	80 91 65 05 	lds	r24, 0x0565
    268a:	8f 5f       	subi	r24, 0xFF	; 255
    268c:	80 93 65 05 	sts	0x0565, r24

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
    2690:	0f 90       	pop	r0
    2692:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if we have just deleted the current task. */
		if( xSchedulerRunning != pdFALSE )
    2694:	80 91 60 05 	lds	r24, 0x0560
    2698:	88 23       	and	r24, r24
    269a:	31 f0       	breq	.+12     	; 0x26a8 <vTaskDelete+0xb4>
		{
			if( ( void * ) pxTaskToDelete == NULL )
    269c:	8b 81       	ldd	r24, Y+3	; 0x03
    269e:	9c 81       	ldd	r25, Y+4	; 0x04
    26a0:	00 97       	sbiw	r24, 0x00	; 0
    26a2:	11 f4       	brne	.+4      	; 0x26a8 <vTaskDelete+0xb4>
			{
				portYIELD_WITHIN_API();
    26a4:	0e 94 e1 0b 	call	0x17c2	; 0x17c2 <vPortYield>
			}
		}
	}
    26a8:	26 96       	adiw	r28, 0x06	; 6
    26aa:	0f b6       	in	r0, 0x3f	; 63
    26ac:	f8 94       	cli
    26ae:	de bf       	out	0x3e, r29	; 62
    26b0:	0f be       	out	0x3f, r0	; 63
    26b2:	cd bf       	out	0x3d, r28	; 61
    26b4:	cf 91       	pop	r28
    26b6:	df 91       	pop	r29
    26b8:	08 95       	ret

000026ba <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
    26ba:	df 93       	push	r29
    26bc:	cf 93       	push	r28
    26be:	cd b7       	in	r28, 0x3d	; 61
    26c0:	de b7       	in	r29, 0x3e	; 62
    26c2:	28 97       	sbiw	r28, 0x08	; 8
    26c4:	0f b6       	in	r0, 0x3f	; 63
    26c6:	f8 94       	cli
    26c8:	de bf       	out	0x3e, r29	; 62
    26ca:	0f be       	out	0x3f, r0	; 63
    26cc:	cd bf       	out	0x3d, r28	; 61
    26ce:	9e 83       	std	Y+6, r25	; 0x06
    26d0:	8d 83       	std	Y+5, r24	; 0x05
    26d2:	78 87       	std	Y+8, r23	; 0x08
    26d4:	6f 83       	std	Y+7, r22	; 0x07
	portTickType xTimeToWake;
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;
    26d6:	19 82       	std	Y+1, r1	; 0x01

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );

		vTaskSuspendAll();
    26d8:	0e 94 49 14 	call	0x2892	; 0x2892 <vTaskSuspendAll>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    26dc:	ed 81       	ldd	r30, Y+5	; 0x05
    26de:	fe 81       	ldd	r31, Y+6	; 0x06
    26e0:	20 81       	ld	r18, Z
    26e2:	31 81       	ldd	r19, Z+1	; 0x01
    26e4:	8f 81       	ldd	r24, Y+7	; 0x07
    26e6:	98 85       	ldd	r25, Y+8	; 0x08
    26e8:	82 0f       	add	r24, r18
    26ea:	93 1f       	adc	r25, r19
    26ec:	9c 83       	std	Y+4, r25	; 0x04
    26ee:	8b 83       	std	Y+3, r24	; 0x03

			if( xTickCount < *pxPreviousWakeTime )
    26f0:	ed 81       	ldd	r30, Y+5	; 0x05
    26f2:	fe 81       	ldd	r31, Y+6	; 0x06
    26f4:	20 81       	ld	r18, Z
    26f6:	31 81       	ldd	r19, Z+1	; 0x01
    26f8:	80 91 5c 05 	lds	r24, 0x055C
    26fc:	90 91 5d 05 	lds	r25, 0x055D
    2700:	82 17       	cp	r24, r18
    2702:	93 07       	cpc	r25, r19
    2704:	a8 f4       	brcc	.+42     	; 0x2730 <vTaskDelayUntil+0x76>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
    2706:	ed 81       	ldd	r30, Y+5	; 0x05
    2708:	fe 81       	ldd	r31, Y+6	; 0x06
    270a:	20 81       	ld	r18, Z
    270c:	31 81       	ldd	r19, Z+1	; 0x01
    270e:	8b 81       	ldd	r24, Y+3	; 0x03
    2710:	9c 81       	ldd	r25, Y+4	; 0x04
    2712:	82 17       	cp	r24, r18
    2714:	93 07       	cpc	r25, r19
    2716:	00 f5       	brcc	.+64     	; 0x2758 <vTaskDelayUntil+0x9e>
    2718:	20 91 5c 05 	lds	r18, 0x055C
    271c:	30 91 5d 05 	lds	r19, 0x055D
    2720:	8b 81       	ldd	r24, Y+3	; 0x03
    2722:	9c 81       	ldd	r25, Y+4	; 0x04
    2724:	28 17       	cp	r18, r24
    2726:	39 07       	cpc	r19, r25
    2728:	b8 f4       	brcc	.+46     	; 0x2758 <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    272a:	81 e0       	ldi	r24, 0x01	; 1
    272c:	89 83       	std	Y+1, r24	; 0x01
    272e:	14 c0       	rjmp	.+40     	; 0x2758 <vTaskDelayUntil+0x9e>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
    2730:	ed 81       	ldd	r30, Y+5	; 0x05
    2732:	fe 81       	ldd	r31, Y+6	; 0x06
    2734:	20 81       	ld	r18, Z
    2736:	31 81       	ldd	r19, Z+1	; 0x01
    2738:	8b 81       	ldd	r24, Y+3	; 0x03
    273a:	9c 81       	ldd	r25, Y+4	; 0x04
    273c:	82 17       	cp	r24, r18
    273e:	93 07       	cpc	r25, r19
    2740:	48 f0       	brcs	.+18     	; 0x2754 <vTaskDelayUntil+0x9a>
    2742:	20 91 5c 05 	lds	r18, 0x055C
    2746:	30 91 5d 05 	lds	r19, 0x055D
    274a:	8b 81       	ldd	r24, Y+3	; 0x03
    274c:	9c 81       	ldd	r25, Y+4	; 0x04
    274e:	28 17       	cp	r18, r24
    2750:	39 07       	cpc	r19, r25
    2752:	10 f4       	brcc	.+4      	; 0x2758 <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    2754:	81 e0       	ldi	r24, 0x01	; 1
    2756:	89 83       	std	Y+1, r24	; 0x01
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    2758:	ed 81       	ldd	r30, Y+5	; 0x05
    275a:	fe 81       	ldd	r31, Y+6	; 0x06
    275c:	8b 81       	ldd	r24, Y+3	; 0x03
    275e:	9c 81       	ldd	r25, Y+4	; 0x04
    2760:	91 83       	std	Z+1, r25	; 0x01
    2762:	80 83       	st	Z, r24

			if( xShouldDelay != pdFALSE )
    2764:	89 81       	ldd	r24, Y+1	; 0x01
    2766:	88 23       	and	r24, r24
    2768:	59 f0       	breq	.+22     	; 0x2780 <vTaskDelayUntil+0xc6>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    276a:	80 91 58 05 	lds	r24, 0x0558
    276e:	90 91 59 05 	lds	r25, 0x0559
    2772:	02 96       	adiw	r24, 0x02	; 2
    2774:	0e 94 d9 09 	call	0x13b2	; 0x13b2 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    2778:	8b 81       	ldd	r24, Y+3	; 0x03
    277a:	9c 81       	ldd	r25, Y+4	; 0x04
    277c:	0e 94 4d 18 	call	0x309a	; 0x309a <prvAddCurrentTaskToDelayedList>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    2780:	0e 94 55 14 	call	0x28aa	; 0x28aa <xTaskResumeAll>
    2784:	8a 83       	std	Y+2, r24	; 0x02

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    2786:	8a 81       	ldd	r24, Y+2	; 0x02
    2788:	88 23       	and	r24, r24
    278a:	11 f4       	brne	.+4      	; 0x2790 <vTaskDelayUntil+0xd6>
		{
			portYIELD_WITHIN_API();
    278c:	0e 94 e1 0b 	call	0x17c2	; 0x17c2 <vPortYield>
		}
	}
    2790:	28 96       	adiw	r28, 0x08	; 8
    2792:	0f b6       	in	r0, 0x3f	; 63
    2794:	f8 94       	cli
    2796:	de bf       	out	0x3e, r29	; 62
    2798:	0f be       	out	0x3f, r0	; 63
    279a:	cd bf       	out	0x3d, r28	; 61
    279c:	cf 91       	pop	r28
    279e:	df 91       	pop	r29
    27a0:	08 95       	ret

000027a2 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    27a2:	df 93       	push	r29
    27a4:	cf 93       	push	r28
    27a6:	00 d0       	rcall	.+0      	; 0x27a8 <vTaskDelay+0x6>
    27a8:	00 d0       	rcall	.+0      	; 0x27aa <vTaskDelay+0x8>
    27aa:	0f 92       	push	r0
    27ac:	cd b7       	in	r28, 0x3d	; 61
    27ae:	de b7       	in	r29, 0x3e	; 62
    27b0:	9d 83       	std	Y+5, r25	; 0x05
    27b2:	8c 83       	std	Y+4, r24	; 0x04
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    27b4:	19 82       	std	Y+1, r1	; 0x01

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
    27b6:	8c 81       	ldd	r24, Y+4	; 0x04
    27b8:	9d 81       	ldd	r25, Y+5	; 0x05
    27ba:	00 97       	sbiw	r24, 0x00	; 0
    27bc:	d1 f0       	breq	.+52     	; 0x27f2 <vTaskDelay+0x50>
		{
			vTaskSuspendAll();
    27be:	0e 94 49 14 	call	0x2892	; 0x2892 <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    27c2:	20 91 5c 05 	lds	r18, 0x055C
    27c6:	30 91 5d 05 	lds	r19, 0x055D
    27ca:	8c 81       	ldd	r24, Y+4	; 0x04
    27cc:	9d 81       	ldd	r25, Y+5	; 0x05
    27ce:	82 0f       	add	r24, r18
    27d0:	93 1f       	adc	r25, r19
    27d2:	9b 83       	std	Y+3, r25	; 0x03
    27d4:	8a 83       	std	Y+2, r24	; 0x02

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    27d6:	80 91 58 05 	lds	r24, 0x0558
    27da:	90 91 59 05 	lds	r25, 0x0559
    27de:	02 96       	adiw	r24, 0x02	; 2
    27e0:	0e 94 d9 09 	call	0x13b2	; 0x13b2 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    27e4:	8a 81       	ldd	r24, Y+2	; 0x02
    27e6:	9b 81       	ldd	r25, Y+3	; 0x03
    27e8:	0e 94 4d 18 	call	0x309a	; 0x309a <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    27ec:	0e 94 55 14 	call	0x28aa	; 0x28aa <xTaskResumeAll>
    27f0:	89 83       	std	Y+1, r24	; 0x01
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    27f2:	89 81       	ldd	r24, Y+1	; 0x01
    27f4:	88 23       	and	r24, r24
    27f6:	11 f4       	brne	.+4      	; 0x27fc <vTaskDelay+0x5a>
		{
			portYIELD_WITHIN_API();
    27f8:	0e 94 e1 0b 	call	0x17c2	; 0x17c2 <vPortYield>
		}
	}
    27fc:	0f 90       	pop	r0
    27fe:	0f 90       	pop	r0
    2800:	0f 90       	pop	r0
    2802:	0f 90       	pop	r0
    2804:	0f 90       	pop	r0
    2806:	cf 91       	pop	r28
    2808:	df 91       	pop	r29
    280a:	08 95       	ret

0000280c <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
    280c:	af 92       	push	r10
    280e:	bf 92       	push	r11
    2810:	cf 92       	push	r12
    2812:	df 92       	push	r13
    2814:	ef 92       	push	r14
    2816:	ff 92       	push	r15
    2818:	0f 93       	push	r16
    281a:	df 93       	push	r29
    281c:	cf 93       	push	r28
    281e:	0f 92       	push	r0
    2820:	cd b7       	in	r28, 0x3d	; 61
    2822:	de b7       	in	r29, 0x3e	; 62
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle );
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );
    2824:	20 e6       	ldi	r18, 0x60	; 96
    2826:	30 e0       	ldi	r19, 0x00	; 0
    2828:	8d e6       	ldi	r24, 0x6D	; 109
    282a:	97 e1       	ldi	r25, 0x17	; 23
    282c:	b9 01       	movw	r22, r18
    282e:	40 e5       	ldi	r20, 0x50	; 80
    2830:	50 e0       	ldi	r21, 0x00	; 0
    2832:	20 e0       	ldi	r18, 0x00	; 0
    2834:	30 e0       	ldi	r19, 0x00	; 0
    2836:	00 e0       	ldi	r16, 0x00	; 0
    2838:	ee 24       	eor	r14, r14
    283a:	ff 24       	eor	r15, r15
    283c:	cc 24       	eor	r12, r12
    283e:	dd 24       	eor	r13, r13
    2840:	aa 24       	eor	r10, r10
    2842:	bb 24       	eor	r11, r11
    2844:	0e 94 0d 12 	call	0x241a	; 0x241a <xTaskGenericCreate>
    2848:	89 83       	std	Y+1, r24	; 0x01
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
    284a:	89 81       	ldd	r24, Y+1	; 0x01
    284c:	81 30       	cpi	r24, 0x01	; 1
    284e:	51 f4       	brne	.+20     	; 0x2864 <vTaskStartScheduler+0x58>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
    2850:	f8 94       	cli

		xSchedulerRunning = pdTRUE;
    2852:	81 e0       	ldi	r24, 0x01	; 1
    2854:	80 93 60 05 	sts	0x0560, r24
		xTickCount = ( portTickType ) 0U;
    2858:	10 92 5d 05 	sts	0x055D, r1
    285c:	10 92 5c 05 	sts	0x055C, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
		
		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    2860:	0e 94 a5 0b 	call	0x174a	; 0x174a <xPortStartScheduler>
		}
	}

	/* This line will only be reached if the kernel could not be started. */
	configASSERT( xReturn );
}
    2864:	0f 90       	pop	r0
    2866:	cf 91       	pop	r28
    2868:	df 91       	pop	r29
    286a:	0f 91       	pop	r16
    286c:	ff 90       	pop	r15
    286e:	ef 90       	pop	r14
    2870:	df 90       	pop	r13
    2872:	cf 90       	pop	r12
    2874:	bf 90       	pop	r11
    2876:	af 90       	pop	r10
    2878:	08 95       	ret

0000287a <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
    287a:	df 93       	push	r29
    287c:	cf 93       	push	r28
    287e:	cd b7       	in	r28, 0x3d	; 61
    2880:	de b7       	in	r29, 0x3e	; 62
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    2882:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    2884:	10 92 60 05 	sts	0x0560, r1
	vPortEndScheduler();
    2888:	0e 94 da 0b 	call	0x17b4	; 0x17b4 <vPortEndScheduler>
}
    288c:	cf 91       	pop	r28
    288e:	df 91       	pop	r29
    2890:	08 95       	ret

00002892 <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
    2892:	df 93       	push	r29
    2894:	cf 93       	push	r28
    2896:	cd b7       	in	r28, 0x3d	; 61
    2898:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    289a:	80 91 61 05 	lds	r24, 0x0561
    289e:	8f 5f       	subi	r24, 0xFF	; 255
    28a0:	80 93 61 05 	sts	0x0561, r24
}
    28a4:	cf 91       	pop	r28
    28a6:	df 91       	pop	r29
    28a8:	08 95       	ret

000028aa <xTaskResumeAll>:
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
    28aa:	df 93       	push	r29
    28ac:	cf 93       	push	r28
    28ae:	00 d0       	rcall	.+0      	; 0x28b0 <xTaskResumeAll+0x6>
    28b0:	00 d0       	rcall	.+0      	; 0x28b2 <xTaskResumeAll+0x8>
    28b2:	cd b7       	in	r28, 0x3d	; 61
    28b4:	de b7       	in	r29, 0x3e	; 62
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    28b6:	1a 82       	std	Y+2, r1	; 0x02
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    28b8:	0f b6       	in	r0, 0x3f	; 63
    28ba:	f8 94       	cli
    28bc:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    28be:	80 91 61 05 	lds	r24, 0x0561
    28c2:	81 50       	subi	r24, 0x01	; 1
    28c4:	80 93 61 05 	sts	0x0561, r24

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    28c8:	80 91 61 05 	lds	r24, 0x0561
    28cc:	88 23       	and	r24, r24
    28ce:	09 f0       	breq	.+2      	; 0x28d2 <xTaskResumeAll+0x28>
    28d0:	6c c0       	rjmp	.+216    	; 0x29aa <xTaskResumeAll+0x100>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
    28d2:	80 91 5b 05 	lds	r24, 0x055B
    28d6:	88 23       	and	r24, r24
    28d8:	09 f4       	brne	.+2      	; 0x28dc <xTaskResumeAll+0x32>
    28da:	67 c0       	rjmp	.+206    	; 0x29aa <xTaskResumeAll+0x100>
			{
				portBASE_TYPE xYieldRequired = pdFALSE;
    28dc:	19 82       	std	Y+1, r1	; 0x01
    28de:	41 c0       	rjmp	.+130    	; 0x2962 <xTaskResumeAll+0xb8>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
    28e0:	e0 91 ae 05 	lds	r30, 0x05AE
    28e4:	f0 91 af 05 	lds	r31, 0x05AF
    28e8:	86 81       	ldd	r24, Z+6	; 0x06
    28ea:	97 81       	ldd	r25, Z+7	; 0x07
    28ec:	9c 83       	std	Y+4, r25	; 0x04
    28ee:	8b 83       	std	Y+3, r24	; 0x03
					vListRemove( &( pxTCB->xEventListItem ) );
    28f0:	8b 81       	ldd	r24, Y+3	; 0x03
    28f2:	9c 81       	ldd	r25, Y+4	; 0x04
    28f4:	0c 96       	adiw	r24, 0x0c	; 12
    28f6:	0e 94 d9 09 	call	0x13b2	; 0x13b2 <vListRemove>
					vListRemove( &( pxTCB->xGenericListItem ) );
    28fa:	8b 81       	ldd	r24, Y+3	; 0x03
    28fc:	9c 81       	ldd	r25, Y+4	; 0x04
    28fe:	02 96       	adiw	r24, 0x02	; 2
    2900:	0e 94 d9 09 	call	0x13b2	; 0x13b2 <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    2904:	eb 81       	ldd	r30, Y+3	; 0x03
    2906:	fc 81       	ldd	r31, Y+4	; 0x04
    2908:	96 89       	ldd	r25, Z+22	; 0x16
    290a:	80 91 5f 05 	lds	r24, 0x055F
    290e:	89 17       	cp	r24, r25
    2910:	28 f4       	brcc	.+10     	; 0x291c <xTaskResumeAll+0x72>
    2912:	eb 81       	ldd	r30, Y+3	; 0x03
    2914:	fc 81       	ldd	r31, Y+4	; 0x04
    2916:	86 89       	ldd	r24, Z+22	; 0x16
    2918:	80 93 5f 05 	sts	0x055F, r24
    291c:	eb 81       	ldd	r30, Y+3	; 0x03
    291e:	fc 81       	ldd	r31, Y+4	; 0x04
    2920:	86 89       	ldd	r24, Z+22	; 0x16
    2922:	28 2f       	mov	r18, r24
    2924:	30 e0       	ldi	r19, 0x00	; 0
    2926:	c9 01       	movw	r24, r18
    2928:	88 0f       	add	r24, r24
    292a:	99 1f       	adc	r25, r25
    292c:	88 0f       	add	r24, r24
    292e:	99 1f       	adc	r25, r25
    2930:	88 0f       	add	r24, r24
    2932:	99 1f       	adc	r25, r25
    2934:	82 0f       	add	r24, r18
    2936:	93 1f       	adc	r25, r19
    2938:	8a 59       	subi	r24, 0x9A	; 154
    293a:	9a 4f       	sbci	r25, 0xFA	; 250
    293c:	2b 81       	ldd	r18, Y+3	; 0x03
    293e:	3c 81       	ldd	r19, Y+4	; 0x04
    2940:	2e 5f       	subi	r18, 0xFE	; 254
    2942:	3f 4f       	sbci	r19, 0xFF	; 255
    2944:	b9 01       	movw	r22, r18
    2946:	0e 94 21 09 	call	0x1242	; 0x1242 <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    294a:	eb 81       	ldd	r30, Y+3	; 0x03
    294c:	fc 81       	ldd	r31, Y+4	; 0x04
    294e:	96 89       	ldd	r25, Z+22	; 0x16
    2950:	e0 91 58 05 	lds	r30, 0x0558
    2954:	f0 91 59 05 	lds	r31, 0x0559
    2958:	86 89       	ldd	r24, Z+22	; 0x16
    295a:	98 17       	cp	r25, r24
    295c:	10 f0       	brcs	.+4      	; 0x2962 <xTaskResumeAll+0xb8>
					{
						xYieldRequired = pdTRUE;
    295e:	81 e0       	ldi	r24, 0x01	; 1
    2960:	89 83       	std	Y+1, r24	; 0x01
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    2962:	80 91 a9 05 	lds	r24, 0x05A9
    2966:	88 23       	and	r24, r24
    2968:	09 f0       	breq	.+2      	; 0x296c <xTaskResumeAll+0xc2>
    296a:	ba cf       	rjmp	.-140    	; 0x28e0 <xTaskResumeAll+0x36>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    296c:	80 91 62 05 	lds	r24, 0x0562
    2970:	88 23       	and	r24, r24
    2972:	71 f0       	breq	.+28     	; 0x2990 <xTaskResumeAll+0xe6>
    2974:	07 c0       	rjmp	.+14     	; 0x2984 <xTaskResumeAll+0xda>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
					{
						vTaskIncrementTick();
    2976:	0e 94 14 15 	call	0x2a28	; 0x2a28 <vTaskIncrementTick>
						--uxMissedTicks;
    297a:	80 91 62 05 	lds	r24, 0x0562
    297e:	81 50       	subi	r24, 0x01	; 1
    2980:	80 93 62 05 	sts	0x0562, r24
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    2984:	80 91 62 05 	lds	r24, 0x0562
    2988:	88 23       	and	r24, r24
    298a:	a9 f7       	brne	.-22     	; 0x2976 <xTaskResumeAll+0xcc>
					/* As we have processed some ticks it is appropriate to yield
					to ensure the highest priority task that is ready to run is
					the task actually running. */
					#if configUSE_PREEMPTION == 1
					{
						xYieldRequired = pdTRUE;
    298c:	81 e0       	ldi	r24, 0x01	; 1
    298e:	89 83       	std	Y+1, r24	; 0x01
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
    2990:	89 81       	ldd	r24, Y+1	; 0x01
    2992:	81 30       	cpi	r24, 0x01	; 1
    2994:	21 f0       	breq	.+8      	; 0x299e <xTaskResumeAll+0xf4>
    2996:	80 91 63 05 	lds	r24, 0x0563
    299a:	81 30       	cpi	r24, 0x01	; 1
    299c:	31 f4       	brne	.+12     	; 0x29aa <xTaskResumeAll+0x100>
				{
					xAlreadyYielded = pdTRUE;
    299e:	81 e0       	ldi	r24, 0x01	; 1
    29a0:	8a 83       	std	Y+2, r24	; 0x02
					xMissedYield = pdFALSE;
    29a2:	10 92 63 05 	sts	0x0563, r1
					portYIELD_WITHIN_API();
    29a6:	0e 94 e1 0b 	call	0x17c2	; 0x17c2 <vPortYield>
				}
			}
		}
	}
	taskEXIT_CRITICAL();
    29aa:	0f 90       	pop	r0
    29ac:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
    29ae:	8a 81       	ldd	r24, Y+2	; 0x02
}
    29b0:	0f 90       	pop	r0
    29b2:	0f 90       	pop	r0
    29b4:	0f 90       	pop	r0
    29b6:	0f 90       	pop	r0
    29b8:	cf 91       	pop	r28
    29ba:	df 91       	pop	r29
    29bc:	08 95       	ret

000029be <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
    29be:	df 93       	push	r29
    29c0:	cf 93       	push	r28
    29c2:	00 d0       	rcall	.+0      	; 0x29c4 <xTaskGetTickCount+0x6>
    29c4:	cd b7       	in	r28, 0x3d	; 61
    29c6:	de b7       	in	r29, 0x3e	; 62
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
    29c8:	0f b6       	in	r0, 0x3f	; 63
    29ca:	f8 94       	cli
    29cc:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    29ce:	80 91 5c 05 	lds	r24, 0x055C
    29d2:	90 91 5d 05 	lds	r25, 0x055D
    29d6:	9a 83       	std	Y+2, r25	; 0x02
    29d8:	89 83       	std	Y+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    29da:	0f 90       	pop	r0
    29dc:	0f be       	out	0x3f, r0	; 63

	return xTicks;
    29de:	89 81       	ldd	r24, Y+1	; 0x01
    29e0:	9a 81       	ldd	r25, Y+2	; 0x02
}
    29e2:	0f 90       	pop	r0
    29e4:	0f 90       	pop	r0
    29e6:	cf 91       	pop	r28
    29e8:	df 91       	pop	r29
    29ea:	08 95       	ret

000029ec <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

portTickType xTaskGetTickCountFromISR( void )
{
    29ec:	df 93       	push	r29
    29ee:	cf 93       	push	r28
    29f0:	00 d0       	rcall	.+0      	; 0x29f2 <xTaskGetTickCountFromISR+0x6>
    29f2:	0f 92       	push	r0
    29f4:	cd b7       	in	r28, 0x3d	; 61
    29f6:	de b7       	in	r29, 0x3e	; 62
portTickType xReturn;
unsigned portBASE_TYPE uxSavedInterruptStatus;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    29f8:	19 82       	std	Y+1, r1	; 0x01
	xReturn = xTickCount;
    29fa:	80 91 5c 05 	lds	r24, 0x055C
    29fe:	90 91 5d 05 	lds	r25, 0x055D
    2a02:	9b 83       	std	Y+3, r25	; 0x03
    2a04:	8a 83       	std	Y+2, r24	; 0x02
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    2a06:	8a 81       	ldd	r24, Y+2	; 0x02
    2a08:	9b 81       	ldd	r25, Y+3	; 0x03
}
    2a0a:	0f 90       	pop	r0
    2a0c:	0f 90       	pop	r0
    2a0e:	0f 90       	pop	r0
    2a10:	cf 91       	pop	r28
    2a12:	df 91       	pop	r29
    2a14:	08 95       	ret

00002a16 <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
    2a16:	df 93       	push	r29
    2a18:	cf 93       	push	r28
    2a1a:	cd b7       	in	r28, 0x3d	; 61
    2a1c:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
    2a1e:	80 91 5b 05 	lds	r24, 0x055B
}
    2a22:	cf 91       	pop	r28
    2a24:	df 91       	pop	r29
    2a26:	08 95       	ret

00002a28 <vTaskIncrementTick>:
 * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
 * documented in task.h
 *----------------------------------------------------------*/

void vTaskIncrementTick( void )
{
    2a28:	df 93       	push	r29
    2a2a:	cf 93       	push	r28
    2a2c:	00 d0       	rcall	.+0      	; 0x2a2e <vTaskIncrementTick+0x6>
    2a2e:	00 d0       	rcall	.+0      	; 0x2a30 <vTaskIncrementTick+0x8>
    2a30:	00 d0       	rcall	.+0      	; 0x2a32 <vTaskIncrementTick+0xa>
    2a32:	cd b7       	in	r28, 0x3d	; 61
    2a34:	de b7       	in	r29, 0x3e	; 62
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    2a36:	80 91 61 05 	lds	r24, 0x0561
    2a3a:	88 23       	and	r24, r24
    2a3c:	09 f0       	breq	.+2      	; 0x2a40 <vTaskIncrementTick+0x18>
    2a3e:	bb c0       	rjmp	.+374    	; 0x2bb6 <vTaskIncrementTick+0x18e>
	{
		++xTickCount;
    2a40:	80 91 5c 05 	lds	r24, 0x055C
    2a44:	90 91 5d 05 	lds	r25, 0x055D
    2a48:	01 96       	adiw	r24, 0x01	; 1
    2a4a:	90 93 5d 05 	sts	0x055D, r25
    2a4e:	80 93 5c 05 	sts	0x055C, r24
		if( xTickCount == ( portTickType ) 0U )
    2a52:	80 91 5c 05 	lds	r24, 0x055C
    2a56:	90 91 5d 05 	lds	r25, 0x055D
    2a5a:	00 97       	sbiw	r24, 0x00	; 0
    2a5c:	d1 f5       	brne	.+116    	; 0x2ad2 <vTaskIncrementTick+0xaa>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );
			
			pxTemp = pxDelayedTaskList;
    2a5e:	80 91 a5 05 	lds	r24, 0x05A5
    2a62:	90 91 a6 05 	lds	r25, 0x05A6
    2a66:	9c 83       	std	Y+4, r25	; 0x04
    2a68:	8b 83       	std	Y+3, r24	; 0x03
			pxDelayedTaskList = pxOverflowDelayedTaskList;
    2a6a:	80 91 a7 05 	lds	r24, 0x05A7
    2a6e:	90 91 a8 05 	lds	r25, 0x05A8
    2a72:	90 93 a6 05 	sts	0x05A6, r25
    2a76:	80 93 a5 05 	sts	0x05A5, r24
			pxOverflowDelayedTaskList = pxTemp;
    2a7a:	8b 81       	ldd	r24, Y+3	; 0x03
    2a7c:	9c 81       	ldd	r25, Y+4	; 0x04
    2a7e:	90 93 a8 05 	sts	0x05A8, r25
    2a82:	80 93 a7 05 	sts	0x05A7, r24
			xNumOfOverflows++;
    2a86:	80 91 64 05 	lds	r24, 0x0564
    2a8a:	8f 5f       	subi	r24, 0xFF	; 255
    2a8c:	80 93 64 05 	sts	0x0564, r24
	
			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    2a90:	e0 91 a5 05 	lds	r30, 0x05A5
    2a94:	f0 91 a6 05 	lds	r31, 0x05A6
    2a98:	80 81       	ld	r24, Z
    2a9a:	88 23       	and	r24, r24
    2a9c:	39 f4       	brne	.+14     	; 0x2aac <vTaskIncrementTick+0x84>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the	
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
    2a9e:	8f ef       	ldi	r24, 0xFF	; 255
    2aa0:	9f ef       	ldi	r25, 0xFF	; 255
    2aa2:	90 93 23 01 	sts	0x0123, r25
    2aa6:	80 93 22 01 	sts	0x0122, r24
    2aaa:	13 c0       	rjmp	.+38     	; 0x2ad2 <vTaskIncrementTick+0xaa>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    2aac:	e0 91 a5 05 	lds	r30, 0x05A5
    2ab0:	f0 91 a6 05 	lds	r31, 0x05A6
    2ab4:	05 80       	ldd	r0, Z+5	; 0x05
    2ab6:	f6 81       	ldd	r31, Z+6	; 0x06
    2ab8:	e0 2d       	mov	r30, r0
    2aba:	86 81       	ldd	r24, Z+6	; 0x06
    2abc:	97 81       	ldd	r25, Z+7	; 0x07
    2abe:	9e 83       	std	Y+6, r25	; 0x06
    2ac0:	8d 83       	std	Y+5, r24	; 0x05
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
    2ac2:	ed 81       	ldd	r30, Y+5	; 0x05
    2ac4:	fe 81       	ldd	r31, Y+6	; 0x06
    2ac6:	82 81       	ldd	r24, Z+2	; 0x02
    2ac8:	93 81       	ldd	r25, Z+3	; 0x03
    2aca:	90 93 23 01 	sts	0x0123, r25
    2ace:	80 93 22 01 	sts	0x0122, r24
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
    2ad2:	20 91 5c 05 	lds	r18, 0x055C
    2ad6:	30 91 5d 05 	lds	r19, 0x055D
    2ada:	80 91 22 01 	lds	r24, 0x0122
    2ade:	90 91 23 01 	lds	r25, 0x0123
    2ae2:	28 17       	cp	r18, r24
    2ae4:	39 07       	cpc	r19, r25
    2ae6:	08 f4       	brcc	.+2      	; 0x2aea <vTaskIncrementTick+0xc2>
    2ae8:	6b c0       	rjmp	.+214    	; 0x2bc0 <vTaskIncrementTick+0x198>
    2aea:	e0 91 a5 05 	lds	r30, 0x05A5
    2aee:	f0 91 a6 05 	lds	r31, 0x05A6
    2af2:	80 81       	ld	r24, Z
    2af4:	88 23       	and	r24, r24
    2af6:	39 f4       	brne	.+14     	; 0x2b06 <vTaskIncrementTick+0xde>
    2af8:	8f ef       	ldi	r24, 0xFF	; 255
    2afa:	9f ef       	ldi	r25, 0xFF	; 255
    2afc:	90 93 23 01 	sts	0x0123, r25
    2b00:	80 93 22 01 	sts	0x0122, r24
    2b04:	5d c0       	rjmp	.+186    	; 0x2bc0 <vTaskIncrementTick+0x198>
    2b06:	e0 91 a5 05 	lds	r30, 0x05A5
    2b0a:	f0 91 a6 05 	lds	r31, 0x05A6
    2b0e:	05 80       	ldd	r0, Z+5	; 0x05
    2b10:	f6 81       	ldd	r31, Z+6	; 0x06
    2b12:	e0 2d       	mov	r30, r0
    2b14:	86 81       	ldd	r24, Z+6	; 0x06
    2b16:	97 81       	ldd	r25, Z+7	; 0x07
    2b18:	9e 83       	std	Y+6, r25	; 0x06
    2b1a:	8d 83       	std	Y+5, r24	; 0x05
    2b1c:	ed 81       	ldd	r30, Y+5	; 0x05
    2b1e:	fe 81       	ldd	r31, Y+6	; 0x06
    2b20:	82 81       	ldd	r24, Z+2	; 0x02
    2b22:	93 81       	ldd	r25, Z+3	; 0x03
    2b24:	9a 83       	std	Y+2, r25	; 0x02
    2b26:	89 83       	std	Y+1, r24	; 0x01
    2b28:	20 91 5c 05 	lds	r18, 0x055C
    2b2c:	30 91 5d 05 	lds	r19, 0x055D
    2b30:	89 81       	ldd	r24, Y+1	; 0x01
    2b32:	9a 81       	ldd	r25, Y+2	; 0x02
    2b34:	28 17       	cp	r18, r24
    2b36:	39 07       	cpc	r19, r25
    2b38:	38 f4       	brcc	.+14     	; 0x2b48 <vTaskIncrementTick+0x120>
    2b3a:	89 81       	ldd	r24, Y+1	; 0x01
    2b3c:	9a 81       	ldd	r25, Y+2	; 0x02
    2b3e:	90 93 23 01 	sts	0x0123, r25
    2b42:	80 93 22 01 	sts	0x0122, r24
    2b46:	3c c0       	rjmp	.+120    	; 0x2bc0 <vTaskIncrementTick+0x198>
    2b48:	8d 81       	ldd	r24, Y+5	; 0x05
    2b4a:	9e 81       	ldd	r25, Y+6	; 0x06
    2b4c:	02 96       	adiw	r24, 0x02	; 2
    2b4e:	0e 94 d9 09 	call	0x13b2	; 0x13b2 <vListRemove>
    2b52:	ed 81       	ldd	r30, Y+5	; 0x05
    2b54:	fe 81       	ldd	r31, Y+6	; 0x06
    2b56:	84 89       	ldd	r24, Z+20	; 0x14
    2b58:	95 89       	ldd	r25, Z+21	; 0x15
    2b5a:	00 97       	sbiw	r24, 0x00	; 0
    2b5c:	29 f0       	breq	.+10     	; 0x2b68 <vTaskIncrementTick+0x140>
    2b5e:	8d 81       	ldd	r24, Y+5	; 0x05
    2b60:	9e 81       	ldd	r25, Y+6	; 0x06
    2b62:	0c 96       	adiw	r24, 0x0c	; 12
    2b64:	0e 94 d9 09 	call	0x13b2	; 0x13b2 <vListRemove>
    2b68:	ed 81       	ldd	r30, Y+5	; 0x05
    2b6a:	fe 81       	ldd	r31, Y+6	; 0x06
    2b6c:	96 89       	ldd	r25, Z+22	; 0x16
    2b6e:	80 91 5f 05 	lds	r24, 0x055F
    2b72:	89 17       	cp	r24, r25
    2b74:	28 f4       	brcc	.+10     	; 0x2b80 <vTaskIncrementTick+0x158>
    2b76:	ed 81       	ldd	r30, Y+5	; 0x05
    2b78:	fe 81       	ldd	r31, Y+6	; 0x06
    2b7a:	86 89       	ldd	r24, Z+22	; 0x16
    2b7c:	80 93 5f 05 	sts	0x055F, r24
    2b80:	ed 81       	ldd	r30, Y+5	; 0x05
    2b82:	fe 81       	ldd	r31, Y+6	; 0x06
    2b84:	86 89       	ldd	r24, Z+22	; 0x16
    2b86:	28 2f       	mov	r18, r24
    2b88:	30 e0       	ldi	r19, 0x00	; 0
    2b8a:	c9 01       	movw	r24, r18
    2b8c:	88 0f       	add	r24, r24
    2b8e:	99 1f       	adc	r25, r25
    2b90:	88 0f       	add	r24, r24
    2b92:	99 1f       	adc	r25, r25
    2b94:	88 0f       	add	r24, r24
    2b96:	99 1f       	adc	r25, r25
    2b98:	82 0f       	add	r24, r18
    2b9a:	93 1f       	adc	r25, r19
    2b9c:	ac 01       	movw	r20, r24
    2b9e:	4a 59       	subi	r20, 0x9A	; 154
    2ba0:	5a 4f       	sbci	r21, 0xFA	; 250
    2ba2:	8d 81       	ldd	r24, Y+5	; 0x05
    2ba4:	9e 81       	ldd	r25, Y+6	; 0x06
    2ba6:	9c 01       	movw	r18, r24
    2ba8:	2e 5f       	subi	r18, 0xFE	; 254
    2baa:	3f 4f       	sbci	r19, 0xFF	; 255
    2bac:	ca 01       	movw	r24, r20
    2bae:	b9 01       	movw	r22, r18
    2bb0:	0e 94 21 09 	call	0x1242	; 0x1242 <vListInsertEnd>
    2bb4:	9a cf       	rjmp	.-204    	; 0x2aea <vTaskIncrementTick+0xc2>
	}
	else
	{
		++uxMissedTicks;
    2bb6:	80 91 62 05 	lds	r24, 0x0562
    2bba:	8f 5f       	subi	r24, 0xFF	; 255
    2bbc:	80 93 62 05 	sts	0x0562, r24
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
    2bc0:	26 96       	adiw	r28, 0x06	; 6
    2bc2:	0f b6       	in	r0, 0x3f	; 63
    2bc4:	f8 94       	cli
    2bc6:	de bf       	out	0x3e, r29	; 62
    2bc8:	0f be       	out	0x3f, r0	; 63
    2bca:	cd bf       	out	0x3d, r28	; 61
    2bcc:	cf 91       	pop	r28
    2bce:	df 91       	pop	r29
    2bd0:	08 95       	ret

00002bd2 <vTaskSwitchContext>:

#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    2bd2:	df 93       	push	r29
    2bd4:	cf 93       	push	r28
    2bd6:	00 d0       	rcall	.+0      	; 0x2bd8 <vTaskSwitchContext+0x6>
    2bd8:	cd b7       	in	r28, 0x3d	; 61
    2bda:	de b7       	in	r29, 0x3e	; 62
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    2bdc:	80 91 61 05 	lds	r24, 0x0561
    2be0:	88 23       	and	r24, r24
    2be2:	49 f0       	breq	.+18     	; 0x2bf6 <vTaskSwitchContext+0x24>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    2be4:	81 e0       	ldi	r24, 0x01	; 1
    2be6:	80 93 63 05 	sts	0x0563, r24
    2bea:	54 c0       	rjmp	.+168    	; 0x2c94 <vTaskSwitchContext+0xc2>
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
    2bec:	80 91 5f 05 	lds	r24, 0x055F
    2bf0:	81 50       	subi	r24, 0x01	; 1
    2bf2:	80 93 5f 05 	sts	0x055F, r24
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    2bf6:	80 91 5f 05 	lds	r24, 0x055F
    2bfa:	28 2f       	mov	r18, r24
    2bfc:	30 e0       	ldi	r19, 0x00	; 0
    2bfe:	c9 01       	movw	r24, r18
    2c00:	88 0f       	add	r24, r24
    2c02:	99 1f       	adc	r25, r25
    2c04:	88 0f       	add	r24, r24
    2c06:	99 1f       	adc	r25, r25
    2c08:	88 0f       	add	r24, r24
    2c0a:	99 1f       	adc	r25, r25
    2c0c:	82 0f       	add	r24, r18
    2c0e:	93 1f       	adc	r25, r19
    2c10:	fc 01       	movw	r30, r24
    2c12:	ea 59       	subi	r30, 0x9A	; 154
    2c14:	fa 4f       	sbci	r31, 0xFA	; 250
    2c16:	80 81       	ld	r24, Z
    2c18:	88 23       	and	r24, r24
    2c1a:	41 f3       	breq	.-48     	; 0x2bec <vTaskSwitchContext+0x1a>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    2c1c:	80 91 5f 05 	lds	r24, 0x055F
    2c20:	28 2f       	mov	r18, r24
    2c22:	30 e0       	ldi	r19, 0x00	; 0
    2c24:	c9 01       	movw	r24, r18
    2c26:	88 0f       	add	r24, r24
    2c28:	99 1f       	adc	r25, r25
    2c2a:	88 0f       	add	r24, r24
    2c2c:	99 1f       	adc	r25, r25
    2c2e:	88 0f       	add	r24, r24
    2c30:	99 1f       	adc	r25, r25
    2c32:	82 0f       	add	r24, r18
    2c34:	93 1f       	adc	r25, r19
    2c36:	8a 59       	subi	r24, 0x9A	; 154
    2c38:	9a 4f       	sbci	r25, 0xFA	; 250
    2c3a:	9a 83       	std	Y+2, r25	; 0x02
    2c3c:	89 83       	std	Y+1, r24	; 0x01
    2c3e:	e9 81       	ldd	r30, Y+1	; 0x01
    2c40:	fa 81       	ldd	r31, Y+2	; 0x02
    2c42:	01 80       	ldd	r0, Z+1	; 0x01
    2c44:	f2 81       	ldd	r31, Z+2	; 0x02
    2c46:	e0 2d       	mov	r30, r0
    2c48:	82 81       	ldd	r24, Z+2	; 0x02
    2c4a:	93 81       	ldd	r25, Z+3	; 0x03
    2c4c:	e9 81       	ldd	r30, Y+1	; 0x01
    2c4e:	fa 81       	ldd	r31, Y+2	; 0x02
    2c50:	92 83       	std	Z+2, r25	; 0x02
    2c52:	81 83       	std	Z+1, r24	; 0x01
    2c54:	e9 81       	ldd	r30, Y+1	; 0x01
    2c56:	fa 81       	ldd	r31, Y+2	; 0x02
    2c58:	21 81       	ldd	r18, Z+1	; 0x01
    2c5a:	32 81       	ldd	r19, Z+2	; 0x02
    2c5c:	89 81       	ldd	r24, Y+1	; 0x01
    2c5e:	9a 81       	ldd	r25, Y+2	; 0x02
    2c60:	03 96       	adiw	r24, 0x03	; 3
    2c62:	28 17       	cp	r18, r24
    2c64:	39 07       	cpc	r19, r25
    2c66:	59 f4       	brne	.+22     	; 0x2c7e <vTaskSwitchContext+0xac>
    2c68:	e9 81       	ldd	r30, Y+1	; 0x01
    2c6a:	fa 81       	ldd	r31, Y+2	; 0x02
    2c6c:	01 80       	ldd	r0, Z+1	; 0x01
    2c6e:	f2 81       	ldd	r31, Z+2	; 0x02
    2c70:	e0 2d       	mov	r30, r0
    2c72:	82 81       	ldd	r24, Z+2	; 0x02
    2c74:	93 81       	ldd	r25, Z+3	; 0x03
    2c76:	e9 81       	ldd	r30, Y+1	; 0x01
    2c78:	fa 81       	ldd	r31, Y+2	; 0x02
    2c7a:	92 83       	std	Z+2, r25	; 0x02
    2c7c:	81 83       	std	Z+1, r24	; 0x01
    2c7e:	e9 81       	ldd	r30, Y+1	; 0x01
    2c80:	fa 81       	ldd	r31, Y+2	; 0x02
    2c82:	01 80       	ldd	r0, Z+1	; 0x01
    2c84:	f2 81       	ldd	r31, Z+2	; 0x02
    2c86:	e0 2d       	mov	r30, r0
    2c88:	86 81       	ldd	r24, Z+6	; 0x06
    2c8a:	97 81       	ldd	r25, Z+7	; 0x07
    2c8c:	90 93 59 05 	sts	0x0559, r25
    2c90:	80 93 58 05 	sts	0x0558, r24
	
		traceTASK_SWITCHED_IN();
		vWriteTraceToBuffer();
	}
}
    2c94:	0f 90       	pop	r0
    2c96:	0f 90       	pop	r0
    2c98:	cf 91       	pop	r28
    2c9a:	df 91       	pop	r29
    2c9c:	08 95       	ret

00002c9e <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    2c9e:	df 93       	push	r29
    2ca0:	cf 93       	push	r28
    2ca2:	00 d0       	rcall	.+0      	; 0x2ca4 <vTaskPlaceOnEventList+0x6>
    2ca4:	00 d0       	rcall	.+0      	; 0x2ca6 <vTaskPlaceOnEventList+0x8>
    2ca6:	00 d0       	rcall	.+0      	; 0x2ca8 <vTaskPlaceOnEventList+0xa>
    2ca8:	cd b7       	in	r28, 0x3d	; 61
    2caa:	de b7       	in	r29, 0x3e	; 62
    2cac:	9c 83       	std	Y+4, r25	; 0x04
    2cae:	8b 83       	std	Y+3, r24	; 0x03
    2cb0:	7e 83       	std	Y+6, r23	; 0x06
    2cb2:	6d 83       	std	Y+5, r22	; 0x05
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    2cb4:	4b 81       	ldd	r20, Y+3	; 0x03
    2cb6:	5c 81       	ldd	r21, Y+4	; 0x04
    2cb8:	80 91 58 05 	lds	r24, 0x0558
    2cbc:	90 91 59 05 	lds	r25, 0x0559
    2cc0:	9c 01       	movw	r18, r24
    2cc2:	24 5f       	subi	r18, 0xF4	; 244
    2cc4:	3f 4f       	sbci	r19, 0xFF	; 255
    2cc6:	ca 01       	movw	r24, r20
    2cc8:	b9 01       	movw	r22, r18
    2cca:	0e 94 6d 09 	call	0x12da	; 0x12da <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2cce:	80 91 58 05 	lds	r24, 0x0558
    2cd2:	90 91 59 05 	lds	r25, 0x0559
    2cd6:	02 96       	adiw	r24, 0x02	; 2
    2cd8:	0e 94 d9 09 	call	0x13b2	; 0x13b2 <vListRemove>
	}
	#else
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    2cdc:	20 91 5c 05 	lds	r18, 0x055C
    2ce0:	30 91 5d 05 	lds	r19, 0x055D
    2ce4:	8d 81       	ldd	r24, Y+5	; 0x05
    2ce6:	9e 81       	ldd	r25, Y+6	; 0x06
    2ce8:	82 0f       	add	r24, r18
    2cea:	93 1f       	adc	r25, r19
    2cec:	9a 83       	std	Y+2, r25	; 0x02
    2cee:	89 83       	std	Y+1, r24	; 0x01
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    2cf0:	89 81       	ldd	r24, Y+1	; 0x01
    2cf2:	9a 81       	ldd	r25, Y+2	; 0x02
    2cf4:	0e 94 4d 18 	call	0x309a	; 0x309a <prvAddCurrentTaskToDelayedList>
	}
	#endif
}
    2cf8:	26 96       	adiw	r28, 0x06	; 6
    2cfa:	0f b6       	in	r0, 0x3f	; 63
    2cfc:	f8 94       	cli
    2cfe:	de bf       	out	0x3e, r29	; 62
    2d00:	0f be       	out	0x3f, r0	; 63
    2d02:	cd bf       	out	0x3d, r28	; 61
    2d04:	cf 91       	pop	r28
    2d06:	df 91       	pop	r29
    2d08:	08 95       	ret

00002d0a <xTaskRemoveFromEventList>:
	
#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    2d0a:	df 93       	push	r29
    2d0c:	cf 93       	push	r28
    2d0e:	00 d0       	rcall	.+0      	; 0x2d10 <xTaskRemoveFromEventList+0x6>
    2d10:	00 d0       	rcall	.+0      	; 0x2d12 <xTaskRemoveFromEventList+0x8>
    2d12:	0f 92       	push	r0
    2d14:	cd b7       	in	r28, 0x3d	; 61
    2d16:	de b7       	in	r29, 0x3e	; 62
    2d18:	9d 83       	std	Y+5, r25	; 0x05
    2d1a:	8c 83       	std	Y+4, r24	; 0x04
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.
	
	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    2d1c:	ec 81       	ldd	r30, Y+4	; 0x04
    2d1e:	fd 81       	ldd	r31, Y+5	; 0x05
    2d20:	05 80       	ldd	r0, Z+5	; 0x05
    2d22:	f6 81       	ldd	r31, Z+6	; 0x06
    2d24:	e0 2d       	mov	r30, r0
    2d26:	86 81       	ldd	r24, Z+6	; 0x06
    2d28:	97 81       	ldd	r25, Z+7	; 0x07
    2d2a:	9b 83       	std	Y+3, r25	; 0x03
    2d2c:	8a 83       	std	Y+2, r24	; 0x02
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
    2d2e:	8a 81       	ldd	r24, Y+2	; 0x02
    2d30:	9b 81       	ldd	r25, Y+3	; 0x03
    2d32:	0c 96       	adiw	r24, 0x0c	; 12
    2d34:	0e 94 d9 09 	call	0x13b2	; 0x13b2 <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    2d38:	80 91 61 05 	lds	r24, 0x0561
    2d3c:	88 23       	and	r24, r24
    2d3e:	61 f5       	brne	.+88     	; 0x2d98 <xTaskRemoveFromEventList+0x8e>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    2d40:	8a 81       	ldd	r24, Y+2	; 0x02
    2d42:	9b 81       	ldd	r25, Y+3	; 0x03
    2d44:	02 96       	adiw	r24, 0x02	; 2
    2d46:	0e 94 d9 09 	call	0x13b2	; 0x13b2 <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    2d4a:	ea 81       	ldd	r30, Y+2	; 0x02
    2d4c:	fb 81       	ldd	r31, Y+3	; 0x03
    2d4e:	96 89       	ldd	r25, Z+22	; 0x16
    2d50:	80 91 5f 05 	lds	r24, 0x055F
    2d54:	89 17       	cp	r24, r25
    2d56:	28 f4       	brcc	.+10     	; 0x2d62 <xTaskRemoveFromEventList+0x58>
    2d58:	ea 81       	ldd	r30, Y+2	; 0x02
    2d5a:	fb 81       	ldd	r31, Y+3	; 0x03
    2d5c:	86 89       	ldd	r24, Z+22	; 0x16
    2d5e:	80 93 5f 05 	sts	0x055F, r24
    2d62:	ea 81       	ldd	r30, Y+2	; 0x02
    2d64:	fb 81       	ldd	r31, Y+3	; 0x03
    2d66:	86 89       	ldd	r24, Z+22	; 0x16
    2d68:	28 2f       	mov	r18, r24
    2d6a:	30 e0       	ldi	r19, 0x00	; 0
    2d6c:	c9 01       	movw	r24, r18
    2d6e:	88 0f       	add	r24, r24
    2d70:	99 1f       	adc	r25, r25
    2d72:	88 0f       	add	r24, r24
    2d74:	99 1f       	adc	r25, r25
    2d76:	88 0f       	add	r24, r24
    2d78:	99 1f       	adc	r25, r25
    2d7a:	82 0f       	add	r24, r18
    2d7c:	93 1f       	adc	r25, r19
    2d7e:	ac 01       	movw	r20, r24
    2d80:	4a 59       	subi	r20, 0x9A	; 154
    2d82:	5a 4f       	sbci	r21, 0xFA	; 250
    2d84:	8a 81       	ldd	r24, Y+2	; 0x02
    2d86:	9b 81       	ldd	r25, Y+3	; 0x03
    2d88:	9c 01       	movw	r18, r24
    2d8a:	2e 5f       	subi	r18, 0xFE	; 254
    2d8c:	3f 4f       	sbci	r19, 0xFF	; 255
    2d8e:	ca 01       	movw	r24, r20
    2d90:	b9 01       	movw	r22, r18
    2d92:	0e 94 21 09 	call	0x1242	; 0x1242 <vListInsertEnd>
    2d96:	0a c0       	rjmp	.+20     	; 0x2dac <xTaskRemoveFromEventList+0xa2>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    2d98:	8a 81       	ldd	r24, Y+2	; 0x02
    2d9a:	9b 81       	ldd	r25, Y+3	; 0x03
    2d9c:	9c 01       	movw	r18, r24
    2d9e:	24 5f       	subi	r18, 0xF4	; 244
    2da0:	3f 4f       	sbci	r19, 0xFF	; 255
    2da2:	89 ea       	ldi	r24, 0xA9	; 169
    2da4:	95 e0       	ldi	r25, 0x05	; 5
    2da6:	b9 01       	movw	r22, r18
    2da8:	0e 94 21 09 	call	0x1242	; 0x1242 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    2dac:	ea 81       	ldd	r30, Y+2	; 0x02
    2dae:	fb 81       	ldd	r31, Y+3	; 0x03
    2db0:	96 89       	ldd	r25, Z+22	; 0x16
    2db2:	e0 91 58 05 	lds	r30, 0x0558
    2db6:	f0 91 59 05 	lds	r31, 0x0559
    2dba:	86 89       	ldd	r24, Z+22	; 0x16
    2dbc:	98 17       	cp	r25, r24
    2dbe:	18 f0       	brcs	.+6      	; 0x2dc6 <xTaskRemoveFromEventList+0xbc>
	{
		/* Return true if the task removed from the event list has
		a higher priority than the calling task.  This allows
		the calling task to know if it should force a context
		switch now. */
		xReturn = pdTRUE;
    2dc0:	81 e0       	ldi	r24, 0x01	; 1
    2dc2:	89 83       	std	Y+1, r24	; 0x01
    2dc4:	01 c0       	rjmp	.+2      	; 0x2dc8 <xTaskRemoveFromEventList+0xbe>
	}
	else
	{
		xReturn = pdFALSE;
    2dc6:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    2dc8:	89 81       	ldd	r24, Y+1	; 0x01
}
    2dca:	0f 90       	pop	r0
    2dcc:	0f 90       	pop	r0
    2dce:	0f 90       	pop	r0
    2dd0:	0f 90       	pop	r0
    2dd2:	0f 90       	pop	r0
    2dd4:	cf 91       	pop	r28
    2dd6:	df 91       	pop	r29
    2dd8:	08 95       	ret

00002dda <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
    2dda:	df 93       	push	r29
    2ddc:	cf 93       	push	r28
    2dde:	00 d0       	rcall	.+0      	; 0x2de0 <vTaskSetTimeOutState+0x6>
    2de0:	cd b7       	in	r28, 0x3d	; 61
    2de2:	de b7       	in	r29, 0x3e	; 62
    2de4:	9a 83       	std	Y+2, r25	; 0x02
    2de6:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    2de8:	80 91 64 05 	lds	r24, 0x0564
    2dec:	e9 81       	ldd	r30, Y+1	; 0x01
    2dee:	fa 81       	ldd	r31, Y+2	; 0x02
    2df0:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    2df2:	80 91 5c 05 	lds	r24, 0x055C
    2df6:	90 91 5d 05 	lds	r25, 0x055D
    2dfa:	e9 81       	ldd	r30, Y+1	; 0x01
    2dfc:	fa 81       	ldd	r31, Y+2	; 0x02
    2dfe:	92 83       	std	Z+2, r25	; 0x02
    2e00:	81 83       	std	Z+1, r24	; 0x01
}
    2e02:	0f 90       	pop	r0
    2e04:	0f 90       	pop	r0
    2e06:	cf 91       	pop	r28
    2e08:	df 91       	pop	r29
    2e0a:	08 95       	ret

00002e0c <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    2e0c:	df 93       	push	r29
    2e0e:	cf 93       	push	r28
    2e10:	00 d0       	rcall	.+0      	; 0x2e12 <xTaskCheckForTimeOut+0x6>
    2e12:	00 d0       	rcall	.+0      	; 0x2e14 <xTaskCheckForTimeOut+0x8>
    2e14:	0f 92       	push	r0
    2e16:	cd b7       	in	r28, 0x3d	; 61
    2e18:	de b7       	in	r29, 0x3e	; 62
    2e1a:	9b 83       	std	Y+3, r25	; 0x03
    2e1c:	8a 83       	std	Y+2, r24	; 0x02
    2e1e:	7d 83       	std	Y+5, r23	; 0x05
    2e20:	6c 83       	std	Y+4, r22	; 0x04
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    2e22:	0f b6       	in	r0, 0x3f	; 63
    2e24:	f8 94       	cli
    2e26:	0f 92       	push	r0
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    2e28:	ea 81       	ldd	r30, Y+2	; 0x02
    2e2a:	fb 81       	ldd	r31, Y+3	; 0x03
    2e2c:	90 81       	ld	r25, Z
    2e2e:	80 91 64 05 	lds	r24, 0x0564
    2e32:	98 17       	cp	r25, r24
    2e34:	71 f0       	breq	.+28     	; 0x2e52 <xTaskCheckForTimeOut+0x46>
    2e36:	ea 81       	ldd	r30, Y+2	; 0x02
    2e38:	fb 81       	ldd	r31, Y+3	; 0x03
    2e3a:	21 81       	ldd	r18, Z+1	; 0x01
    2e3c:	32 81       	ldd	r19, Z+2	; 0x02
    2e3e:	80 91 5c 05 	lds	r24, 0x055C
    2e42:	90 91 5d 05 	lds	r25, 0x055D
    2e46:	82 17       	cp	r24, r18
    2e48:	93 07       	cpc	r25, r19
    2e4a:	18 f0       	brcs	.+6      	; 0x2e52 <xTaskCheckForTimeOut+0x46>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    2e4c:	81 e0       	ldi	r24, 0x01	; 1
    2e4e:	89 83       	std	Y+1, r24	; 0x01
    2e50:	2f c0       	rjmp	.+94     	; 0x2eb0 <xTaskCheckForTimeOut+0xa4>
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    2e52:	20 91 5c 05 	lds	r18, 0x055C
    2e56:	30 91 5d 05 	lds	r19, 0x055D
    2e5a:	ea 81       	ldd	r30, Y+2	; 0x02
    2e5c:	fb 81       	ldd	r31, Y+3	; 0x03
    2e5e:	81 81       	ldd	r24, Z+1	; 0x01
    2e60:	92 81       	ldd	r25, Z+2	; 0x02
    2e62:	28 1b       	sub	r18, r24
    2e64:	39 0b       	sbc	r19, r25
    2e66:	ec 81       	ldd	r30, Y+4	; 0x04
    2e68:	fd 81       	ldd	r31, Y+5	; 0x05
    2e6a:	80 81       	ld	r24, Z
    2e6c:	91 81       	ldd	r25, Z+1	; 0x01
    2e6e:	28 17       	cp	r18, r24
    2e70:	39 07       	cpc	r19, r25
    2e72:	e0 f4       	brcc	.+56     	; 0x2eac <xTaskCheckForTimeOut+0xa0>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    2e74:	ec 81       	ldd	r30, Y+4	; 0x04
    2e76:	fd 81       	ldd	r31, Y+5	; 0x05
    2e78:	40 81       	ld	r20, Z
    2e7a:	51 81       	ldd	r21, Z+1	; 0x01
    2e7c:	ea 81       	ldd	r30, Y+2	; 0x02
    2e7e:	fb 81       	ldd	r31, Y+3	; 0x03
    2e80:	21 81       	ldd	r18, Z+1	; 0x01
    2e82:	32 81       	ldd	r19, Z+2	; 0x02
    2e84:	80 91 5c 05 	lds	r24, 0x055C
    2e88:	90 91 5d 05 	lds	r25, 0x055D
    2e8c:	b9 01       	movw	r22, r18
    2e8e:	68 1b       	sub	r22, r24
    2e90:	79 0b       	sbc	r23, r25
    2e92:	cb 01       	movw	r24, r22
    2e94:	84 0f       	add	r24, r20
    2e96:	95 1f       	adc	r25, r21
    2e98:	ec 81       	ldd	r30, Y+4	; 0x04
    2e9a:	fd 81       	ldd	r31, Y+5	; 0x05
    2e9c:	91 83       	std	Z+1, r25	; 0x01
    2e9e:	80 83       	st	Z, r24
			vTaskSetTimeOutState( pxTimeOut );
    2ea0:	8a 81       	ldd	r24, Y+2	; 0x02
    2ea2:	9b 81       	ldd	r25, Y+3	; 0x03
    2ea4:	0e 94 ed 16 	call	0x2dda	; 0x2dda <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    2ea8:	19 82       	std	Y+1, r1	; 0x01
    2eaa:	02 c0       	rjmp	.+4      	; 0x2eb0 <xTaskCheckForTimeOut+0xa4>
		}
		else
		{
			xReturn = pdTRUE;
    2eac:	81 e0       	ldi	r24, 0x01	; 1
    2eae:	89 83       	std	Y+1, r24	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    2eb0:	0f 90       	pop	r0
    2eb2:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    2eb4:	89 81       	ldd	r24, Y+1	; 0x01
}
    2eb6:	0f 90       	pop	r0
    2eb8:	0f 90       	pop	r0
    2eba:	0f 90       	pop	r0
    2ebc:	0f 90       	pop	r0
    2ebe:	0f 90       	pop	r0
    2ec0:	cf 91       	pop	r28
    2ec2:	df 91       	pop	r29
    2ec4:	08 95       	ret

00002ec6 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    2ec6:	df 93       	push	r29
    2ec8:	cf 93       	push	r28
    2eca:	cd b7       	in	r28, 0x3d	; 61
    2ecc:	de b7       	in	r29, 0x3e	; 62
	xMissedYield = pdTRUE;
    2ece:	81 e0       	ldi	r24, 0x01	; 1
    2ed0:	80 93 63 05 	sts	0x0563, r24
}
    2ed4:	cf 91       	pop	r28
    2ed6:	df 91       	pop	r29
    2ed8:	08 95       	ret

00002eda <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    2eda:	df 93       	push	r29
    2edc:	cf 93       	push	r28
    2ede:	00 d0       	rcall	.+0      	; 0x2ee0 <prvIdleTask+0x6>
    2ee0:	cd b7       	in	r28, 0x3d	; 61
    2ee2:	de b7       	in	r29, 0x3e	; 62
    2ee4:	9a 83       	std	Y+2, r25	; 0x02
    2ee6:	89 83       	std	Y+1, r24	; 0x01
	( void ) pvParameters;

	for( ;; )
	{
		/* See if any tasks have been deleted. */
		prvCheckTasksWaitingTermination();
    2ee8:	0e 94 0f 18 	call	0x301e	; 0x301e <prvCheckTasksWaitingTermination>
    2eec:	fd cf       	rjmp	.-6      	; 0x2ee8 <prvIdleTask+0xe>

00002eee <prvInitialiseTCBVariables>:
 *----------------------------------------------------------*/



static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned portBASE_TYPE uxPriority, const xMemoryRegion * const xRegions, unsigned short usStackDepth )
{
    2eee:	0f 93       	push	r16
    2ef0:	1f 93       	push	r17
    2ef2:	df 93       	push	r29
    2ef4:	cf 93       	push	r28
    2ef6:	cd b7       	in	r28, 0x3d	; 61
    2ef8:	de b7       	in	r29, 0x3e	; 62
    2efa:	29 97       	sbiw	r28, 0x09	; 9
    2efc:	0f b6       	in	r0, 0x3f	; 63
    2efe:	f8 94       	cli
    2f00:	de bf       	out	0x3e, r29	; 62
    2f02:	0f be       	out	0x3f, r0	; 63
    2f04:	cd bf       	out	0x3d, r28	; 61
    2f06:	9a 83       	std	Y+2, r25	; 0x02
    2f08:	89 83       	std	Y+1, r24	; 0x01
    2f0a:	7c 83       	std	Y+4, r23	; 0x04
    2f0c:	6b 83       	std	Y+3, r22	; 0x03
    2f0e:	4d 83       	std	Y+5, r20	; 0x05
    2f10:	3f 83       	std	Y+7, r19	; 0x07
    2f12:	2e 83       	std	Y+6, r18	; 0x06
    2f14:	19 87       	std	Y+9, r17	; 0x09
    2f16:	08 87       	std	Y+8, r16	; 0x08
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
    2f18:	89 81       	ldd	r24, Y+1	; 0x01
    2f1a:	9a 81       	ldd	r25, Y+2	; 0x02
    2f1c:	49 96       	adiw	r24, 0x19	; 25
    2f1e:	2b 81       	ldd	r18, Y+3	; 0x03
    2f20:	3c 81       	ldd	r19, Y+4	; 0x04
    2f22:	b9 01       	movw	r22, r18
    2f24:	48 e0       	ldi	r20, 0x08	; 8
    2f26:	50 e0       	ldi	r21, 0x00	; 0
    2f28:	0e 94 37 2c 	call	0x586e	; 0x586e <strncpy>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
    2f2c:	e9 81       	ldd	r30, Y+1	; 0x01
    2f2e:	fa 81       	ldd	r31, Y+2	; 0x02
    2f30:	10 a2       	std	Z+32, r1	; 0x20

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= configMAX_PRIORITIES )
    2f32:	8d 81       	ldd	r24, Y+5	; 0x05
    2f34:	85 30       	cpi	r24, 0x05	; 5
    2f36:	10 f0       	brcs	.+4      	; 0x2f3c <prvInitialiseTCBVariables+0x4e>
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
    2f38:	84 e0       	ldi	r24, 0x04	; 4
    2f3a:	8d 83       	std	Y+5, r24	; 0x05
	}

	pxTCB->uxPriority = uxPriority;
    2f3c:	e9 81       	ldd	r30, Y+1	; 0x01
    2f3e:	fa 81       	ldd	r31, Y+2	; 0x02
    2f40:	8d 81       	ldd	r24, Y+5	; 0x05
    2f42:	86 8b       	std	Z+22, r24	; 0x16
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
    2f44:	e9 81       	ldd	r30, Y+1	; 0x01
    2f46:	fa 81       	ldd	r31, Y+2	; 0x02
    2f48:	8d 81       	ldd	r24, Y+5	; 0x05
    2f4a:	81 a3       	std	Z+33, r24	; 0x21
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
    2f4c:	89 81       	ldd	r24, Y+1	; 0x01
    2f4e:	9a 81       	ldd	r25, Y+2	; 0x02
    2f50:	02 96       	adiw	r24, 0x02	; 2
    2f52:	0e 94 11 09 	call	0x1222	; 0x1222 <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
    2f56:	89 81       	ldd	r24, Y+1	; 0x01
    2f58:	9a 81       	ldd	r25, Y+2	; 0x02
    2f5a:	0c 96       	adiw	r24, 0x0c	; 12
    2f5c:	0e 94 11 09 	call	0x1222	; 0x1222 <vListInitialiseItem>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
    2f60:	e9 81       	ldd	r30, Y+1	; 0x01
    2f62:	fa 81       	ldd	r31, Y+2	; 0x02
    2f64:	89 81       	ldd	r24, Y+1	; 0x01
    2f66:	9a 81       	ldd	r25, Y+2	; 0x02
    2f68:	91 87       	std	Z+9, r25	; 0x09
    2f6a:	80 87       	std	Z+8, r24	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    2f6c:	8d 81       	ldd	r24, Y+5	; 0x05
    2f6e:	28 2f       	mov	r18, r24
    2f70:	30 e0       	ldi	r19, 0x00	; 0
    2f72:	85 e0       	ldi	r24, 0x05	; 5
    2f74:	90 e0       	ldi	r25, 0x00	; 0
    2f76:	82 1b       	sub	r24, r18
    2f78:	93 0b       	sbc	r25, r19
    2f7a:	e9 81       	ldd	r30, Y+1	; 0x01
    2f7c:	fa 81       	ldd	r31, Y+2	; 0x02
    2f7e:	95 87       	std	Z+13, r25	; 0x0d
    2f80:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
    2f82:	e9 81       	ldd	r30, Y+1	; 0x01
    2f84:	fa 81       	ldd	r31, Y+2	; 0x02
    2f86:	89 81       	ldd	r24, Y+1	; 0x01
    2f88:	9a 81       	ldd	r25, Y+2	; 0x02
    2f8a:	93 8b       	std	Z+19, r25	; 0x13
    2f8c:	82 8b       	std	Z+18, r24	; 0x12
	{
		( void ) xRegions;
		( void ) usStackDepth;
	}
	#endif
}
    2f8e:	29 96       	adiw	r28, 0x09	; 9
    2f90:	0f b6       	in	r0, 0x3f	; 63
    2f92:	f8 94       	cli
    2f94:	de bf       	out	0x3e, r29	; 62
    2f96:	0f be       	out	0x3f, r0	; 63
    2f98:	cd bf       	out	0x3d, r28	; 61
    2f9a:	cf 91       	pop	r28
    2f9c:	df 91       	pop	r29
    2f9e:	1f 91       	pop	r17
    2fa0:	0f 91       	pop	r16
    2fa2:	08 95       	ret

00002fa4 <prvInitialiseTaskLists>:
	}
	/*-----------------------------------------------------------*/
#endif

static void prvInitialiseTaskLists( void )
{
    2fa4:	df 93       	push	r29
    2fa6:	cf 93       	push	r28
    2fa8:	0f 92       	push	r0
    2faa:	cd b7       	in	r28, 0x3d	; 61
    2fac:	de b7       	in	r29, 0x3e	; 62
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
    2fae:	19 82       	std	Y+1, r1	; 0x01
    2fb0:	13 c0       	rjmp	.+38     	; 0x2fd8 <prvInitialiseTaskLists+0x34>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
    2fb2:	89 81       	ldd	r24, Y+1	; 0x01
    2fb4:	28 2f       	mov	r18, r24
    2fb6:	30 e0       	ldi	r19, 0x00	; 0
    2fb8:	c9 01       	movw	r24, r18
    2fba:	88 0f       	add	r24, r24
    2fbc:	99 1f       	adc	r25, r25
    2fbe:	88 0f       	add	r24, r24
    2fc0:	99 1f       	adc	r25, r25
    2fc2:	88 0f       	add	r24, r24
    2fc4:	99 1f       	adc	r25, r25
    2fc6:	82 0f       	add	r24, r18
    2fc8:	93 1f       	adc	r25, r19
    2fca:	8a 59       	subi	r24, 0x9A	; 154
    2fcc:	9a 4f       	sbci	r25, 0xFA	; 250
    2fce:	0e 94 e7 08 	call	0x11ce	; 0x11ce <vListInitialise>

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
    2fd2:	89 81       	ldd	r24, Y+1	; 0x01
    2fd4:	8f 5f       	subi	r24, 0xFF	; 255
    2fd6:	89 83       	std	Y+1, r24	; 0x01
    2fd8:	89 81       	ldd	r24, Y+1	; 0x01
    2fda:	85 30       	cpi	r24, 0x05	; 5
    2fdc:	50 f3       	brcs	.-44     	; 0x2fb2 <prvInitialiseTaskLists+0xe>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
    2fde:	83 e9       	ldi	r24, 0x93	; 147
    2fe0:	95 e0       	ldi	r25, 0x05	; 5
    2fe2:	0e 94 e7 08 	call	0x11ce	; 0x11ce <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
    2fe6:	8c e9       	ldi	r24, 0x9C	; 156
    2fe8:	95 e0       	ldi	r25, 0x05	; 5
    2fea:	0e 94 e7 08 	call	0x11ce	; 0x11ce <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyList );
    2fee:	89 ea       	ldi	r24, 0xA9	; 169
    2ff0:	95 e0       	ldi	r25, 0x05	; 5
    2ff2:	0e 94 e7 08 	call	0x11ce	; 0x11ce <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
    2ff6:	82 eb       	ldi	r24, 0xB2	; 178
    2ff8:	95 e0       	ldi	r25, 0x05	; 5
    2ffa:	0e 94 e7 08 	call	0x11ce	; 0x11ce <vListInitialise>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    2ffe:	83 e9       	ldi	r24, 0x93	; 147
    3000:	95 e0       	ldi	r25, 0x05	; 5
    3002:	90 93 a6 05 	sts	0x05A6, r25
    3006:	80 93 a5 05 	sts	0x05A5, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    300a:	8c e9       	ldi	r24, 0x9C	; 156
    300c:	95 e0       	ldi	r25, 0x05	; 5
    300e:	90 93 a8 05 	sts	0x05A8, r25
    3012:	80 93 a7 05 	sts	0x05A7, r24
}
    3016:	0f 90       	pop	r0
    3018:	cf 91       	pop	r28
    301a:	df 91       	pop	r29
    301c:	08 95       	ret

0000301e <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    301e:	df 93       	push	r29
    3020:	cf 93       	push	r28
    3022:	00 d0       	rcall	.+0      	; 0x3024 <prvCheckTasksWaitingTermination+0x6>
    3024:	0f 92       	push	r0
    3026:	cd b7       	in	r28, 0x3d	; 61
    3028:	de b7       	in	r29, 0x3e	; 62
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
    302a:	80 91 5a 05 	lds	r24, 0x055A
    302e:	88 23       	and	r24, r24
    3030:	71 f1       	breq	.+92     	; 0x308e <prvCheckTasksWaitingTermination+0x70>
		{
			vTaskSuspendAll();
    3032:	0e 94 49 14 	call	0x2892	; 0x2892 <vTaskSuspendAll>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    3036:	80 91 b2 05 	lds	r24, 0x05B2
    303a:	1b 82       	std	Y+3, r1	; 0x03
    303c:	88 23       	and	r24, r24
    303e:	11 f4       	brne	.+4      	; 0x3044 <prvCheckTasksWaitingTermination+0x26>
    3040:	81 e0       	ldi	r24, 0x01	; 1
    3042:	8b 83       	std	Y+3, r24	; 0x03
			xTaskResumeAll();
    3044:	0e 94 55 14 	call	0x28aa	; 0x28aa <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
    3048:	8b 81       	ldd	r24, Y+3	; 0x03
    304a:	88 23       	and	r24, r24
    304c:	01 f5       	brne	.+64     	; 0x308e <prvCheckTasksWaitingTermination+0x70>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
    304e:	0f b6       	in	r0, 0x3f	; 63
    3050:	f8 94       	cli
    3052:	0f 92       	push	r0
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
    3054:	e0 91 b7 05 	lds	r30, 0x05B7
    3058:	f0 91 b8 05 	lds	r31, 0x05B8
    305c:	86 81       	ldd	r24, Z+6	; 0x06
    305e:	97 81       	ldd	r25, Z+7	; 0x07
    3060:	9a 83       	std	Y+2, r25	; 0x02
    3062:	89 83       	std	Y+1, r24	; 0x01
					vListRemove( &( pxTCB->xGenericListItem ) );
    3064:	89 81       	ldd	r24, Y+1	; 0x01
    3066:	9a 81       	ldd	r25, Y+2	; 0x02
    3068:	02 96       	adiw	r24, 0x02	; 2
    306a:	0e 94 d9 09 	call	0x13b2	; 0x13b2 <vListRemove>
					--uxCurrentNumberOfTasks;
    306e:	80 91 5b 05 	lds	r24, 0x055B
    3072:	81 50       	subi	r24, 0x01	; 1
    3074:	80 93 5b 05 	sts	0x055B, r24
					--uxTasksDeleted;
    3078:	80 91 5a 05 	lds	r24, 0x055A
    307c:	81 50       	subi	r24, 0x01	; 1
    307e:	80 93 5a 05 	sts	0x055A, r24
				}
				taskEXIT_CRITICAL();
    3082:	0f 90       	pop	r0
    3084:	0f be       	out	0x3f, r0	; 63

				prvDeleteTCB( pxTCB );
    3086:	89 81       	ldd	r24, Y+1	; 0x01
    3088:	9a 81       	ldd	r25, Y+2	; 0x02
    308a:	0e 94 e6 18 	call	0x31cc	; 0x31cc <prvDeleteTCB>
			}
		}
	}
	#endif
}
    308e:	0f 90       	pop	r0
    3090:	0f 90       	pop	r0
    3092:	0f 90       	pop	r0
    3094:	cf 91       	pop	r28
    3096:	df 91       	pop	r29
    3098:	08 95       	ret

0000309a <prvAddCurrentTaskToDelayedList>:
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
    309a:	df 93       	push	r29
    309c:	cf 93       	push	r28
    309e:	00 d0       	rcall	.+0      	; 0x30a0 <prvAddCurrentTaskToDelayedList+0x6>
    30a0:	cd b7       	in	r28, 0x3d	; 61
    30a2:	de b7       	in	r29, 0x3e	; 62
    30a4:	9a 83       	std	Y+2, r25	; 0x02
    30a6:	89 83       	std	Y+1, r24	; 0x01
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    30a8:	e0 91 58 05 	lds	r30, 0x0558
    30ac:	f0 91 59 05 	lds	r31, 0x0559
    30b0:	89 81       	ldd	r24, Y+1	; 0x01
    30b2:	9a 81       	ldd	r25, Y+2	; 0x02
    30b4:	93 83       	std	Z+3, r25	; 0x03
    30b6:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xTickCount )
    30b8:	20 91 5c 05 	lds	r18, 0x055C
    30bc:	30 91 5d 05 	lds	r19, 0x055D
    30c0:	89 81       	ldd	r24, Y+1	; 0x01
    30c2:	9a 81       	ldd	r25, Y+2	; 0x02
    30c4:	82 17       	cp	r24, r18
    30c6:	93 07       	cpc	r25, r19
    30c8:	70 f4       	brcc	.+28     	; 0x30e6 <prvAddCurrentTaskToDelayedList+0x4c>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    30ca:	80 91 a7 05 	lds	r24, 0x05A7
    30ce:	90 91 a8 05 	lds	r25, 0x05A8
    30d2:	20 91 58 05 	lds	r18, 0x0558
    30d6:	30 91 59 05 	lds	r19, 0x0559
    30da:	2e 5f       	subi	r18, 0xFE	; 254
    30dc:	3f 4f       	sbci	r19, 0xFF	; 255
    30de:	b9 01       	movw	r22, r18
    30e0:	0e 94 6d 09 	call	0x12da	; 0x12da <vListInsert>
    30e4:	1e c0       	rjmp	.+60     	; 0x3122 <prvAddCurrentTaskToDelayedList+0x88>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    30e6:	40 91 a5 05 	lds	r20, 0x05A5
    30ea:	50 91 a6 05 	lds	r21, 0x05A6
    30ee:	80 91 58 05 	lds	r24, 0x0558
    30f2:	90 91 59 05 	lds	r25, 0x0559
    30f6:	9c 01       	movw	r18, r24
    30f8:	2e 5f       	subi	r18, 0xFE	; 254
    30fa:	3f 4f       	sbci	r19, 0xFF	; 255
    30fc:	ca 01       	movw	r24, r20
    30fe:	b9 01       	movw	r22, r18
    3100:	0e 94 6d 09 	call	0x12da	; 0x12da <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
    3104:	20 91 22 01 	lds	r18, 0x0122
    3108:	30 91 23 01 	lds	r19, 0x0123
    310c:	89 81       	ldd	r24, Y+1	; 0x01
    310e:	9a 81       	ldd	r25, Y+2	; 0x02
    3110:	82 17       	cp	r24, r18
    3112:	93 07       	cpc	r25, r19
    3114:	30 f4       	brcc	.+12     	; 0x3122 <prvAddCurrentTaskToDelayedList+0x88>
		{
			xNextTaskUnblockTime = xTimeToWake;
    3116:	89 81       	ldd	r24, Y+1	; 0x01
    3118:	9a 81       	ldd	r25, Y+2	; 0x02
    311a:	90 93 23 01 	sts	0x0123, r25
    311e:	80 93 22 01 	sts	0x0122, r24
		}
	}
}
    3122:	0f 90       	pop	r0
    3124:	0f 90       	pop	r0
    3126:	cf 91       	pop	r28
    3128:	df 91       	pop	r29
    312a:	08 95       	ret

0000312c <prvAllocateTCBAndStack>:
/*-----------------------------------------------------------*/

static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer )
{
    312c:	df 93       	push	r29
    312e:	cf 93       	push	r28
    3130:	cd b7       	in	r28, 0x3d	; 61
    3132:	de b7       	in	r29, 0x3e	; 62
    3134:	28 97       	sbiw	r28, 0x08	; 8
    3136:	0f b6       	in	r0, 0x3f	; 63
    3138:	f8 94       	cli
    313a:	de bf       	out	0x3e, r29	; 62
    313c:	0f be       	out	0x3f, r0	; 63
    313e:	cd bf       	out	0x3d, r28	; 61
    3140:	9c 83       	std	Y+4, r25	; 0x04
    3142:	8b 83       	std	Y+3, r24	; 0x03
    3144:	7e 83       	std	Y+6, r23	; 0x06
    3146:	6d 83       	std	Y+5, r22	; 0x05
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
    3148:	82 e2       	ldi	r24, 0x22	; 34
    314a:	90 e0       	ldi	r25, 0x00	; 0
    314c:	0e 94 7b 08 	call	0x10f6	; 0x10f6 <pvPortMalloc>
    3150:	9a 83       	std	Y+2, r25	; 0x02
    3152:	89 83       	std	Y+1, r24	; 0x01

	if( pxNewTCB != NULL )
    3154:	89 81       	ldd	r24, Y+1	; 0x01
    3156:	9a 81       	ldd	r25, Y+2	; 0x02
    3158:	00 97       	sbiw	r24, 0x00	; 0
    315a:	69 f1       	breq	.+90     	; 0x31b6 <prvAllocateTCBAndStack+0x8a>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
    315c:	8d 81       	ldd	r24, Y+5	; 0x05
    315e:	9e 81       	ldd	r25, Y+6	; 0x06
    3160:	00 97       	sbiw	r24, 0x00	; 0
    3162:	39 f4       	brne	.+14     	; 0x3172 <prvAllocateTCBAndStack+0x46>
    3164:	8b 81       	ldd	r24, Y+3	; 0x03
    3166:	9c 81       	ldd	r25, Y+4	; 0x04
    3168:	0e 94 7b 08 	call	0x10f6	; 0x10f6 <pvPortMalloc>
    316c:	98 87       	std	Y+8, r25	; 0x08
    316e:	8f 83       	std	Y+7, r24	; 0x07
    3170:	04 c0       	rjmp	.+8      	; 0x317a <prvAllocateTCBAndStack+0x4e>
    3172:	8d 81       	ldd	r24, Y+5	; 0x05
    3174:	9e 81       	ldd	r25, Y+6	; 0x06
    3176:	98 87       	std	Y+8, r25	; 0x08
    3178:	8f 83       	std	Y+7, r24	; 0x07
    317a:	e9 81       	ldd	r30, Y+1	; 0x01
    317c:	fa 81       	ldd	r31, Y+2	; 0x02
    317e:	8f 81       	ldd	r24, Y+7	; 0x07
    3180:	98 85       	ldd	r25, Y+8	; 0x08
    3182:	90 8f       	std	Z+24, r25	; 0x18
    3184:	87 8b       	std	Z+23, r24	; 0x17

		if( pxNewTCB->pxStack == NULL )
    3186:	e9 81       	ldd	r30, Y+1	; 0x01
    3188:	fa 81       	ldd	r31, Y+2	; 0x02
    318a:	87 89       	ldd	r24, Z+23	; 0x17
    318c:	90 8d       	ldd	r25, Z+24	; 0x18
    318e:	00 97       	sbiw	r24, 0x00	; 0
    3190:	39 f4       	brne	.+14     	; 0x31a0 <prvAllocateTCBAndStack+0x74>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
    3192:	89 81       	ldd	r24, Y+1	; 0x01
    3194:	9a 81       	ldd	r25, Y+2	; 0x02
    3196:	0e 94 c1 08 	call	0x1182	; 0x1182 <vPortFree>
			pxNewTCB = NULL;
    319a:	1a 82       	std	Y+2, r1	; 0x02
    319c:	19 82       	std	Y+1, r1	; 0x01
    319e:	0b c0       	rjmp	.+22     	; 0x31b6 <prvAllocateTCBAndStack+0x8a>
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( portSTACK_TYPE ) );
    31a0:	e9 81       	ldd	r30, Y+1	; 0x01
    31a2:	fa 81       	ldd	r31, Y+2	; 0x02
    31a4:	87 89       	ldd	r24, Z+23	; 0x17
    31a6:	90 8d       	ldd	r25, Z+24	; 0x18
    31a8:	2b 81       	ldd	r18, Y+3	; 0x03
    31aa:	3c 81       	ldd	r19, Y+4	; 0x04
    31ac:	65 ea       	ldi	r22, 0xA5	; 165
    31ae:	70 e0       	ldi	r23, 0x00	; 0
    31b0:	a9 01       	movw	r20, r18
    31b2:	0e 94 30 2c 	call	0x5860	; 0x5860 <memset>
		}
	}

	return pxNewTCB;
    31b6:	89 81       	ldd	r24, Y+1	; 0x01
    31b8:	9a 81       	ldd	r25, Y+2	; 0x02
}
    31ba:	28 96       	adiw	r28, 0x08	; 8
    31bc:	0f b6       	in	r0, 0x3f	; 63
    31be:	f8 94       	cli
    31c0:	de bf       	out	0x3e, r29	; 62
    31c2:	0f be       	out	0x3f, r0	; 63
    31c4:	cd bf       	out	0x3d, r28	; 61
    31c6:	cf 91       	pop	r28
    31c8:	df 91       	pop	r29
    31ca:	08 95       	ret

000031cc <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
    31cc:	df 93       	push	r29
    31ce:	cf 93       	push	r28
    31d0:	00 d0       	rcall	.+0      	; 0x31d2 <prvDeleteTCB+0x6>
    31d2:	cd b7       	in	r28, 0x3d	; 61
    31d4:	de b7       	in	r29, 0x3e	; 62
    31d6:	9a 83       	std	Y+2, r25	; 0x02
    31d8:	89 83       	std	Y+1, r24	; 0x01
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
    31da:	e9 81       	ldd	r30, Y+1	; 0x01
    31dc:	fa 81       	ldd	r31, Y+2	; 0x02
    31de:	87 89       	ldd	r24, Z+23	; 0x17
    31e0:	90 8d       	ldd	r25, Z+24	; 0x18
    31e2:	0e 94 c1 08 	call	0x1182	; 0x1182 <vPortFree>
		vPortFree( pxTCB );
    31e6:	89 81       	ldd	r24, Y+1	; 0x01
    31e8:	9a 81       	ldd	r25, Y+2	; 0x02
    31ea:	0e 94 c1 08 	call	0x1182	; 0x1182 <vPortFree>
	}
    31ee:	0f 90       	pop	r0
    31f0:	0f 90       	pop	r0
    31f2:	cf 91       	pop	r28
    31f4:	df 91       	pop	r29
    31f6:	08 95       	ret

000031f8 <xTaskGetCurrentTaskHandle>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )

	xTaskHandle xTaskGetCurrentTaskHandle( void )
	{
    31f8:	df 93       	push	r29
    31fa:	cf 93       	push	r28
    31fc:	00 d0       	rcall	.+0      	; 0x31fe <xTaskGetCurrentTaskHandle+0x6>
    31fe:	cd b7       	in	r28, 0x3d	; 61
    3200:	de b7       	in	r29, 0x3e	; 62
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
    3202:	80 91 58 05 	lds	r24, 0x0558
    3206:	90 91 59 05 	lds	r25, 0x0559
    320a:	9a 83       	std	Y+2, r25	; 0x02
    320c:	89 83       	std	Y+1, r24	; 0x01

		return xReturn;
    320e:	89 81       	ldd	r24, Y+1	; 0x01
    3210:	9a 81       	ldd	r25, Y+2	; 0x02
	}
    3212:	0f 90       	pop	r0
    3214:	0f 90       	pop	r0
    3216:	cf 91       	pop	r28
    3218:	df 91       	pop	r29
    321a:	08 95       	ret

0000321c <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
    321c:	df 93       	push	r29
    321e:	cf 93       	push	r28
    3220:	00 d0       	rcall	.+0      	; 0x3222 <vTaskPriorityInherit+0x6>
    3222:	00 d0       	rcall	.+0      	; 0x3224 <vTaskPriorityInherit+0x8>
    3224:	cd b7       	in	r28, 0x3d	; 61
    3226:	de b7       	in	r29, 0x3e	; 62
    3228:	9c 83       	std	Y+4, r25	; 0x04
    322a:	8b 83       	std	Y+3, r24	; 0x03
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
    322c:	8b 81       	ldd	r24, Y+3	; 0x03
    322e:	9c 81       	ldd	r25, Y+4	; 0x04
    3230:	9a 83       	std	Y+2, r25	; 0x02
    3232:	89 83       	std	Y+1, r24	; 0x01

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
    3234:	e9 81       	ldd	r30, Y+1	; 0x01
    3236:	fa 81       	ldd	r31, Y+2	; 0x02
    3238:	96 89       	ldd	r25, Z+22	; 0x16
    323a:	e0 91 58 05 	lds	r30, 0x0558
    323e:	f0 91 59 05 	lds	r31, 0x0559
    3242:	86 89       	ldd	r24, Z+22	; 0x16
    3244:	98 17       	cp	r25, r24
    3246:	08 f0       	brcs	.+2      	; 0x324a <vTaskPriorityInherit+0x2e>
    3248:	62 c0       	rjmp	.+196    	; 0x330e <vTaskPriorityInherit+0xf2>
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
    324a:	e0 91 58 05 	lds	r30, 0x0558
    324e:	f0 91 59 05 	lds	r31, 0x0559
    3252:	86 89       	ldd	r24, Z+22	; 0x16
    3254:	28 2f       	mov	r18, r24
    3256:	30 e0       	ldi	r19, 0x00	; 0
    3258:	85 e0       	ldi	r24, 0x05	; 5
    325a:	90 e0       	ldi	r25, 0x00	; 0
    325c:	82 1b       	sub	r24, r18
    325e:	93 0b       	sbc	r25, r19
    3260:	e9 81       	ldd	r30, Y+1	; 0x01
    3262:	fa 81       	ldd	r31, Y+2	; 0x02
    3264:	95 87       	std	Z+13, r25	; 0x0d
    3266:	84 87       	std	Z+12, r24	; 0x0c

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
    3268:	e9 81       	ldd	r30, Y+1	; 0x01
    326a:	fa 81       	ldd	r31, Y+2	; 0x02
    326c:	42 85       	ldd	r20, Z+10	; 0x0a
    326e:	53 85       	ldd	r21, Z+11	; 0x0b
    3270:	e9 81       	ldd	r30, Y+1	; 0x01
    3272:	fa 81       	ldd	r31, Y+2	; 0x02
    3274:	86 89       	ldd	r24, Z+22	; 0x16
    3276:	28 2f       	mov	r18, r24
    3278:	30 e0       	ldi	r19, 0x00	; 0
    327a:	c9 01       	movw	r24, r18
    327c:	88 0f       	add	r24, r24
    327e:	99 1f       	adc	r25, r25
    3280:	88 0f       	add	r24, r24
    3282:	99 1f       	adc	r25, r25
    3284:	88 0f       	add	r24, r24
    3286:	99 1f       	adc	r25, r25
    3288:	82 0f       	add	r24, r18
    328a:	93 1f       	adc	r25, r19
    328c:	8a 59       	subi	r24, 0x9A	; 154
    328e:	9a 4f       	sbci	r25, 0xFA	; 250
    3290:	48 17       	cp	r20, r24
    3292:	59 07       	cpc	r21, r25
    3294:	a1 f5       	brne	.+104    	; 0x32fe <vTaskPriorityInherit+0xe2>
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
    3296:	89 81       	ldd	r24, Y+1	; 0x01
    3298:	9a 81       	ldd	r25, Y+2	; 0x02
    329a:	02 96       	adiw	r24, 0x02	; 2
    329c:	0e 94 d9 09 	call	0x13b2	; 0x13b2 <vListRemove>

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    32a0:	e0 91 58 05 	lds	r30, 0x0558
    32a4:	f0 91 59 05 	lds	r31, 0x0559
    32a8:	86 89       	ldd	r24, Z+22	; 0x16
    32aa:	e9 81       	ldd	r30, Y+1	; 0x01
    32ac:	fa 81       	ldd	r31, Y+2	; 0x02
    32ae:	86 8b       	std	Z+22, r24	; 0x16
				prvAddTaskToReadyQueue( pxTCB );
    32b0:	e9 81       	ldd	r30, Y+1	; 0x01
    32b2:	fa 81       	ldd	r31, Y+2	; 0x02
    32b4:	96 89       	ldd	r25, Z+22	; 0x16
    32b6:	80 91 5f 05 	lds	r24, 0x055F
    32ba:	89 17       	cp	r24, r25
    32bc:	28 f4       	brcc	.+10     	; 0x32c8 <vTaskPriorityInherit+0xac>
    32be:	e9 81       	ldd	r30, Y+1	; 0x01
    32c0:	fa 81       	ldd	r31, Y+2	; 0x02
    32c2:	86 89       	ldd	r24, Z+22	; 0x16
    32c4:	80 93 5f 05 	sts	0x055F, r24
    32c8:	e9 81       	ldd	r30, Y+1	; 0x01
    32ca:	fa 81       	ldd	r31, Y+2	; 0x02
    32cc:	86 89       	ldd	r24, Z+22	; 0x16
    32ce:	28 2f       	mov	r18, r24
    32d0:	30 e0       	ldi	r19, 0x00	; 0
    32d2:	c9 01       	movw	r24, r18
    32d4:	88 0f       	add	r24, r24
    32d6:	99 1f       	adc	r25, r25
    32d8:	88 0f       	add	r24, r24
    32da:	99 1f       	adc	r25, r25
    32dc:	88 0f       	add	r24, r24
    32de:	99 1f       	adc	r25, r25
    32e0:	82 0f       	add	r24, r18
    32e2:	93 1f       	adc	r25, r19
    32e4:	ac 01       	movw	r20, r24
    32e6:	4a 59       	subi	r20, 0x9A	; 154
    32e8:	5a 4f       	sbci	r21, 0xFA	; 250
    32ea:	89 81       	ldd	r24, Y+1	; 0x01
    32ec:	9a 81       	ldd	r25, Y+2	; 0x02
    32ee:	9c 01       	movw	r18, r24
    32f0:	2e 5f       	subi	r18, 0xFE	; 254
    32f2:	3f 4f       	sbci	r19, 0xFF	; 255
    32f4:	ca 01       	movw	r24, r20
    32f6:	b9 01       	movw	r22, r18
    32f8:	0e 94 21 09 	call	0x1242	; 0x1242 <vListInsertEnd>
    32fc:	08 c0       	rjmp	.+16     	; 0x330e <vTaskPriorityInherit+0xf2>
			}
			else
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    32fe:	e0 91 58 05 	lds	r30, 0x0558
    3302:	f0 91 59 05 	lds	r31, 0x0559
    3306:	86 89       	ldd	r24, Z+22	; 0x16
    3308:	e9 81       	ldd	r30, Y+1	; 0x01
    330a:	fa 81       	ldd	r31, Y+2	; 0x02
    330c:	86 8b       	std	Z+22, r24	; 0x16
			}
		}
	}
    330e:	0f 90       	pop	r0
    3310:	0f 90       	pop	r0
    3312:	0f 90       	pop	r0
    3314:	0f 90       	pop	r0
    3316:	cf 91       	pop	r28
    3318:	df 91       	pop	r29
    331a:	08 95       	ret

0000331c <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
    331c:	df 93       	push	r29
    331e:	cf 93       	push	r28
    3320:	00 d0       	rcall	.+0      	; 0x3322 <vTaskPriorityDisinherit+0x6>
    3322:	00 d0       	rcall	.+0      	; 0x3324 <vTaskPriorityDisinherit+0x8>
    3324:	cd b7       	in	r28, 0x3d	; 61
    3326:	de b7       	in	r29, 0x3e	; 62
    3328:	9c 83       	std	Y+4, r25	; 0x04
    332a:	8b 83       	std	Y+3, r24	; 0x03
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
    332c:	8b 81       	ldd	r24, Y+3	; 0x03
    332e:	9c 81       	ldd	r25, Y+4	; 0x04
    3330:	9a 83       	std	Y+2, r25	; 0x02
    3332:	89 83       	std	Y+1, r24	; 0x01

		if( pxMutexHolder != NULL )
    3334:	8b 81       	ldd	r24, Y+3	; 0x03
    3336:	9c 81       	ldd	r25, Y+4	; 0x04
    3338:	00 97       	sbiw	r24, 0x00	; 0
    333a:	09 f4       	brne	.+2      	; 0x333e <vTaskPriorityDisinherit+0x22>
    333c:	47 c0       	rjmp	.+142    	; 0x33cc <vTaskPriorityDisinherit+0xb0>
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    333e:	e9 81       	ldd	r30, Y+1	; 0x01
    3340:	fa 81       	ldd	r31, Y+2	; 0x02
    3342:	96 89       	ldd	r25, Z+22	; 0x16
    3344:	e9 81       	ldd	r30, Y+1	; 0x01
    3346:	fa 81       	ldd	r31, Y+2	; 0x02
    3348:	81 a1       	ldd	r24, Z+33	; 0x21
    334a:	98 17       	cp	r25, r24
    334c:	09 f4       	brne	.+2      	; 0x3350 <vTaskPriorityDisinherit+0x34>
    334e:	3e c0       	rjmp	.+124    	; 0x33cc <vTaskPriorityDisinherit+0xb0>
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
    3350:	89 81       	ldd	r24, Y+1	; 0x01
    3352:	9a 81       	ldd	r25, Y+2	; 0x02
    3354:	02 96       	adiw	r24, 0x02	; 2
    3356:	0e 94 d9 09 	call	0x13b2	; 0x13b2 <vListRemove>

				/* Disinherit the priority before adding ourselves into the new
				ready list. */
				pxTCB->uxPriority = pxTCB->uxBasePriority;
    335a:	e9 81       	ldd	r30, Y+1	; 0x01
    335c:	fa 81       	ldd	r31, Y+2	; 0x02
    335e:	81 a1       	ldd	r24, Z+33	; 0x21
    3360:	e9 81       	ldd	r30, Y+1	; 0x01
    3362:	fa 81       	ldd	r31, Y+2	; 0x02
    3364:	86 8b       	std	Z+22, r24	; 0x16
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
    3366:	e9 81       	ldd	r30, Y+1	; 0x01
    3368:	fa 81       	ldd	r31, Y+2	; 0x02
    336a:	86 89       	ldd	r24, Z+22	; 0x16
    336c:	28 2f       	mov	r18, r24
    336e:	30 e0       	ldi	r19, 0x00	; 0
    3370:	85 e0       	ldi	r24, 0x05	; 5
    3372:	90 e0       	ldi	r25, 0x00	; 0
    3374:	82 1b       	sub	r24, r18
    3376:	93 0b       	sbc	r25, r19
    3378:	e9 81       	ldd	r30, Y+1	; 0x01
    337a:	fa 81       	ldd	r31, Y+2	; 0x02
    337c:	95 87       	std	Z+13, r25	; 0x0d
    337e:	84 87       	std	Z+12, r24	; 0x0c
				prvAddTaskToReadyQueue( pxTCB );
    3380:	e9 81       	ldd	r30, Y+1	; 0x01
    3382:	fa 81       	ldd	r31, Y+2	; 0x02
    3384:	96 89       	ldd	r25, Z+22	; 0x16
    3386:	80 91 5f 05 	lds	r24, 0x055F
    338a:	89 17       	cp	r24, r25
    338c:	28 f4       	brcc	.+10     	; 0x3398 <vTaskPriorityDisinherit+0x7c>
    338e:	e9 81       	ldd	r30, Y+1	; 0x01
    3390:	fa 81       	ldd	r31, Y+2	; 0x02
    3392:	86 89       	ldd	r24, Z+22	; 0x16
    3394:	80 93 5f 05 	sts	0x055F, r24
    3398:	e9 81       	ldd	r30, Y+1	; 0x01
    339a:	fa 81       	ldd	r31, Y+2	; 0x02
    339c:	86 89       	ldd	r24, Z+22	; 0x16
    339e:	28 2f       	mov	r18, r24
    33a0:	30 e0       	ldi	r19, 0x00	; 0
    33a2:	c9 01       	movw	r24, r18
    33a4:	88 0f       	add	r24, r24
    33a6:	99 1f       	adc	r25, r25
    33a8:	88 0f       	add	r24, r24
    33aa:	99 1f       	adc	r25, r25
    33ac:	88 0f       	add	r24, r24
    33ae:	99 1f       	adc	r25, r25
    33b0:	82 0f       	add	r24, r18
    33b2:	93 1f       	adc	r25, r19
    33b4:	ac 01       	movw	r20, r24
    33b6:	4a 59       	subi	r20, 0x9A	; 154
    33b8:	5a 4f       	sbci	r21, 0xFA	; 250
    33ba:	89 81       	ldd	r24, Y+1	; 0x01
    33bc:	9a 81       	ldd	r25, Y+2	; 0x02
    33be:	9c 01       	movw	r18, r24
    33c0:	2e 5f       	subi	r18, 0xFE	; 254
    33c2:	3f 4f       	sbci	r19, 0xFF	; 255
    33c4:	ca 01       	movw	r24, r20
    33c6:	b9 01       	movw	r22, r18
    33c8:	0e 94 21 09 	call	0x1242	; 0x1242 <vListInsertEnd>
			}
		}
	}
    33cc:	0f 90       	pop	r0
    33ce:	0f 90       	pop	r0
    33d0:	0f 90       	pop	r0
    33d2:	0f 90       	pop	r0
    33d4:	cf 91       	pop	r28
    33d6:	df 91       	pop	r29
    33d8:	08 95       	ret

000033da <DIO_vSetPinDirection>:
 * set the direction of PinX as input with pull up resistor or without pull up resistor or as OUTPUT
 * input: portX,pin_number
 * OUTPUT: Nothing
 **************************************************************************************************/
void DIO_vSetPinDirection(uint8 Copy_u8PORT, uint8 Copy_u8PinNumber,
		uint8 copy_u8state) {
    33da:	df 93       	push	r29
    33dc:	cf 93       	push	r28
    33de:	cd b7       	in	r28, 0x3d	; 61
    33e0:	de b7       	in	r29, 0x3e	; 62
    33e2:	2d 97       	sbiw	r28, 0x0d	; 13
    33e4:	0f b6       	in	r0, 0x3f	; 63
    33e6:	f8 94       	cli
    33e8:	de bf       	out	0x3e, r29	; 62
    33ea:	0f be       	out	0x3f, r0	; 63
    33ec:	cd bf       	out	0x3d, r28	; 61
    33ee:	89 83       	std	Y+1, r24	; 0x01
    33f0:	6a 83       	std	Y+2, r22	; 0x02
    33f2:	4b 83       	std	Y+3, r20	; 0x03
	switch (Copy_u8PORT) {
    33f4:	89 81       	ldd	r24, Y+1	; 0x01
    33f6:	28 2f       	mov	r18, r24
    33f8:	30 e0       	ldi	r19, 0x00	; 0
    33fa:	3d 87       	std	Y+13, r19	; 0x0d
    33fc:	2c 87       	std	Y+12, r18	; 0x0c
    33fe:	8c 85       	ldd	r24, Y+12	; 0x0c
    3400:	9d 85       	ldd	r25, Y+13	; 0x0d
    3402:	81 30       	cpi	r24, 0x01	; 1
    3404:	91 05       	cpc	r25, r1
    3406:	09 f4       	brne	.+2      	; 0x340a <DIO_vSetPinDirection+0x30>
    3408:	8f c0       	rjmp	.+286    	; 0x3528 <DIO_vSetPinDirection+0x14e>
    340a:	2c 85       	ldd	r18, Y+12	; 0x0c
    340c:	3d 85       	ldd	r19, Y+13	; 0x0d
    340e:	22 30       	cpi	r18, 0x02	; 2
    3410:	31 05       	cpc	r19, r1
    3412:	2c f4       	brge	.+10     	; 0x341e <DIO_vSetPinDirection+0x44>
    3414:	8c 85       	ldd	r24, Y+12	; 0x0c
    3416:	9d 85       	ldd	r25, Y+13	; 0x0d
    3418:	00 97       	sbiw	r24, 0x00	; 0
    341a:	71 f0       	breq	.+28     	; 0x3438 <DIO_vSetPinDirection+0x5e>
    341c:	ec c1       	rjmp	.+984    	; 0x37f6 <DIO_vSetPinDirection+0x41c>
    341e:	2c 85       	ldd	r18, Y+12	; 0x0c
    3420:	3d 85       	ldd	r19, Y+13	; 0x0d
    3422:	22 30       	cpi	r18, 0x02	; 2
    3424:	31 05       	cpc	r19, r1
    3426:	09 f4       	brne	.+2      	; 0x342a <DIO_vSetPinDirection+0x50>
    3428:	f7 c0       	rjmp	.+494    	; 0x3618 <DIO_vSetPinDirection+0x23e>
    342a:	8c 85       	ldd	r24, Y+12	; 0x0c
    342c:	9d 85       	ldd	r25, Y+13	; 0x0d
    342e:	83 30       	cpi	r24, 0x03	; 3
    3430:	91 05       	cpc	r25, r1
    3432:	09 f4       	brne	.+2      	; 0x3436 <DIO_vSetPinDirection+0x5c>
    3434:	69 c1       	rjmp	.+722    	; 0x3708 <DIO_vSetPinDirection+0x32e>
    3436:	df c1       	rjmp	.+958    	; 0x37f6 <DIO_vSetPinDirection+0x41c>
	case PORT_A:
		switch (copy_u8state) {
    3438:	8b 81       	ldd	r24, Y+3	; 0x03
    343a:	28 2f       	mov	r18, r24
    343c:	30 e0       	ldi	r19, 0x00	; 0
    343e:	3b 87       	std	Y+11, r19	; 0x0b
    3440:	2a 87       	std	Y+10, r18	; 0x0a
    3442:	8a 85       	ldd	r24, Y+10	; 0x0a
    3444:	9b 85       	ldd	r25, Y+11	; 0x0b
    3446:	81 30       	cpi	r24, 0x01	; 1
    3448:	91 05       	cpc	r25, r1
    344a:	09 f4       	brne	.+2      	; 0x344e <DIO_vSetPinDirection+0x74>
    344c:	45 c0       	rjmp	.+138    	; 0x34d8 <DIO_vSetPinDirection+0xfe>
    344e:	2a 85       	ldd	r18, Y+10	; 0x0a
    3450:	3b 85       	ldd	r19, Y+11	; 0x0b
    3452:	22 30       	cpi	r18, 0x02	; 2
    3454:	31 05       	cpc	r19, r1
    3456:	29 f0       	breq	.+10     	; 0x3462 <DIO_vSetPinDirection+0x88>
    3458:	8a 85       	ldd	r24, Y+10	; 0x0a
    345a:	9b 85       	ldd	r25, Y+11	; 0x0b
    345c:	00 97       	sbiw	r24, 0x00	; 0
    345e:	a9 f0       	breq	.+42     	; 0x348a <DIO_vSetPinDirection+0xb0>
    3460:	ca c1       	rjmp	.+916    	; 0x37f6 <DIO_vSetPinDirection+0x41c>
		case OUTPUT:
			setbit(DDRA, Copy_u8PinNumber);
    3462:	aa e3       	ldi	r26, 0x3A	; 58
    3464:	b0 e0       	ldi	r27, 0x00	; 0
    3466:	ea e3       	ldi	r30, 0x3A	; 58
    3468:	f0 e0       	ldi	r31, 0x00	; 0
    346a:	80 81       	ld	r24, Z
    346c:	48 2f       	mov	r20, r24
    346e:	8a 81       	ldd	r24, Y+2	; 0x02
    3470:	28 2f       	mov	r18, r24
    3472:	30 e0       	ldi	r19, 0x00	; 0
    3474:	81 e0       	ldi	r24, 0x01	; 1
    3476:	90 e0       	ldi	r25, 0x00	; 0
    3478:	02 2e       	mov	r0, r18
    347a:	02 c0       	rjmp	.+4      	; 0x3480 <DIO_vSetPinDirection+0xa6>
    347c:	88 0f       	add	r24, r24
    347e:	99 1f       	adc	r25, r25
    3480:	0a 94       	dec	r0
    3482:	e2 f7       	brpl	.-8      	; 0x347c <DIO_vSetPinDirection+0xa2>
    3484:	84 2b       	or	r24, r20
    3486:	8c 93       	st	X, r24
    3488:	b6 c1       	rjmp	.+876    	; 0x37f6 <DIO_vSetPinDirection+0x41c>
			break;
		case IPWR:
			clearbit(DDRA, Copy_u8PinNumber);
    348a:	aa e3       	ldi	r26, 0x3A	; 58
    348c:	b0 e0       	ldi	r27, 0x00	; 0
    348e:	ea e3       	ldi	r30, 0x3A	; 58
    3490:	f0 e0       	ldi	r31, 0x00	; 0
    3492:	80 81       	ld	r24, Z
    3494:	48 2f       	mov	r20, r24
    3496:	8a 81       	ldd	r24, Y+2	; 0x02
    3498:	28 2f       	mov	r18, r24
    349a:	30 e0       	ldi	r19, 0x00	; 0
    349c:	81 e0       	ldi	r24, 0x01	; 1
    349e:	90 e0       	ldi	r25, 0x00	; 0
    34a0:	02 c0       	rjmp	.+4      	; 0x34a6 <DIO_vSetPinDirection+0xcc>
    34a2:	88 0f       	add	r24, r24
    34a4:	99 1f       	adc	r25, r25
    34a6:	2a 95       	dec	r18
    34a8:	e2 f7       	brpl	.-8      	; 0x34a2 <DIO_vSetPinDirection+0xc8>
    34aa:	80 95       	com	r24
    34ac:	84 23       	and	r24, r20
    34ae:	8c 93       	st	X, r24
			setbit(PORTA, Copy_u8PinNumber);
    34b0:	ab e3       	ldi	r26, 0x3B	; 59
    34b2:	b0 e0       	ldi	r27, 0x00	; 0
    34b4:	eb e3       	ldi	r30, 0x3B	; 59
    34b6:	f0 e0       	ldi	r31, 0x00	; 0
    34b8:	80 81       	ld	r24, Z
    34ba:	48 2f       	mov	r20, r24
    34bc:	8a 81       	ldd	r24, Y+2	; 0x02
    34be:	28 2f       	mov	r18, r24
    34c0:	30 e0       	ldi	r19, 0x00	; 0
    34c2:	81 e0       	ldi	r24, 0x01	; 1
    34c4:	90 e0       	ldi	r25, 0x00	; 0
    34c6:	02 2e       	mov	r0, r18
    34c8:	02 c0       	rjmp	.+4      	; 0x34ce <DIO_vSetPinDirection+0xf4>
    34ca:	88 0f       	add	r24, r24
    34cc:	99 1f       	adc	r25, r25
    34ce:	0a 94       	dec	r0
    34d0:	e2 f7       	brpl	.-8      	; 0x34ca <DIO_vSetPinDirection+0xf0>
    34d2:	84 2b       	or	r24, r20
    34d4:	8c 93       	st	X, r24
    34d6:	8f c1       	rjmp	.+798    	; 0x37f6 <DIO_vSetPinDirection+0x41c>
			break;
		case IPWOR:
			clearbit(DDRA, Copy_u8PinNumber);
    34d8:	aa e3       	ldi	r26, 0x3A	; 58
    34da:	b0 e0       	ldi	r27, 0x00	; 0
    34dc:	ea e3       	ldi	r30, 0x3A	; 58
    34de:	f0 e0       	ldi	r31, 0x00	; 0
    34e0:	80 81       	ld	r24, Z
    34e2:	48 2f       	mov	r20, r24
    34e4:	8a 81       	ldd	r24, Y+2	; 0x02
    34e6:	28 2f       	mov	r18, r24
    34e8:	30 e0       	ldi	r19, 0x00	; 0
    34ea:	81 e0       	ldi	r24, 0x01	; 1
    34ec:	90 e0       	ldi	r25, 0x00	; 0
    34ee:	02 c0       	rjmp	.+4      	; 0x34f4 <DIO_vSetPinDirection+0x11a>
    34f0:	88 0f       	add	r24, r24
    34f2:	99 1f       	adc	r25, r25
    34f4:	2a 95       	dec	r18
    34f6:	e2 f7       	brpl	.-8      	; 0x34f0 <DIO_vSetPinDirection+0x116>
    34f8:	80 95       	com	r24
    34fa:	84 23       	and	r24, r20
    34fc:	8c 93       	st	X, r24
			clearbit(PORTA, Copy_u8PinNumber);
    34fe:	ab e3       	ldi	r26, 0x3B	; 59
    3500:	b0 e0       	ldi	r27, 0x00	; 0
    3502:	eb e3       	ldi	r30, 0x3B	; 59
    3504:	f0 e0       	ldi	r31, 0x00	; 0
    3506:	80 81       	ld	r24, Z
    3508:	48 2f       	mov	r20, r24
    350a:	8a 81       	ldd	r24, Y+2	; 0x02
    350c:	28 2f       	mov	r18, r24
    350e:	30 e0       	ldi	r19, 0x00	; 0
    3510:	81 e0       	ldi	r24, 0x01	; 1
    3512:	90 e0       	ldi	r25, 0x00	; 0
    3514:	02 2e       	mov	r0, r18
    3516:	02 c0       	rjmp	.+4      	; 0x351c <DIO_vSetPinDirection+0x142>
    3518:	88 0f       	add	r24, r24
    351a:	99 1f       	adc	r25, r25
    351c:	0a 94       	dec	r0
    351e:	e2 f7       	brpl	.-8      	; 0x3518 <DIO_vSetPinDirection+0x13e>
    3520:	80 95       	com	r24
    3522:	84 23       	and	r24, r20
    3524:	8c 93       	st	X, r24
    3526:	67 c1       	rjmp	.+718    	; 0x37f6 <DIO_vSetPinDirection+0x41c>
			break;
		}
		break;
	case PORT_B:
		switch (copy_u8state) {
    3528:	8b 81       	ldd	r24, Y+3	; 0x03
    352a:	28 2f       	mov	r18, r24
    352c:	30 e0       	ldi	r19, 0x00	; 0
    352e:	39 87       	std	Y+9, r19	; 0x09
    3530:	28 87       	std	Y+8, r18	; 0x08
    3532:	88 85       	ldd	r24, Y+8	; 0x08
    3534:	99 85       	ldd	r25, Y+9	; 0x09
    3536:	81 30       	cpi	r24, 0x01	; 1
    3538:	91 05       	cpc	r25, r1
    353a:	09 f4       	brne	.+2      	; 0x353e <DIO_vSetPinDirection+0x164>
    353c:	45 c0       	rjmp	.+138    	; 0x35c8 <DIO_vSetPinDirection+0x1ee>
    353e:	28 85       	ldd	r18, Y+8	; 0x08
    3540:	39 85       	ldd	r19, Y+9	; 0x09
    3542:	22 30       	cpi	r18, 0x02	; 2
    3544:	31 05       	cpc	r19, r1
    3546:	29 f0       	breq	.+10     	; 0x3552 <DIO_vSetPinDirection+0x178>
    3548:	88 85       	ldd	r24, Y+8	; 0x08
    354a:	99 85       	ldd	r25, Y+9	; 0x09
    354c:	00 97       	sbiw	r24, 0x00	; 0
    354e:	a9 f0       	breq	.+42     	; 0x357a <DIO_vSetPinDirection+0x1a0>
    3550:	52 c1       	rjmp	.+676    	; 0x37f6 <DIO_vSetPinDirection+0x41c>
		case OUTPUT:
			setbit(DDRB, Copy_u8PinNumber);
    3552:	a7 e3       	ldi	r26, 0x37	; 55
    3554:	b0 e0       	ldi	r27, 0x00	; 0
    3556:	e7 e3       	ldi	r30, 0x37	; 55
    3558:	f0 e0       	ldi	r31, 0x00	; 0
    355a:	80 81       	ld	r24, Z
    355c:	48 2f       	mov	r20, r24
    355e:	8a 81       	ldd	r24, Y+2	; 0x02
    3560:	28 2f       	mov	r18, r24
    3562:	30 e0       	ldi	r19, 0x00	; 0
    3564:	81 e0       	ldi	r24, 0x01	; 1
    3566:	90 e0       	ldi	r25, 0x00	; 0
    3568:	02 2e       	mov	r0, r18
    356a:	02 c0       	rjmp	.+4      	; 0x3570 <DIO_vSetPinDirection+0x196>
    356c:	88 0f       	add	r24, r24
    356e:	99 1f       	adc	r25, r25
    3570:	0a 94       	dec	r0
    3572:	e2 f7       	brpl	.-8      	; 0x356c <DIO_vSetPinDirection+0x192>
    3574:	84 2b       	or	r24, r20
    3576:	8c 93       	st	X, r24
    3578:	3e c1       	rjmp	.+636    	; 0x37f6 <DIO_vSetPinDirection+0x41c>
			break;
		case IPWR:
			clearbit(DDRB, Copy_u8PinNumber);
    357a:	a7 e3       	ldi	r26, 0x37	; 55
    357c:	b0 e0       	ldi	r27, 0x00	; 0
    357e:	e7 e3       	ldi	r30, 0x37	; 55
    3580:	f0 e0       	ldi	r31, 0x00	; 0
    3582:	80 81       	ld	r24, Z
    3584:	48 2f       	mov	r20, r24
    3586:	8a 81       	ldd	r24, Y+2	; 0x02
    3588:	28 2f       	mov	r18, r24
    358a:	30 e0       	ldi	r19, 0x00	; 0
    358c:	81 e0       	ldi	r24, 0x01	; 1
    358e:	90 e0       	ldi	r25, 0x00	; 0
    3590:	02 c0       	rjmp	.+4      	; 0x3596 <DIO_vSetPinDirection+0x1bc>
    3592:	88 0f       	add	r24, r24
    3594:	99 1f       	adc	r25, r25
    3596:	2a 95       	dec	r18
    3598:	e2 f7       	brpl	.-8      	; 0x3592 <DIO_vSetPinDirection+0x1b8>
    359a:	80 95       	com	r24
    359c:	84 23       	and	r24, r20
    359e:	8c 93       	st	X, r24
			setbit(PORTB, Copy_u8PinNumber);
    35a0:	a8 e3       	ldi	r26, 0x38	; 56
    35a2:	b0 e0       	ldi	r27, 0x00	; 0
    35a4:	e8 e3       	ldi	r30, 0x38	; 56
    35a6:	f0 e0       	ldi	r31, 0x00	; 0
    35a8:	80 81       	ld	r24, Z
    35aa:	48 2f       	mov	r20, r24
    35ac:	8a 81       	ldd	r24, Y+2	; 0x02
    35ae:	28 2f       	mov	r18, r24
    35b0:	30 e0       	ldi	r19, 0x00	; 0
    35b2:	81 e0       	ldi	r24, 0x01	; 1
    35b4:	90 e0       	ldi	r25, 0x00	; 0
    35b6:	02 2e       	mov	r0, r18
    35b8:	02 c0       	rjmp	.+4      	; 0x35be <DIO_vSetPinDirection+0x1e4>
    35ba:	88 0f       	add	r24, r24
    35bc:	99 1f       	adc	r25, r25
    35be:	0a 94       	dec	r0
    35c0:	e2 f7       	brpl	.-8      	; 0x35ba <DIO_vSetPinDirection+0x1e0>
    35c2:	84 2b       	or	r24, r20
    35c4:	8c 93       	st	X, r24
    35c6:	17 c1       	rjmp	.+558    	; 0x37f6 <DIO_vSetPinDirection+0x41c>
			break;
		case IPWOR:
			clearbit(DDRB, Copy_u8PinNumber);
    35c8:	a7 e3       	ldi	r26, 0x37	; 55
    35ca:	b0 e0       	ldi	r27, 0x00	; 0
    35cc:	e7 e3       	ldi	r30, 0x37	; 55
    35ce:	f0 e0       	ldi	r31, 0x00	; 0
    35d0:	80 81       	ld	r24, Z
    35d2:	48 2f       	mov	r20, r24
    35d4:	8a 81       	ldd	r24, Y+2	; 0x02
    35d6:	28 2f       	mov	r18, r24
    35d8:	30 e0       	ldi	r19, 0x00	; 0
    35da:	81 e0       	ldi	r24, 0x01	; 1
    35dc:	90 e0       	ldi	r25, 0x00	; 0
    35de:	02 c0       	rjmp	.+4      	; 0x35e4 <DIO_vSetPinDirection+0x20a>
    35e0:	88 0f       	add	r24, r24
    35e2:	99 1f       	adc	r25, r25
    35e4:	2a 95       	dec	r18
    35e6:	e2 f7       	brpl	.-8      	; 0x35e0 <DIO_vSetPinDirection+0x206>
    35e8:	80 95       	com	r24
    35ea:	84 23       	and	r24, r20
    35ec:	8c 93       	st	X, r24
			clearbit(PORTB, Copy_u8PinNumber);
    35ee:	a8 e3       	ldi	r26, 0x38	; 56
    35f0:	b0 e0       	ldi	r27, 0x00	; 0
    35f2:	e8 e3       	ldi	r30, 0x38	; 56
    35f4:	f0 e0       	ldi	r31, 0x00	; 0
    35f6:	80 81       	ld	r24, Z
    35f8:	48 2f       	mov	r20, r24
    35fa:	8a 81       	ldd	r24, Y+2	; 0x02
    35fc:	28 2f       	mov	r18, r24
    35fe:	30 e0       	ldi	r19, 0x00	; 0
    3600:	81 e0       	ldi	r24, 0x01	; 1
    3602:	90 e0       	ldi	r25, 0x00	; 0
    3604:	02 2e       	mov	r0, r18
    3606:	02 c0       	rjmp	.+4      	; 0x360c <DIO_vSetPinDirection+0x232>
    3608:	88 0f       	add	r24, r24
    360a:	99 1f       	adc	r25, r25
    360c:	0a 94       	dec	r0
    360e:	e2 f7       	brpl	.-8      	; 0x3608 <DIO_vSetPinDirection+0x22e>
    3610:	80 95       	com	r24
    3612:	84 23       	and	r24, r20
    3614:	8c 93       	st	X, r24
    3616:	ef c0       	rjmp	.+478    	; 0x37f6 <DIO_vSetPinDirection+0x41c>
			break;
		}
		break;
	case PORT_C:
		switch (copy_u8state) {
    3618:	8b 81       	ldd	r24, Y+3	; 0x03
    361a:	28 2f       	mov	r18, r24
    361c:	30 e0       	ldi	r19, 0x00	; 0
    361e:	3f 83       	std	Y+7, r19	; 0x07
    3620:	2e 83       	std	Y+6, r18	; 0x06
    3622:	8e 81       	ldd	r24, Y+6	; 0x06
    3624:	9f 81       	ldd	r25, Y+7	; 0x07
    3626:	81 30       	cpi	r24, 0x01	; 1
    3628:	91 05       	cpc	r25, r1
    362a:	09 f4       	brne	.+2      	; 0x362e <DIO_vSetPinDirection+0x254>
    362c:	45 c0       	rjmp	.+138    	; 0x36b8 <DIO_vSetPinDirection+0x2de>
    362e:	2e 81       	ldd	r18, Y+6	; 0x06
    3630:	3f 81       	ldd	r19, Y+7	; 0x07
    3632:	22 30       	cpi	r18, 0x02	; 2
    3634:	31 05       	cpc	r19, r1
    3636:	29 f0       	breq	.+10     	; 0x3642 <DIO_vSetPinDirection+0x268>
    3638:	8e 81       	ldd	r24, Y+6	; 0x06
    363a:	9f 81       	ldd	r25, Y+7	; 0x07
    363c:	00 97       	sbiw	r24, 0x00	; 0
    363e:	a9 f0       	breq	.+42     	; 0x366a <DIO_vSetPinDirection+0x290>
    3640:	da c0       	rjmp	.+436    	; 0x37f6 <DIO_vSetPinDirection+0x41c>
		case OUTPUT:
			setbit(DDRC, Copy_u8PinNumber);
    3642:	a4 e3       	ldi	r26, 0x34	; 52
    3644:	b0 e0       	ldi	r27, 0x00	; 0
    3646:	e4 e3       	ldi	r30, 0x34	; 52
    3648:	f0 e0       	ldi	r31, 0x00	; 0
    364a:	80 81       	ld	r24, Z
    364c:	48 2f       	mov	r20, r24
    364e:	8a 81       	ldd	r24, Y+2	; 0x02
    3650:	28 2f       	mov	r18, r24
    3652:	30 e0       	ldi	r19, 0x00	; 0
    3654:	81 e0       	ldi	r24, 0x01	; 1
    3656:	90 e0       	ldi	r25, 0x00	; 0
    3658:	02 2e       	mov	r0, r18
    365a:	02 c0       	rjmp	.+4      	; 0x3660 <DIO_vSetPinDirection+0x286>
    365c:	88 0f       	add	r24, r24
    365e:	99 1f       	adc	r25, r25
    3660:	0a 94       	dec	r0
    3662:	e2 f7       	brpl	.-8      	; 0x365c <DIO_vSetPinDirection+0x282>
    3664:	84 2b       	or	r24, r20
    3666:	8c 93       	st	X, r24
    3668:	c6 c0       	rjmp	.+396    	; 0x37f6 <DIO_vSetPinDirection+0x41c>
			break;
		case IPWR:
			clearbit(DDRC, Copy_u8PinNumber);
    366a:	a4 e3       	ldi	r26, 0x34	; 52
    366c:	b0 e0       	ldi	r27, 0x00	; 0
    366e:	e4 e3       	ldi	r30, 0x34	; 52
    3670:	f0 e0       	ldi	r31, 0x00	; 0
    3672:	80 81       	ld	r24, Z
    3674:	48 2f       	mov	r20, r24
    3676:	8a 81       	ldd	r24, Y+2	; 0x02
    3678:	28 2f       	mov	r18, r24
    367a:	30 e0       	ldi	r19, 0x00	; 0
    367c:	81 e0       	ldi	r24, 0x01	; 1
    367e:	90 e0       	ldi	r25, 0x00	; 0
    3680:	02 c0       	rjmp	.+4      	; 0x3686 <DIO_vSetPinDirection+0x2ac>
    3682:	88 0f       	add	r24, r24
    3684:	99 1f       	adc	r25, r25
    3686:	2a 95       	dec	r18
    3688:	e2 f7       	brpl	.-8      	; 0x3682 <DIO_vSetPinDirection+0x2a8>
    368a:	80 95       	com	r24
    368c:	84 23       	and	r24, r20
    368e:	8c 93       	st	X, r24
			setbit(PORTC, Copy_u8PinNumber);
    3690:	a5 e3       	ldi	r26, 0x35	; 53
    3692:	b0 e0       	ldi	r27, 0x00	; 0
    3694:	e5 e3       	ldi	r30, 0x35	; 53
    3696:	f0 e0       	ldi	r31, 0x00	; 0
    3698:	80 81       	ld	r24, Z
    369a:	48 2f       	mov	r20, r24
    369c:	8a 81       	ldd	r24, Y+2	; 0x02
    369e:	28 2f       	mov	r18, r24
    36a0:	30 e0       	ldi	r19, 0x00	; 0
    36a2:	81 e0       	ldi	r24, 0x01	; 1
    36a4:	90 e0       	ldi	r25, 0x00	; 0
    36a6:	02 2e       	mov	r0, r18
    36a8:	02 c0       	rjmp	.+4      	; 0x36ae <DIO_vSetPinDirection+0x2d4>
    36aa:	88 0f       	add	r24, r24
    36ac:	99 1f       	adc	r25, r25
    36ae:	0a 94       	dec	r0
    36b0:	e2 f7       	brpl	.-8      	; 0x36aa <DIO_vSetPinDirection+0x2d0>
    36b2:	84 2b       	or	r24, r20
    36b4:	8c 93       	st	X, r24
    36b6:	9f c0       	rjmp	.+318    	; 0x37f6 <DIO_vSetPinDirection+0x41c>
			break;
		case IPWOR:
			clearbit(DDRC, Copy_u8PinNumber);
    36b8:	a4 e3       	ldi	r26, 0x34	; 52
    36ba:	b0 e0       	ldi	r27, 0x00	; 0
    36bc:	e4 e3       	ldi	r30, 0x34	; 52
    36be:	f0 e0       	ldi	r31, 0x00	; 0
    36c0:	80 81       	ld	r24, Z
    36c2:	48 2f       	mov	r20, r24
    36c4:	8a 81       	ldd	r24, Y+2	; 0x02
    36c6:	28 2f       	mov	r18, r24
    36c8:	30 e0       	ldi	r19, 0x00	; 0
    36ca:	81 e0       	ldi	r24, 0x01	; 1
    36cc:	90 e0       	ldi	r25, 0x00	; 0
    36ce:	02 c0       	rjmp	.+4      	; 0x36d4 <DIO_vSetPinDirection+0x2fa>
    36d0:	88 0f       	add	r24, r24
    36d2:	99 1f       	adc	r25, r25
    36d4:	2a 95       	dec	r18
    36d6:	e2 f7       	brpl	.-8      	; 0x36d0 <DIO_vSetPinDirection+0x2f6>
    36d8:	80 95       	com	r24
    36da:	84 23       	and	r24, r20
    36dc:	8c 93       	st	X, r24
			clearbit(PORTC, Copy_u8PinNumber);
    36de:	a5 e3       	ldi	r26, 0x35	; 53
    36e0:	b0 e0       	ldi	r27, 0x00	; 0
    36e2:	e5 e3       	ldi	r30, 0x35	; 53
    36e4:	f0 e0       	ldi	r31, 0x00	; 0
    36e6:	80 81       	ld	r24, Z
    36e8:	48 2f       	mov	r20, r24
    36ea:	8a 81       	ldd	r24, Y+2	; 0x02
    36ec:	28 2f       	mov	r18, r24
    36ee:	30 e0       	ldi	r19, 0x00	; 0
    36f0:	81 e0       	ldi	r24, 0x01	; 1
    36f2:	90 e0       	ldi	r25, 0x00	; 0
    36f4:	02 2e       	mov	r0, r18
    36f6:	02 c0       	rjmp	.+4      	; 0x36fc <DIO_vSetPinDirection+0x322>
    36f8:	88 0f       	add	r24, r24
    36fa:	99 1f       	adc	r25, r25
    36fc:	0a 94       	dec	r0
    36fe:	e2 f7       	brpl	.-8      	; 0x36f8 <DIO_vSetPinDirection+0x31e>
    3700:	80 95       	com	r24
    3702:	84 23       	and	r24, r20
    3704:	8c 93       	st	X, r24
    3706:	77 c0       	rjmp	.+238    	; 0x37f6 <DIO_vSetPinDirection+0x41c>
			break;
		}
		break;
	case PORT_D:
		switch (copy_u8state) {
    3708:	8b 81       	ldd	r24, Y+3	; 0x03
    370a:	28 2f       	mov	r18, r24
    370c:	30 e0       	ldi	r19, 0x00	; 0
    370e:	3d 83       	std	Y+5, r19	; 0x05
    3710:	2c 83       	std	Y+4, r18	; 0x04
    3712:	8c 81       	ldd	r24, Y+4	; 0x04
    3714:	9d 81       	ldd	r25, Y+5	; 0x05
    3716:	81 30       	cpi	r24, 0x01	; 1
    3718:	91 05       	cpc	r25, r1
    371a:	09 f4       	brne	.+2      	; 0x371e <DIO_vSetPinDirection+0x344>
    371c:	45 c0       	rjmp	.+138    	; 0x37a8 <DIO_vSetPinDirection+0x3ce>
    371e:	2c 81       	ldd	r18, Y+4	; 0x04
    3720:	3d 81       	ldd	r19, Y+5	; 0x05
    3722:	22 30       	cpi	r18, 0x02	; 2
    3724:	31 05       	cpc	r19, r1
    3726:	29 f0       	breq	.+10     	; 0x3732 <DIO_vSetPinDirection+0x358>
    3728:	8c 81       	ldd	r24, Y+4	; 0x04
    372a:	9d 81       	ldd	r25, Y+5	; 0x05
    372c:	00 97       	sbiw	r24, 0x00	; 0
    372e:	a9 f0       	breq	.+42     	; 0x375a <DIO_vSetPinDirection+0x380>
    3730:	62 c0       	rjmp	.+196    	; 0x37f6 <DIO_vSetPinDirection+0x41c>
		case OUTPUT:
			setbit(DDRD, Copy_u8PinNumber);
    3732:	a1 e3       	ldi	r26, 0x31	; 49
    3734:	b0 e0       	ldi	r27, 0x00	; 0
    3736:	e1 e3       	ldi	r30, 0x31	; 49
    3738:	f0 e0       	ldi	r31, 0x00	; 0
    373a:	80 81       	ld	r24, Z
    373c:	48 2f       	mov	r20, r24
    373e:	8a 81       	ldd	r24, Y+2	; 0x02
    3740:	28 2f       	mov	r18, r24
    3742:	30 e0       	ldi	r19, 0x00	; 0
    3744:	81 e0       	ldi	r24, 0x01	; 1
    3746:	90 e0       	ldi	r25, 0x00	; 0
    3748:	02 2e       	mov	r0, r18
    374a:	02 c0       	rjmp	.+4      	; 0x3750 <DIO_vSetPinDirection+0x376>
    374c:	88 0f       	add	r24, r24
    374e:	99 1f       	adc	r25, r25
    3750:	0a 94       	dec	r0
    3752:	e2 f7       	brpl	.-8      	; 0x374c <DIO_vSetPinDirection+0x372>
    3754:	84 2b       	or	r24, r20
    3756:	8c 93       	st	X, r24
    3758:	4e c0       	rjmp	.+156    	; 0x37f6 <DIO_vSetPinDirection+0x41c>
			break;
		case IPWR:
			clearbit(DDRD, Copy_u8PinNumber);
    375a:	a1 e3       	ldi	r26, 0x31	; 49
    375c:	b0 e0       	ldi	r27, 0x00	; 0
    375e:	e1 e3       	ldi	r30, 0x31	; 49
    3760:	f0 e0       	ldi	r31, 0x00	; 0
    3762:	80 81       	ld	r24, Z
    3764:	48 2f       	mov	r20, r24
    3766:	8a 81       	ldd	r24, Y+2	; 0x02
    3768:	28 2f       	mov	r18, r24
    376a:	30 e0       	ldi	r19, 0x00	; 0
    376c:	81 e0       	ldi	r24, 0x01	; 1
    376e:	90 e0       	ldi	r25, 0x00	; 0
    3770:	02 c0       	rjmp	.+4      	; 0x3776 <DIO_vSetPinDirection+0x39c>
    3772:	88 0f       	add	r24, r24
    3774:	99 1f       	adc	r25, r25
    3776:	2a 95       	dec	r18
    3778:	e2 f7       	brpl	.-8      	; 0x3772 <DIO_vSetPinDirection+0x398>
    377a:	80 95       	com	r24
    377c:	84 23       	and	r24, r20
    377e:	8c 93       	st	X, r24
			setbit(PORTD, Copy_u8PinNumber);
    3780:	a2 e3       	ldi	r26, 0x32	; 50
    3782:	b0 e0       	ldi	r27, 0x00	; 0
    3784:	e2 e3       	ldi	r30, 0x32	; 50
    3786:	f0 e0       	ldi	r31, 0x00	; 0
    3788:	80 81       	ld	r24, Z
    378a:	48 2f       	mov	r20, r24
    378c:	8a 81       	ldd	r24, Y+2	; 0x02
    378e:	28 2f       	mov	r18, r24
    3790:	30 e0       	ldi	r19, 0x00	; 0
    3792:	81 e0       	ldi	r24, 0x01	; 1
    3794:	90 e0       	ldi	r25, 0x00	; 0
    3796:	02 2e       	mov	r0, r18
    3798:	02 c0       	rjmp	.+4      	; 0x379e <DIO_vSetPinDirection+0x3c4>
    379a:	88 0f       	add	r24, r24
    379c:	99 1f       	adc	r25, r25
    379e:	0a 94       	dec	r0
    37a0:	e2 f7       	brpl	.-8      	; 0x379a <DIO_vSetPinDirection+0x3c0>
    37a2:	84 2b       	or	r24, r20
    37a4:	8c 93       	st	X, r24
    37a6:	27 c0       	rjmp	.+78     	; 0x37f6 <DIO_vSetPinDirection+0x41c>
			break;
		case IPWOR:
			clearbit(DDRD, Copy_u8PinNumber);
    37a8:	a1 e3       	ldi	r26, 0x31	; 49
    37aa:	b0 e0       	ldi	r27, 0x00	; 0
    37ac:	e1 e3       	ldi	r30, 0x31	; 49
    37ae:	f0 e0       	ldi	r31, 0x00	; 0
    37b0:	80 81       	ld	r24, Z
    37b2:	48 2f       	mov	r20, r24
    37b4:	8a 81       	ldd	r24, Y+2	; 0x02
    37b6:	28 2f       	mov	r18, r24
    37b8:	30 e0       	ldi	r19, 0x00	; 0
    37ba:	81 e0       	ldi	r24, 0x01	; 1
    37bc:	90 e0       	ldi	r25, 0x00	; 0
    37be:	02 c0       	rjmp	.+4      	; 0x37c4 <DIO_vSetPinDirection+0x3ea>
    37c0:	88 0f       	add	r24, r24
    37c2:	99 1f       	adc	r25, r25
    37c4:	2a 95       	dec	r18
    37c6:	e2 f7       	brpl	.-8      	; 0x37c0 <DIO_vSetPinDirection+0x3e6>
    37c8:	80 95       	com	r24
    37ca:	84 23       	and	r24, r20
    37cc:	8c 93       	st	X, r24
			clearbit(PORTD, Copy_u8PinNumber);
    37ce:	a2 e3       	ldi	r26, 0x32	; 50
    37d0:	b0 e0       	ldi	r27, 0x00	; 0
    37d2:	e2 e3       	ldi	r30, 0x32	; 50
    37d4:	f0 e0       	ldi	r31, 0x00	; 0
    37d6:	80 81       	ld	r24, Z
    37d8:	48 2f       	mov	r20, r24
    37da:	8a 81       	ldd	r24, Y+2	; 0x02
    37dc:	28 2f       	mov	r18, r24
    37de:	30 e0       	ldi	r19, 0x00	; 0
    37e0:	81 e0       	ldi	r24, 0x01	; 1
    37e2:	90 e0       	ldi	r25, 0x00	; 0
    37e4:	02 2e       	mov	r0, r18
    37e6:	02 c0       	rjmp	.+4      	; 0x37ec <DIO_vSetPinDirection+0x412>
    37e8:	88 0f       	add	r24, r24
    37ea:	99 1f       	adc	r25, r25
    37ec:	0a 94       	dec	r0
    37ee:	e2 f7       	brpl	.-8      	; 0x37e8 <DIO_vSetPinDirection+0x40e>
    37f0:	80 95       	com	r24
    37f2:	84 23       	and	r24, r20
    37f4:	8c 93       	st	X, r24
			break;
		}
		break;
	}
}
    37f6:	2d 96       	adiw	r28, 0x0d	; 13
    37f8:	0f b6       	in	r0, 0x3f	; 63
    37fa:	f8 94       	cli
    37fc:	de bf       	out	0x3e, r29	; 62
    37fe:	0f be       	out	0x3f, r0	; 63
    3800:	cd bf       	out	0x3d, r28	; 61
    3802:	cf 91       	pop	r28
    3804:	df 91       	pop	r29
    3806:	08 95       	ret

00003808 <DIO_vWritePin>:
 * write 1 or 0 on the OUTPUTPin
 * input:PORTx , PIN Number and Value(1 or 0)
 * OUTPUT:Nothing
 ***********************************************************************/
void DIO_vWritePin(uint8 Copy_u8PORT, uint8 Copy_u8PinNumber,
		uint8 Copy_u8value) {
    3808:	df 93       	push	r29
    380a:	cf 93       	push	r28
    380c:	cd b7       	in	r28, 0x3d	; 61
    380e:	de b7       	in	r29, 0x3e	; 62
    3810:	2d 97       	sbiw	r28, 0x0d	; 13
    3812:	0f b6       	in	r0, 0x3f	; 63
    3814:	f8 94       	cli
    3816:	de bf       	out	0x3e, r29	; 62
    3818:	0f be       	out	0x3f, r0	; 63
    381a:	cd bf       	out	0x3d, r28	; 61
    381c:	89 83       	std	Y+1, r24	; 0x01
    381e:	6a 83       	std	Y+2, r22	; 0x02
    3820:	4b 83       	std	Y+3, r20	; 0x03
	switch (Copy_u8PORT) {
    3822:	89 81       	ldd	r24, Y+1	; 0x01
    3824:	28 2f       	mov	r18, r24
    3826:	30 e0       	ldi	r19, 0x00	; 0
    3828:	3d 87       	std	Y+13, r19	; 0x0d
    382a:	2c 87       	std	Y+12, r18	; 0x0c
    382c:	8c 85       	ldd	r24, Y+12	; 0x0c
    382e:	9d 85       	ldd	r25, Y+13	; 0x0d
    3830:	81 30       	cpi	r24, 0x01	; 1
    3832:	91 05       	cpc	r25, r1
    3834:	09 f4       	brne	.+2      	; 0x3838 <DIO_vWritePin+0x30>
    3836:	4f c0       	rjmp	.+158    	; 0x38d6 <DIO_vWritePin+0xce>
    3838:	2c 85       	ldd	r18, Y+12	; 0x0c
    383a:	3d 85       	ldd	r19, Y+13	; 0x0d
    383c:	22 30       	cpi	r18, 0x02	; 2
    383e:	31 05       	cpc	r19, r1
    3840:	2c f4       	brge	.+10     	; 0x384c <DIO_vWritePin+0x44>
    3842:	8c 85       	ldd	r24, Y+12	; 0x0c
    3844:	9d 85       	ldd	r25, Y+13	; 0x0d
    3846:	00 97       	sbiw	r24, 0x00	; 0
    3848:	71 f0       	breq	.+28     	; 0x3866 <DIO_vWritePin+0x5e>
    384a:	ec c0       	rjmp	.+472    	; 0x3a24 <DIO_vWritePin+0x21c>
    384c:	2c 85       	ldd	r18, Y+12	; 0x0c
    384e:	3d 85       	ldd	r19, Y+13	; 0x0d
    3850:	22 30       	cpi	r18, 0x02	; 2
    3852:	31 05       	cpc	r19, r1
    3854:	09 f4       	brne	.+2      	; 0x3858 <DIO_vWritePin+0x50>
    3856:	77 c0       	rjmp	.+238    	; 0x3946 <DIO_vWritePin+0x13e>
    3858:	8c 85       	ldd	r24, Y+12	; 0x0c
    385a:	9d 85       	ldd	r25, Y+13	; 0x0d
    385c:	83 30       	cpi	r24, 0x03	; 3
    385e:	91 05       	cpc	r25, r1
    3860:	09 f4       	brne	.+2      	; 0x3864 <DIO_vWritePin+0x5c>
    3862:	a9 c0       	rjmp	.+338    	; 0x39b6 <DIO_vWritePin+0x1ae>
    3864:	df c0       	rjmp	.+446    	; 0x3a24 <DIO_vWritePin+0x21c>
	case PORT_A:
		switch (Copy_u8value) {
    3866:	8b 81       	ldd	r24, Y+3	; 0x03
    3868:	28 2f       	mov	r18, r24
    386a:	30 e0       	ldi	r19, 0x00	; 0
    386c:	3b 87       	std	Y+11, r19	; 0x0b
    386e:	2a 87       	std	Y+10, r18	; 0x0a
    3870:	8a 85       	ldd	r24, Y+10	; 0x0a
    3872:	9b 85       	ldd	r25, Y+11	; 0x0b
    3874:	00 97       	sbiw	r24, 0x00	; 0
    3876:	31 f0       	breq	.+12     	; 0x3884 <DIO_vWritePin+0x7c>
    3878:	2a 85       	ldd	r18, Y+10	; 0x0a
    387a:	3b 85       	ldd	r19, Y+11	; 0x0b
    387c:	21 30       	cpi	r18, 0x01	; 1
    387e:	31 05       	cpc	r19, r1
    3880:	b1 f0       	breq	.+44     	; 0x38ae <DIO_vWritePin+0xa6>
    3882:	d0 c0       	rjmp	.+416    	; 0x3a24 <DIO_vWritePin+0x21c>
		case LOW:
			clearbit(PORTA, Copy_u8PinNumber);
    3884:	ab e3       	ldi	r26, 0x3B	; 59
    3886:	b0 e0       	ldi	r27, 0x00	; 0
    3888:	eb e3       	ldi	r30, 0x3B	; 59
    388a:	f0 e0       	ldi	r31, 0x00	; 0
    388c:	80 81       	ld	r24, Z
    388e:	48 2f       	mov	r20, r24
    3890:	8a 81       	ldd	r24, Y+2	; 0x02
    3892:	28 2f       	mov	r18, r24
    3894:	30 e0       	ldi	r19, 0x00	; 0
    3896:	81 e0       	ldi	r24, 0x01	; 1
    3898:	90 e0       	ldi	r25, 0x00	; 0
    389a:	02 2e       	mov	r0, r18
    389c:	02 c0       	rjmp	.+4      	; 0x38a2 <DIO_vWritePin+0x9a>
    389e:	88 0f       	add	r24, r24
    38a0:	99 1f       	adc	r25, r25
    38a2:	0a 94       	dec	r0
    38a4:	e2 f7       	brpl	.-8      	; 0x389e <DIO_vWritePin+0x96>
    38a6:	80 95       	com	r24
    38a8:	84 23       	and	r24, r20
    38aa:	8c 93       	st	X, r24
    38ac:	bb c0       	rjmp	.+374    	; 0x3a24 <DIO_vWritePin+0x21c>
			break;
		case HIGH:
			setbit(PORTA, Copy_u8PinNumber);
    38ae:	ab e3       	ldi	r26, 0x3B	; 59
    38b0:	b0 e0       	ldi	r27, 0x00	; 0
    38b2:	eb e3       	ldi	r30, 0x3B	; 59
    38b4:	f0 e0       	ldi	r31, 0x00	; 0
    38b6:	80 81       	ld	r24, Z
    38b8:	48 2f       	mov	r20, r24
    38ba:	8a 81       	ldd	r24, Y+2	; 0x02
    38bc:	28 2f       	mov	r18, r24
    38be:	30 e0       	ldi	r19, 0x00	; 0
    38c0:	81 e0       	ldi	r24, 0x01	; 1
    38c2:	90 e0       	ldi	r25, 0x00	; 0
    38c4:	02 2e       	mov	r0, r18
    38c6:	02 c0       	rjmp	.+4      	; 0x38cc <DIO_vWritePin+0xc4>
    38c8:	88 0f       	add	r24, r24
    38ca:	99 1f       	adc	r25, r25
    38cc:	0a 94       	dec	r0
    38ce:	e2 f7       	brpl	.-8      	; 0x38c8 <DIO_vWritePin+0xc0>
    38d0:	84 2b       	or	r24, r20
    38d2:	8c 93       	st	X, r24
    38d4:	a7 c0       	rjmp	.+334    	; 0x3a24 <DIO_vWritePin+0x21c>
			break;
		}
		break;
	case PORT_B:
		switch (Copy_u8value) {
    38d6:	8b 81       	ldd	r24, Y+3	; 0x03
    38d8:	28 2f       	mov	r18, r24
    38da:	30 e0       	ldi	r19, 0x00	; 0
    38dc:	39 87       	std	Y+9, r19	; 0x09
    38de:	28 87       	std	Y+8, r18	; 0x08
    38e0:	88 85       	ldd	r24, Y+8	; 0x08
    38e2:	99 85       	ldd	r25, Y+9	; 0x09
    38e4:	00 97       	sbiw	r24, 0x00	; 0
    38e6:	31 f0       	breq	.+12     	; 0x38f4 <DIO_vWritePin+0xec>
    38e8:	28 85       	ldd	r18, Y+8	; 0x08
    38ea:	39 85       	ldd	r19, Y+9	; 0x09
    38ec:	21 30       	cpi	r18, 0x01	; 1
    38ee:	31 05       	cpc	r19, r1
    38f0:	b1 f0       	breq	.+44     	; 0x391e <DIO_vWritePin+0x116>
    38f2:	98 c0       	rjmp	.+304    	; 0x3a24 <DIO_vWritePin+0x21c>
		case LOW:
			clearbit(PORTB, Copy_u8PinNumber);
    38f4:	a8 e3       	ldi	r26, 0x38	; 56
    38f6:	b0 e0       	ldi	r27, 0x00	; 0
    38f8:	e8 e3       	ldi	r30, 0x38	; 56
    38fa:	f0 e0       	ldi	r31, 0x00	; 0
    38fc:	80 81       	ld	r24, Z
    38fe:	48 2f       	mov	r20, r24
    3900:	8a 81       	ldd	r24, Y+2	; 0x02
    3902:	28 2f       	mov	r18, r24
    3904:	30 e0       	ldi	r19, 0x00	; 0
    3906:	81 e0       	ldi	r24, 0x01	; 1
    3908:	90 e0       	ldi	r25, 0x00	; 0
    390a:	02 2e       	mov	r0, r18
    390c:	02 c0       	rjmp	.+4      	; 0x3912 <DIO_vWritePin+0x10a>
    390e:	88 0f       	add	r24, r24
    3910:	99 1f       	adc	r25, r25
    3912:	0a 94       	dec	r0
    3914:	e2 f7       	brpl	.-8      	; 0x390e <DIO_vWritePin+0x106>
    3916:	80 95       	com	r24
    3918:	84 23       	and	r24, r20
    391a:	8c 93       	st	X, r24
    391c:	83 c0       	rjmp	.+262    	; 0x3a24 <DIO_vWritePin+0x21c>
			break;
		case HIGH:
			setbit(PORTB, Copy_u8PinNumber);
    391e:	a8 e3       	ldi	r26, 0x38	; 56
    3920:	b0 e0       	ldi	r27, 0x00	; 0
    3922:	e8 e3       	ldi	r30, 0x38	; 56
    3924:	f0 e0       	ldi	r31, 0x00	; 0
    3926:	80 81       	ld	r24, Z
    3928:	48 2f       	mov	r20, r24
    392a:	8a 81       	ldd	r24, Y+2	; 0x02
    392c:	28 2f       	mov	r18, r24
    392e:	30 e0       	ldi	r19, 0x00	; 0
    3930:	81 e0       	ldi	r24, 0x01	; 1
    3932:	90 e0       	ldi	r25, 0x00	; 0
    3934:	02 2e       	mov	r0, r18
    3936:	02 c0       	rjmp	.+4      	; 0x393c <DIO_vWritePin+0x134>
    3938:	88 0f       	add	r24, r24
    393a:	99 1f       	adc	r25, r25
    393c:	0a 94       	dec	r0
    393e:	e2 f7       	brpl	.-8      	; 0x3938 <DIO_vWritePin+0x130>
    3940:	84 2b       	or	r24, r20
    3942:	8c 93       	st	X, r24
    3944:	6f c0       	rjmp	.+222    	; 0x3a24 <DIO_vWritePin+0x21c>
			break;
		}
		break;
	case PORT_C:
		switch (Copy_u8value) {
    3946:	8b 81       	ldd	r24, Y+3	; 0x03
    3948:	28 2f       	mov	r18, r24
    394a:	30 e0       	ldi	r19, 0x00	; 0
    394c:	3f 83       	std	Y+7, r19	; 0x07
    394e:	2e 83       	std	Y+6, r18	; 0x06
    3950:	8e 81       	ldd	r24, Y+6	; 0x06
    3952:	9f 81       	ldd	r25, Y+7	; 0x07
    3954:	00 97       	sbiw	r24, 0x00	; 0
    3956:	31 f0       	breq	.+12     	; 0x3964 <DIO_vWritePin+0x15c>
    3958:	2e 81       	ldd	r18, Y+6	; 0x06
    395a:	3f 81       	ldd	r19, Y+7	; 0x07
    395c:	21 30       	cpi	r18, 0x01	; 1
    395e:	31 05       	cpc	r19, r1
    3960:	b1 f0       	breq	.+44     	; 0x398e <DIO_vWritePin+0x186>
    3962:	60 c0       	rjmp	.+192    	; 0x3a24 <DIO_vWritePin+0x21c>
		case LOW:
			clearbit(PORTC, Copy_u8PinNumber);
    3964:	a5 e3       	ldi	r26, 0x35	; 53
    3966:	b0 e0       	ldi	r27, 0x00	; 0
    3968:	e5 e3       	ldi	r30, 0x35	; 53
    396a:	f0 e0       	ldi	r31, 0x00	; 0
    396c:	80 81       	ld	r24, Z
    396e:	48 2f       	mov	r20, r24
    3970:	8a 81       	ldd	r24, Y+2	; 0x02
    3972:	28 2f       	mov	r18, r24
    3974:	30 e0       	ldi	r19, 0x00	; 0
    3976:	81 e0       	ldi	r24, 0x01	; 1
    3978:	90 e0       	ldi	r25, 0x00	; 0
    397a:	02 2e       	mov	r0, r18
    397c:	02 c0       	rjmp	.+4      	; 0x3982 <DIO_vWritePin+0x17a>
    397e:	88 0f       	add	r24, r24
    3980:	99 1f       	adc	r25, r25
    3982:	0a 94       	dec	r0
    3984:	e2 f7       	brpl	.-8      	; 0x397e <DIO_vWritePin+0x176>
    3986:	80 95       	com	r24
    3988:	84 23       	and	r24, r20
    398a:	8c 93       	st	X, r24
    398c:	4b c0       	rjmp	.+150    	; 0x3a24 <DIO_vWritePin+0x21c>
			break;
		case HIGH:
			setbit(PORTC, Copy_u8PinNumber);
    398e:	a5 e3       	ldi	r26, 0x35	; 53
    3990:	b0 e0       	ldi	r27, 0x00	; 0
    3992:	e5 e3       	ldi	r30, 0x35	; 53
    3994:	f0 e0       	ldi	r31, 0x00	; 0
    3996:	80 81       	ld	r24, Z
    3998:	48 2f       	mov	r20, r24
    399a:	8a 81       	ldd	r24, Y+2	; 0x02
    399c:	28 2f       	mov	r18, r24
    399e:	30 e0       	ldi	r19, 0x00	; 0
    39a0:	81 e0       	ldi	r24, 0x01	; 1
    39a2:	90 e0       	ldi	r25, 0x00	; 0
    39a4:	02 2e       	mov	r0, r18
    39a6:	02 c0       	rjmp	.+4      	; 0x39ac <DIO_vWritePin+0x1a4>
    39a8:	88 0f       	add	r24, r24
    39aa:	99 1f       	adc	r25, r25
    39ac:	0a 94       	dec	r0
    39ae:	e2 f7       	brpl	.-8      	; 0x39a8 <DIO_vWritePin+0x1a0>
    39b0:	84 2b       	or	r24, r20
    39b2:	8c 93       	st	X, r24
    39b4:	37 c0       	rjmp	.+110    	; 0x3a24 <DIO_vWritePin+0x21c>
			break;
		}
		break;
	case PORT_D:
		switch (Copy_u8value) {
    39b6:	8b 81       	ldd	r24, Y+3	; 0x03
    39b8:	28 2f       	mov	r18, r24
    39ba:	30 e0       	ldi	r19, 0x00	; 0
    39bc:	3d 83       	std	Y+5, r19	; 0x05
    39be:	2c 83       	std	Y+4, r18	; 0x04
    39c0:	8c 81       	ldd	r24, Y+4	; 0x04
    39c2:	9d 81       	ldd	r25, Y+5	; 0x05
    39c4:	00 97       	sbiw	r24, 0x00	; 0
    39c6:	31 f0       	breq	.+12     	; 0x39d4 <DIO_vWritePin+0x1cc>
    39c8:	2c 81       	ldd	r18, Y+4	; 0x04
    39ca:	3d 81       	ldd	r19, Y+5	; 0x05
    39cc:	21 30       	cpi	r18, 0x01	; 1
    39ce:	31 05       	cpc	r19, r1
    39d0:	b1 f0       	breq	.+44     	; 0x39fe <DIO_vWritePin+0x1f6>
    39d2:	28 c0       	rjmp	.+80     	; 0x3a24 <DIO_vWritePin+0x21c>
		case LOW:
			clearbit(PORTD, Copy_u8PinNumber);
    39d4:	a2 e3       	ldi	r26, 0x32	; 50
    39d6:	b0 e0       	ldi	r27, 0x00	; 0
    39d8:	e2 e3       	ldi	r30, 0x32	; 50
    39da:	f0 e0       	ldi	r31, 0x00	; 0
    39dc:	80 81       	ld	r24, Z
    39de:	48 2f       	mov	r20, r24
    39e0:	8a 81       	ldd	r24, Y+2	; 0x02
    39e2:	28 2f       	mov	r18, r24
    39e4:	30 e0       	ldi	r19, 0x00	; 0
    39e6:	81 e0       	ldi	r24, 0x01	; 1
    39e8:	90 e0       	ldi	r25, 0x00	; 0
    39ea:	02 2e       	mov	r0, r18
    39ec:	02 c0       	rjmp	.+4      	; 0x39f2 <DIO_vWritePin+0x1ea>
    39ee:	88 0f       	add	r24, r24
    39f0:	99 1f       	adc	r25, r25
    39f2:	0a 94       	dec	r0
    39f4:	e2 f7       	brpl	.-8      	; 0x39ee <DIO_vWritePin+0x1e6>
    39f6:	80 95       	com	r24
    39f8:	84 23       	and	r24, r20
    39fa:	8c 93       	st	X, r24
    39fc:	13 c0       	rjmp	.+38     	; 0x3a24 <DIO_vWritePin+0x21c>
			break;
		case HIGH:
			setbit(PORTD, Copy_u8PinNumber);
    39fe:	a2 e3       	ldi	r26, 0x32	; 50
    3a00:	b0 e0       	ldi	r27, 0x00	; 0
    3a02:	e2 e3       	ldi	r30, 0x32	; 50
    3a04:	f0 e0       	ldi	r31, 0x00	; 0
    3a06:	80 81       	ld	r24, Z
    3a08:	48 2f       	mov	r20, r24
    3a0a:	8a 81       	ldd	r24, Y+2	; 0x02
    3a0c:	28 2f       	mov	r18, r24
    3a0e:	30 e0       	ldi	r19, 0x00	; 0
    3a10:	81 e0       	ldi	r24, 0x01	; 1
    3a12:	90 e0       	ldi	r25, 0x00	; 0
    3a14:	02 2e       	mov	r0, r18
    3a16:	02 c0       	rjmp	.+4      	; 0x3a1c <DIO_vWritePin+0x214>
    3a18:	88 0f       	add	r24, r24
    3a1a:	99 1f       	adc	r25, r25
    3a1c:	0a 94       	dec	r0
    3a1e:	e2 f7       	brpl	.-8      	; 0x3a18 <DIO_vWritePin+0x210>
    3a20:	84 2b       	or	r24, r20
    3a22:	8c 93       	st	X, r24
			break;
		}
		break;
	}
}
    3a24:	2d 96       	adiw	r28, 0x0d	; 13
    3a26:	0f b6       	in	r0, 0x3f	; 63
    3a28:	f8 94       	cli
    3a2a:	de bf       	out	0x3e, r29	; 62
    3a2c:	0f be       	out	0x3f, r0	; 63
    3a2e:	cd bf       	out	0x3d, r28	; 61
    3a30:	cf 91       	pop	r28
    3a32:	df 91       	pop	r29
    3a34:	08 95       	ret

00003a36 <DIO_u8GetPinValue>:
 * get the value of PInx
 * input:portx and pin number
 * OUTPUT:returns value of Pin (1 or 0)
 *
 ************************************************************************/
uint8 DIO_u8GetPinValue(uint8 Copy_u8PORT, uint8 Copy_u8PinNumber) {
    3a36:	df 93       	push	r29
    3a38:	cf 93       	push	r28
    3a3a:	00 d0       	rcall	.+0      	; 0x3a3c <DIO_u8GetPinValue+0x6>
    3a3c:	00 d0       	rcall	.+0      	; 0x3a3e <DIO_u8GetPinValue+0x8>
    3a3e:	0f 92       	push	r0
    3a40:	cd b7       	in	r28, 0x3d	; 61
    3a42:	de b7       	in	r29, 0x3e	; 62
    3a44:	8a 83       	std	Y+2, r24	; 0x02
    3a46:	6b 83       	std	Y+3, r22	; 0x03
	uint8 pin_value;
	switch (Copy_u8PORT) {
    3a48:	8a 81       	ldd	r24, Y+2	; 0x02
    3a4a:	28 2f       	mov	r18, r24
    3a4c:	30 e0       	ldi	r19, 0x00	; 0
    3a4e:	3d 83       	std	Y+5, r19	; 0x05
    3a50:	2c 83       	std	Y+4, r18	; 0x04
    3a52:	4c 81       	ldd	r20, Y+4	; 0x04
    3a54:	5d 81       	ldd	r21, Y+5	; 0x05
    3a56:	41 30       	cpi	r20, 0x01	; 1
    3a58:	51 05       	cpc	r21, r1
    3a5a:	b1 f1       	breq	.+108    	; 0x3ac8 <DIO_u8GetPinValue+0x92>
    3a5c:	8c 81       	ldd	r24, Y+4	; 0x04
    3a5e:	9d 81       	ldd	r25, Y+5	; 0x05
    3a60:	82 30       	cpi	r24, 0x02	; 2
    3a62:	91 05       	cpc	r25, r1
    3a64:	34 f4       	brge	.+12     	; 0x3a72 <DIO_u8GetPinValue+0x3c>
    3a66:	2c 81       	ldd	r18, Y+4	; 0x04
    3a68:	3d 81       	ldd	r19, Y+5	; 0x05
    3a6a:	21 15       	cp	r18, r1
    3a6c:	31 05       	cpc	r19, r1
    3a6e:	71 f0       	breq	.+28     	; 0x3a8c <DIO_u8GetPinValue+0x56>
    3a70:	84 c0       	rjmp	.+264    	; 0x3b7a <DIO_u8GetPinValue+0x144>
    3a72:	4c 81       	ldd	r20, Y+4	; 0x04
    3a74:	5d 81       	ldd	r21, Y+5	; 0x05
    3a76:	42 30       	cpi	r20, 0x02	; 2
    3a78:	51 05       	cpc	r21, r1
    3a7a:	09 f4       	brne	.+2      	; 0x3a7e <DIO_u8GetPinValue+0x48>
    3a7c:	43 c0       	rjmp	.+134    	; 0x3b04 <DIO_u8GetPinValue+0xce>
    3a7e:	8c 81       	ldd	r24, Y+4	; 0x04
    3a80:	9d 81       	ldd	r25, Y+5	; 0x05
    3a82:	83 30       	cpi	r24, 0x03	; 3
    3a84:	91 05       	cpc	r25, r1
    3a86:	09 f4       	brne	.+2      	; 0x3a8a <DIO_u8GetPinValue+0x54>
    3a88:	5b c0       	rjmp	.+182    	; 0x3b40 <DIO_u8GetPinValue+0x10a>
    3a8a:	77 c0       	rjmp	.+238    	; 0x3b7a <DIO_u8GetPinValue+0x144>
	case PORT_A:
		pin_value = getbit(PINA, Copy_u8PinNumber);
    3a8c:	e9 e3       	ldi	r30, 0x39	; 57
    3a8e:	f0 e0       	ldi	r31, 0x00	; 0
    3a90:	80 81       	ld	r24, Z
    3a92:	48 2f       	mov	r20, r24
    3a94:	50 e0       	ldi	r21, 0x00	; 0
    3a96:	8b 81       	ldd	r24, Y+3	; 0x03
    3a98:	28 2f       	mov	r18, r24
    3a9a:	30 e0       	ldi	r19, 0x00	; 0
    3a9c:	81 e0       	ldi	r24, 0x01	; 1
    3a9e:	90 e0       	ldi	r25, 0x00	; 0
    3aa0:	02 c0       	rjmp	.+4      	; 0x3aa6 <DIO_u8GetPinValue+0x70>
    3aa2:	88 0f       	add	r24, r24
    3aa4:	99 1f       	adc	r25, r25
    3aa6:	2a 95       	dec	r18
    3aa8:	e2 f7       	brpl	.-8      	; 0x3aa2 <DIO_u8GetPinValue+0x6c>
    3aaa:	9a 01       	movw	r18, r20
    3aac:	28 23       	and	r18, r24
    3aae:	39 23       	and	r19, r25
    3ab0:	8b 81       	ldd	r24, Y+3	; 0x03
    3ab2:	88 2f       	mov	r24, r24
    3ab4:	90 e0       	ldi	r25, 0x00	; 0
    3ab6:	a9 01       	movw	r20, r18
    3ab8:	02 c0       	rjmp	.+4      	; 0x3abe <DIO_u8GetPinValue+0x88>
    3aba:	55 95       	asr	r21
    3abc:	47 95       	ror	r20
    3abe:	8a 95       	dec	r24
    3ac0:	e2 f7       	brpl	.-8      	; 0x3aba <DIO_u8GetPinValue+0x84>
    3ac2:	ca 01       	movw	r24, r20
    3ac4:	89 83       	std	Y+1, r24	; 0x01
    3ac6:	59 c0       	rjmp	.+178    	; 0x3b7a <DIO_u8GetPinValue+0x144>
		break;
	case PORT_B:
		pin_value = getbit(PINB, Copy_u8PinNumber);
    3ac8:	e6 e3       	ldi	r30, 0x36	; 54
    3aca:	f0 e0       	ldi	r31, 0x00	; 0
    3acc:	80 81       	ld	r24, Z
    3ace:	48 2f       	mov	r20, r24
    3ad0:	50 e0       	ldi	r21, 0x00	; 0
    3ad2:	8b 81       	ldd	r24, Y+3	; 0x03
    3ad4:	28 2f       	mov	r18, r24
    3ad6:	30 e0       	ldi	r19, 0x00	; 0
    3ad8:	81 e0       	ldi	r24, 0x01	; 1
    3ada:	90 e0       	ldi	r25, 0x00	; 0
    3adc:	02 c0       	rjmp	.+4      	; 0x3ae2 <DIO_u8GetPinValue+0xac>
    3ade:	88 0f       	add	r24, r24
    3ae0:	99 1f       	adc	r25, r25
    3ae2:	2a 95       	dec	r18
    3ae4:	e2 f7       	brpl	.-8      	; 0x3ade <DIO_u8GetPinValue+0xa8>
    3ae6:	9a 01       	movw	r18, r20
    3ae8:	28 23       	and	r18, r24
    3aea:	39 23       	and	r19, r25
    3aec:	8b 81       	ldd	r24, Y+3	; 0x03
    3aee:	88 2f       	mov	r24, r24
    3af0:	90 e0       	ldi	r25, 0x00	; 0
    3af2:	a9 01       	movw	r20, r18
    3af4:	02 c0       	rjmp	.+4      	; 0x3afa <DIO_u8GetPinValue+0xc4>
    3af6:	55 95       	asr	r21
    3af8:	47 95       	ror	r20
    3afa:	8a 95       	dec	r24
    3afc:	e2 f7       	brpl	.-8      	; 0x3af6 <DIO_u8GetPinValue+0xc0>
    3afe:	ca 01       	movw	r24, r20
    3b00:	89 83       	std	Y+1, r24	; 0x01
    3b02:	3b c0       	rjmp	.+118    	; 0x3b7a <DIO_u8GetPinValue+0x144>
		break;
	case PORT_C:
		pin_value = getbit(PINC, Copy_u8PinNumber);
    3b04:	e3 e3       	ldi	r30, 0x33	; 51
    3b06:	f0 e0       	ldi	r31, 0x00	; 0
    3b08:	80 81       	ld	r24, Z
    3b0a:	48 2f       	mov	r20, r24
    3b0c:	50 e0       	ldi	r21, 0x00	; 0
    3b0e:	8b 81       	ldd	r24, Y+3	; 0x03
    3b10:	28 2f       	mov	r18, r24
    3b12:	30 e0       	ldi	r19, 0x00	; 0
    3b14:	81 e0       	ldi	r24, 0x01	; 1
    3b16:	90 e0       	ldi	r25, 0x00	; 0
    3b18:	02 c0       	rjmp	.+4      	; 0x3b1e <DIO_u8GetPinValue+0xe8>
    3b1a:	88 0f       	add	r24, r24
    3b1c:	99 1f       	adc	r25, r25
    3b1e:	2a 95       	dec	r18
    3b20:	e2 f7       	brpl	.-8      	; 0x3b1a <DIO_u8GetPinValue+0xe4>
    3b22:	9a 01       	movw	r18, r20
    3b24:	28 23       	and	r18, r24
    3b26:	39 23       	and	r19, r25
    3b28:	8b 81       	ldd	r24, Y+3	; 0x03
    3b2a:	88 2f       	mov	r24, r24
    3b2c:	90 e0       	ldi	r25, 0x00	; 0
    3b2e:	a9 01       	movw	r20, r18
    3b30:	02 c0       	rjmp	.+4      	; 0x3b36 <DIO_u8GetPinValue+0x100>
    3b32:	55 95       	asr	r21
    3b34:	47 95       	ror	r20
    3b36:	8a 95       	dec	r24
    3b38:	e2 f7       	brpl	.-8      	; 0x3b32 <DIO_u8GetPinValue+0xfc>
    3b3a:	ca 01       	movw	r24, r20
    3b3c:	89 83       	std	Y+1, r24	; 0x01
    3b3e:	1d c0       	rjmp	.+58     	; 0x3b7a <DIO_u8GetPinValue+0x144>
		break;
	case PORT_D:
		pin_value = getbit(PIND, Copy_u8PinNumber);
    3b40:	e0 e3       	ldi	r30, 0x30	; 48
    3b42:	f0 e0       	ldi	r31, 0x00	; 0
    3b44:	80 81       	ld	r24, Z
    3b46:	48 2f       	mov	r20, r24
    3b48:	50 e0       	ldi	r21, 0x00	; 0
    3b4a:	8b 81       	ldd	r24, Y+3	; 0x03
    3b4c:	28 2f       	mov	r18, r24
    3b4e:	30 e0       	ldi	r19, 0x00	; 0
    3b50:	81 e0       	ldi	r24, 0x01	; 1
    3b52:	90 e0       	ldi	r25, 0x00	; 0
    3b54:	02 c0       	rjmp	.+4      	; 0x3b5a <DIO_u8GetPinValue+0x124>
    3b56:	88 0f       	add	r24, r24
    3b58:	99 1f       	adc	r25, r25
    3b5a:	2a 95       	dec	r18
    3b5c:	e2 f7       	brpl	.-8      	; 0x3b56 <DIO_u8GetPinValue+0x120>
    3b5e:	9a 01       	movw	r18, r20
    3b60:	28 23       	and	r18, r24
    3b62:	39 23       	and	r19, r25
    3b64:	8b 81       	ldd	r24, Y+3	; 0x03
    3b66:	88 2f       	mov	r24, r24
    3b68:	90 e0       	ldi	r25, 0x00	; 0
    3b6a:	a9 01       	movw	r20, r18
    3b6c:	02 c0       	rjmp	.+4      	; 0x3b72 <DIO_u8GetPinValue+0x13c>
    3b6e:	55 95       	asr	r21
    3b70:	47 95       	ror	r20
    3b72:	8a 95       	dec	r24
    3b74:	e2 f7       	brpl	.-8      	; 0x3b6e <DIO_u8GetPinValue+0x138>
    3b76:	ca 01       	movw	r24, r20
    3b78:	89 83       	std	Y+1, r24	; 0x01
		break;
	}
	return pin_value;
    3b7a:	89 81       	ldd	r24, Y+1	; 0x01
}
    3b7c:	0f 90       	pop	r0
    3b7e:	0f 90       	pop	r0
    3b80:	0f 90       	pop	r0
    3b82:	0f 90       	pop	r0
    3b84:	0f 90       	pop	r0
    3b86:	cf 91       	pop	r28
    3b88:	df 91       	pop	r29
    3b8a:	08 95       	ret

00003b8c <DIO_vTogglePin>:
 * Description :void DIO_u8TogglePin(port Copy_u8PORT,u8 Copy_u8PinNumber)
 * toggle PinX
 * input:PortX and Pin number
 * OUTPUT:Nothing
 *************************************************************************/
void DIO_vTogglePin(uint8 Copy_u8PORT, uint8 Copy_u8PinNumber) {
    3b8c:	df 93       	push	r29
    3b8e:	cf 93       	push	r28
    3b90:	00 d0       	rcall	.+0      	; 0x3b92 <DIO_vTogglePin+0x6>
    3b92:	00 d0       	rcall	.+0      	; 0x3b94 <DIO_vTogglePin+0x8>
    3b94:	cd b7       	in	r28, 0x3d	; 61
    3b96:	de b7       	in	r29, 0x3e	; 62
    3b98:	89 83       	std	Y+1, r24	; 0x01
    3b9a:	6a 83       	std	Y+2, r22	; 0x02
	switch (Copy_u8PORT) {
    3b9c:	89 81       	ldd	r24, Y+1	; 0x01
    3b9e:	28 2f       	mov	r18, r24
    3ba0:	30 e0       	ldi	r19, 0x00	; 0
    3ba2:	3c 83       	std	Y+4, r19	; 0x04
    3ba4:	2b 83       	std	Y+3, r18	; 0x03
    3ba6:	8b 81       	ldd	r24, Y+3	; 0x03
    3ba8:	9c 81       	ldd	r25, Y+4	; 0x04
    3baa:	81 30       	cpi	r24, 0x01	; 1
    3bac:	91 05       	cpc	r25, r1
    3bae:	49 f1       	breq	.+82     	; 0x3c02 <DIO_vTogglePin+0x76>
    3bb0:	2b 81       	ldd	r18, Y+3	; 0x03
    3bb2:	3c 81       	ldd	r19, Y+4	; 0x04
    3bb4:	22 30       	cpi	r18, 0x02	; 2
    3bb6:	31 05       	cpc	r19, r1
    3bb8:	2c f4       	brge	.+10     	; 0x3bc4 <DIO_vTogglePin+0x38>
    3bba:	8b 81       	ldd	r24, Y+3	; 0x03
    3bbc:	9c 81       	ldd	r25, Y+4	; 0x04
    3bbe:	00 97       	sbiw	r24, 0x00	; 0
    3bc0:	61 f0       	breq	.+24     	; 0x3bda <DIO_vTogglePin+0x4e>
    3bc2:	5a c0       	rjmp	.+180    	; 0x3c78 <DIO_vTogglePin+0xec>
    3bc4:	2b 81       	ldd	r18, Y+3	; 0x03
    3bc6:	3c 81       	ldd	r19, Y+4	; 0x04
    3bc8:	22 30       	cpi	r18, 0x02	; 2
    3bca:	31 05       	cpc	r19, r1
    3bcc:	71 f1       	breq	.+92     	; 0x3c2a <DIO_vTogglePin+0x9e>
    3bce:	8b 81       	ldd	r24, Y+3	; 0x03
    3bd0:	9c 81       	ldd	r25, Y+4	; 0x04
    3bd2:	83 30       	cpi	r24, 0x03	; 3
    3bd4:	91 05       	cpc	r25, r1
    3bd6:	e9 f1       	breq	.+122    	; 0x3c52 <DIO_vTogglePin+0xc6>
    3bd8:	4f c0       	rjmp	.+158    	; 0x3c78 <DIO_vTogglePin+0xec>
	case PORT_A:
		togglebit(PORTA, Copy_u8PinNumber);
    3bda:	ab e3       	ldi	r26, 0x3B	; 59
    3bdc:	b0 e0       	ldi	r27, 0x00	; 0
    3bde:	eb e3       	ldi	r30, 0x3B	; 59
    3be0:	f0 e0       	ldi	r31, 0x00	; 0
    3be2:	80 81       	ld	r24, Z
    3be4:	48 2f       	mov	r20, r24
    3be6:	8a 81       	ldd	r24, Y+2	; 0x02
    3be8:	28 2f       	mov	r18, r24
    3bea:	30 e0       	ldi	r19, 0x00	; 0
    3bec:	81 e0       	ldi	r24, 0x01	; 1
    3bee:	90 e0       	ldi	r25, 0x00	; 0
    3bf0:	02 2e       	mov	r0, r18
    3bf2:	02 c0       	rjmp	.+4      	; 0x3bf8 <DIO_vTogglePin+0x6c>
    3bf4:	88 0f       	add	r24, r24
    3bf6:	99 1f       	adc	r25, r25
    3bf8:	0a 94       	dec	r0
    3bfa:	e2 f7       	brpl	.-8      	; 0x3bf4 <DIO_vTogglePin+0x68>
    3bfc:	84 27       	eor	r24, r20
    3bfe:	8c 93       	st	X, r24
    3c00:	3b c0       	rjmp	.+118    	; 0x3c78 <DIO_vTogglePin+0xec>
		break;
	case PORT_B:
		togglebit(PORTB, Copy_u8PinNumber);
    3c02:	a8 e3       	ldi	r26, 0x38	; 56
    3c04:	b0 e0       	ldi	r27, 0x00	; 0
    3c06:	e8 e3       	ldi	r30, 0x38	; 56
    3c08:	f0 e0       	ldi	r31, 0x00	; 0
    3c0a:	80 81       	ld	r24, Z
    3c0c:	48 2f       	mov	r20, r24
    3c0e:	8a 81       	ldd	r24, Y+2	; 0x02
    3c10:	28 2f       	mov	r18, r24
    3c12:	30 e0       	ldi	r19, 0x00	; 0
    3c14:	81 e0       	ldi	r24, 0x01	; 1
    3c16:	90 e0       	ldi	r25, 0x00	; 0
    3c18:	02 2e       	mov	r0, r18
    3c1a:	02 c0       	rjmp	.+4      	; 0x3c20 <DIO_vTogglePin+0x94>
    3c1c:	88 0f       	add	r24, r24
    3c1e:	99 1f       	adc	r25, r25
    3c20:	0a 94       	dec	r0
    3c22:	e2 f7       	brpl	.-8      	; 0x3c1c <DIO_vTogglePin+0x90>
    3c24:	84 27       	eor	r24, r20
    3c26:	8c 93       	st	X, r24
    3c28:	27 c0       	rjmp	.+78     	; 0x3c78 <DIO_vTogglePin+0xec>
		break;
	case PORT_C:
		togglebit(PORTC, Copy_u8PinNumber);
    3c2a:	a5 e3       	ldi	r26, 0x35	; 53
    3c2c:	b0 e0       	ldi	r27, 0x00	; 0
    3c2e:	e5 e3       	ldi	r30, 0x35	; 53
    3c30:	f0 e0       	ldi	r31, 0x00	; 0
    3c32:	80 81       	ld	r24, Z
    3c34:	48 2f       	mov	r20, r24
    3c36:	8a 81       	ldd	r24, Y+2	; 0x02
    3c38:	28 2f       	mov	r18, r24
    3c3a:	30 e0       	ldi	r19, 0x00	; 0
    3c3c:	81 e0       	ldi	r24, 0x01	; 1
    3c3e:	90 e0       	ldi	r25, 0x00	; 0
    3c40:	02 2e       	mov	r0, r18
    3c42:	02 c0       	rjmp	.+4      	; 0x3c48 <DIO_vTogglePin+0xbc>
    3c44:	88 0f       	add	r24, r24
    3c46:	99 1f       	adc	r25, r25
    3c48:	0a 94       	dec	r0
    3c4a:	e2 f7       	brpl	.-8      	; 0x3c44 <DIO_vTogglePin+0xb8>
    3c4c:	84 27       	eor	r24, r20
    3c4e:	8c 93       	st	X, r24
    3c50:	13 c0       	rjmp	.+38     	; 0x3c78 <DIO_vTogglePin+0xec>
		break;
	case PORT_D:
		togglebit(PORTD, Copy_u8PinNumber);
    3c52:	a2 e3       	ldi	r26, 0x32	; 50
    3c54:	b0 e0       	ldi	r27, 0x00	; 0
    3c56:	e2 e3       	ldi	r30, 0x32	; 50
    3c58:	f0 e0       	ldi	r31, 0x00	; 0
    3c5a:	80 81       	ld	r24, Z
    3c5c:	48 2f       	mov	r20, r24
    3c5e:	8a 81       	ldd	r24, Y+2	; 0x02
    3c60:	28 2f       	mov	r18, r24
    3c62:	30 e0       	ldi	r19, 0x00	; 0
    3c64:	81 e0       	ldi	r24, 0x01	; 1
    3c66:	90 e0       	ldi	r25, 0x00	; 0
    3c68:	02 2e       	mov	r0, r18
    3c6a:	02 c0       	rjmp	.+4      	; 0x3c70 <DIO_vTogglePin+0xe4>
    3c6c:	88 0f       	add	r24, r24
    3c6e:	99 1f       	adc	r25, r25
    3c70:	0a 94       	dec	r0
    3c72:	e2 f7       	brpl	.-8      	; 0x3c6c <DIO_vTogglePin+0xe0>
    3c74:	84 27       	eor	r24, r20
    3c76:	8c 93       	st	X, r24
		break;
	}
}
    3c78:	0f 90       	pop	r0
    3c7a:	0f 90       	pop	r0
    3c7c:	0f 90       	pop	r0
    3c7e:	0f 90       	pop	r0
    3c80:	cf 91       	pop	r28
    3c82:	df 91       	pop	r29
    3c84:	08 95       	ret

00003c86 <DIO_vSetPortDirection>:
 * Description:void DIO_vSetPortDirection(port Copy_u8PORT,u8 DDRX copy_u8state)
 * set the Direction of the port
 * input:portX and desired direction
 * OUTPUT:Nothing
 *********************************************************************************/
void DIO_vSetPortDirection(uint8 Copy_u8PORT, uint8 copy_u8state) {
    3c86:	df 93       	push	r29
    3c88:	cf 93       	push	r28
    3c8a:	cd b7       	in	r28, 0x3d	; 61
    3c8c:	de b7       	in	r29, 0x3e	; 62
    3c8e:	2c 97       	sbiw	r28, 0x0c	; 12
    3c90:	0f b6       	in	r0, 0x3f	; 63
    3c92:	f8 94       	cli
    3c94:	de bf       	out	0x3e, r29	; 62
    3c96:	0f be       	out	0x3f, r0	; 63
    3c98:	cd bf       	out	0x3d, r28	; 61
    3c9a:	89 83       	std	Y+1, r24	; 0x01
    3c9c:	6a 83       	std	Y+2, r22	; 0x02
	switch (Copy_u8PORT) {
    3c9e:	89 81       	ldd	r24, Y+1	; 0x01
    3ca0:	28 2f       	mov	r18, r24
    3ca2:	30 e0       	ldi	r19, 0x00	; 0
    3ca4:	3c 87       	std	Y+12, r19	; 0x0c
    3ca6:	2b 87       	std	Y+11, r18	; 0x0b
    3ca8:	8b 85       	ldd	r24, Y+11	; 0x0b
    3caa:	9c 85       	ldd	r25, Y+12	; 0x0c
    3cac:	81 30       	cpi	r24, 0x01	; 1
    3cae:	91 05       	cpc	r25, r1
    3cb0:	09 f4       	brne	.+2      	; 0x3cb4 <DIO_vSetPortDirection+0x2e>
    3cb2:	3f c0       	rjmp	.+126    	; 0x3d32 <DIO_vSetPortDirection+0xac>
    3cb4:	2b 85       	ldd	r18, Y+11	; 0x0b
    3cb6:	3c 85       	ldd	r19, Y+12	; 0x0c
    3cb8:	22 30       	cpi	r18, 0x02	; 2
    3cba:	31 05       	cpc	r19, r1
    3cbc:	2c f4       	brge	.+10     	; 0x3cc8 <DIO_vSetPortDirection+0x42>
    3cbe:	8b 85       	ldd	r24, Y+11	; 0x0b
    3cc0:	9c 85       	ldd	r25, Y+12	; 0x0c
    3cc2:	00 97       	sbiw	r24, 0x00	; 0
    3cc4:	71 f0       	breq	.+28     	; 0x3ce2 <DIO_vSetPortDirection+0x5c>
    3cc6:	ac c0       	rjmp	.+344    	; 0x3e20 <DIO_vSetPortDirection+0x19a>
    3cc8:	2b 85       	ldd	r18, Y+11	; 0x0b
    3cca:	3c 85       	ldd	r19, Y+12	; 0x0c
    3ccc:	22 30       	cpi	r18, 0x02	; 2
    3cce:	31 05       	cpc	r19, r1
    3cd0:	09 f4       	brne	.+2      	; 0x3cd4 <DIO_vSetPortDirection+0x4e>
    3cd2:	57 c0       	rjmp	.+174    	; 0x3d82 <DIO_vSetPortDirection+0xfc>
    3cd4:	8b 85       	ldd	r24, Y+11	; 0x0b
    3cd6:	9c 85       	ldd	r25, Y+12	; 0x0c
    3cd8:	83 30       	cpi	r24, 0x03	; 3
    3cda:	91 05       	cpc	r25, r1
    3cdc:	09 f4       	brne	.+2      	; 0x3ce0 <DIO_vSetPortDirection+0x5a>
    3cde:	79 c0       	rjmp	.+242    	; 0x3dd2 <DIO_vSetPortDirection+0x14c>
    3ce0:	9f c0       	rjmp	.+318    	; 0x3e20 <DIO_vSetPortDirection+0x19a>
	case PORT_A:
		switch (copy_u8state) {
    3ce2:	8a 81       	ldd	r24, Y+2	; 0x02
    3ce4:	28 2f       	mov	r18, r24
    3ce6:	30 e0       	ldi	r19, 0x00	; 0
    3ce8:	3a 87       	std	Y+10, r19	; 0x0a
    3cea:	29 87       	std	Y+9, r18	; 0x09
    3cec:	89 85       	ldd	r24, Y+9	; 0x09
    3cee:	9a 85       	ldd	r25, Y+10	; 0x0a
    3cf0:	81 30       	cpi	r24, 0x01	; 1
    3cf2:	91 05       	cpc	r25, r1
    3cf4:	b9 f0       	breq	.+46     	; 0x3d24 <DIO_vSetPortDirection+0x9e>
    3cf6:	29 85       	ldd	r18, Y+9	; 0x09
    3cf8:	3a 85       	ldd	r19, Y+10	; 0x0a
    3cfa:	22 30       	cpi	r18, 0x02	; 2
    3cfc:	31 05       	cpc	r19, r1
    3cfe:	29 f0       	breq	.+10     	; 0x3d0a <DIO_vSetPortDirection+0x84>
    3d00:	89 85       	ldd	r24, Y+9	; 0x09
    3d02:	9a 85       	ldd	r25, Y+10	; 0x0a
    3d04:	00 97       	sbiw	r24, 0x00	; 0
    3d06:	31 f0       	breq	.+12     	; 0x3d14 <DIO_vSetPortDirection+0x8e>
    3d08:	8b c0       	rjmp	.+278    	; 0x3e20 <DIO_vSetPortDirection+0x19a>
		case OUTPUT:
			DDRA = SET_PORT;
    3d0a:	ea e3       	ldi	r30, 0x3A	; 58
    3d0c:	f0 e0       	ldi	r31, 0x00	; 0
    3d0e:	8f ef       	ldi	r24, 0xFF	; 255
    3d10:	80 83       	st	Z, r24
    3d12:	86 c0       	rjmp	.+268    	; 0x3e20 <DIO_vSetPortDirection+0x19a>
			break;
		case IPWR:
			DDRA = CLEAR_PORT;
    3d14:	ea e3       	ldi	r30, 0x3A	; 58
    3d16:	f0 e0       	ldi	r31, 0x00	; 0
    3d18:	10 82       	st	Z, r1
			PORTA = SET_PORT;
    3d1a:	eb e3       	ldi	r30, 0x3B	; 59
    3d1c:	f0 e0       	ldi	r31, 0x00	; 0
    3d1e:	8f ef       	ldi	r24, 0xFF	; 255
    3d20:	80 83       	st	Z, r24
    3d22:	7e c0       	rjmp	.+252    	; 0x3e20 <DIO_vSetPortDirection+0x19a>
			break;
		case IPWOR:
			DDRA = CLEAR_PORT;
    3d24:	ea e3       	ldi	r30, 0x3A	; 58
    3d26:	f0 e0       	ldi	r31, 0x00	; 0
    3d28:	10 82       	st	Z, r1
			PORTA = CLEAR_PORT;
    3d2a:	eb e3       	ldi	r30, 0x3B	; 59
    3d2c:	f0 e0       	ldi	r31, 0x00	; 0
    3d2e:	10 82       	st	Z, r1
    3d30:	77 c0       	rjmp	.+238    	; 0x3e20 <DIO_vSetPortDirection+0x19a>
			break;
		}
		break;
	case PORT_B:
		switch (copy_u8state) {
    3d32:	8a 81       	ldd	r24, Y+2	; 0x02
    3d34:	28 2f       	mov	r18, r24
    3d36:	30 e0       	ldi	r19, 0x00	; 0
    3d38:	38 87       	std	Y+8, r19	; 0x08
    3d3a:	2f 83       	std	Y+7, r18	; 0x07
    3d3c:	8f 81       	ldd	r24, Y+7	; 0x07
    3d3e:	98 85       	ldd	r25, Y+8	; 0x08
    3d40:	81 30       	cpi	r24, 0x01	; 1
    3d42:	91 05       	cpc	r25, r1
    3d44:	b9 f0       	breq	.+46     	; 0x3d74 <DIO_vSetPortDirection+0xee>
    3d46:	2f 81       	ldd	r18, Y+7	; 0x07
    3d48:	38 85       	ldd	r19, Y+8	; 0x08
    3d4a:	22 30       	cpi	r18, 0x02	; 2
    3d4c:	31 05       	cpc	r19, r1
    3d4e:	29 f0       	breq	.+10     	; 0x3d5a <DIO_vSetPortDirection+0xd4>
    3d50:	8f 81       	ldd	r24, Y+7	; 0x07
    3d52:	98 85       	ldd	r25, Y+8	; 0x08
    3d54:	00 97       	sbiw	r24, 0x00	; 0
    3d56:	31 f0       	breq	.+12     	; 0x3d64 <DIO_vSetPortDirection+0xde>
    3d58:	63 c0       	rjmp	.+198    	; 0x3e20 <DIO_vSetPortDirection+0x19a>
		case OUTPUT:
			DDRB = SET_PORT;
    3d5a:	e7 e3       	ldi	r30, 0x37	; 55
    3d5c:	f0 e0       	ldi	r31, 0x00	; 0
    3d5e:	8f ef       	ldi	r24, 0xFF	; 255
    3d60:	80 83       	st	Z, r24
    3d62:	5e c0       	rjmp	.+188    	; 0x3e20 <DIO_vSetPortDirection+0x19a>
			break;
		case IPWR:
			DDRB = CLEAR_PORT;
    3d64:	e7 e3       	ldi	r30, 0x37	; 55
    3d66:	f0 e0       	ldi	r31, 0x00	; 0
    3d68:	10 82       	st	Z, r1
			PORTB = SET_PORT;
    3d6a:	e8 e3       	ldi	r30, 0x38	; 56
    3d6c:	f0 e0       	ldi	r31, 0x00	; 0
    3d6e:	8f ef       	ldi	r24, 0xFF	; 255
    3d70:	80 83       	st	Z, r24
    3d72:	56 c0       	rjmp	.+172    	; 0x3e20 <DIO_vSetPortDirection+0x19a>
			break;
		case IPWOR:
			DDRB = CLEAR_PORT;
    3d74:	e7 e3       	ldi	r30, 0x37	; 55
    3d76:	f0 e0       	ldi	r31, 0x00	; 0
    3d78:	10 82       	st	Z, r1
			PORTB = CLEAR_PORT;
    3d7a:	e8 e3       	ldi	r30, 0x38	; 56
    3d7c:	f0 e0       	ldi	r31, 0x00	; 0
    3d7e:	10 82       	st	Z, r1
    3d80:	4f c0       	rjmp	.+158    	; 0x3e20 <DIO_vSetPortDirection+0x19a>
			break;
		}
		break;
	case PORT_C:
		switch (copy_u8state) {
    3d82:	8a 81       	ldd	r24, Y+2	; 0x02
    3d84:	28 2f       	mov	r18, r24
    3d86:	30 e0       	ldi	r19, 0x00	; 0
    3d88:	3e 83       	std	Y+6, r19	; 0x06
    3d8a:	2d 83       	std	Y+5, r18	; 0x05
    3d8c:	8d 81       	ldd	r24, Y+5	; 0x05
    3d8e:	9e 81       	ldd	r25, Y+6	; 0x06
    3d90:	81 30       	cpi	r24, 0x01	; 1
    3d92:	91 05       	cpc	r25, r1
    3d94:	b9 f0       	breq	.+46     	; 0x3dc4 <DIO_vSetPortDirection+0x13e>
    3d96:	2d 81       	ldd	r18, Y+5	; 0x05
    3d98:	3e 81       	ldd	r19, Y+6	; 0x06
    3d9a:	22 30       	cpi	r18, 0x02	; 2
    3d9c:	31 05       	cpc	r19, r1
    3d9e:	29 f0       	breq	.+10     	; 0x3daa <DIO_vSetPortDirection+0x124>
    3da0:	8d 81       	ldd	r24, Y+5	; 0x05
    3da2:	9e 81       	ldd	r25, Y+6	; 0x06
    3da4:	00 97       	sbiw	r24, 0x00	; 0
    3da6:	31 f0       	breq	.+12     	; 0x3db4 <DIO_vSetPortDirection+0x12e>
    3da8:	3b c0       	rjmp	.+118    	; 0x3e20 <DIO_vSetPortDirection+0x19a>
		case OUTPUT:
			DDRC = SET_PORT;
    3daa:	e4 e3       	ldi	r30, 0x34	; 52
    3dac:	f0 e0       	ldi	r31, 0x00	; 0
    3dae:	8f ef       	ldi	r24, 0xFF	; 255
    3db0:	80 83       	st	Z, r24
    3db2:	36 c0       	rjmp	.+108    	; 0x3e20 <DIO_vSetPortDirection+0x19a>
			break;
		case IPWR:
			DDRC = CLEAR_PORT;
    3db4:	e4 e3       	ldi	r30, 0x34	; 52
    3db6:	f0 e0       	ldi	r31, 0x00	; 0
    3db8:	10 82       	st	Z, r1
			PORTC = SET_PORT;
    3dba:	e5 e3       	ldi	r30, 0x35	; 53
    3dbc:	f0 e0       	ldi	r31, 0x00	; 0
    3dbe:	8f ef       	ldi	r24, 0xFF	; 255
    3dc0:	80 83       	st	Z, r24
    3dc2:	2e c0       	rjmp	.+92     	; 0x3e20 <DIO_vSetPortDirection+0x19a>
			break;
		case IPWOR:
			DDRC = CLEAR_PORT;
    3dc4:	e4 e3       	ldi	r30, 0x34	; 52
    3dc6:	f0 e0       	ldi	r31, 0x00	; 0
    3dc8:	10 82       	st	Z, r1
			PORTC = CLEAR_PORT;
    3dca:	e5 e3       	ldi	r30, 0x35	; 53
    3dcc:	f0 e0       	ldi	r31, 0x00	; 0
    3dce:	10 82       	st	Z, r1
    3dd0:	27 c0       	rjmp	.+78     	; 0x3e20 <DIO_vSetPortDirection+0x19a>
			break;
		}
		break;
	case PORT_D:
		switch (copy_u8state) {
    3dd2:	8a 81       	ldd	r24, Y+2	; 0x02
    3dd4:	28 2f       	mov	r18, r24
    3dd6:	30 e0       	ldi	r19, 0x00	; 0
    3dd8:	3c 83       	std	Y+4, r19	; 0x04
    3dda:	2b 83       	std	Y+3, r18	; 0x03
    3ddc:	8b 81       	ldd	r24, Y+3	; 0x03
    3dde:	9c 81       	ldd	r25, Y+4	; 0x04
    3de0:	81 30       	cpi	r24, 0x01	; 1
    3de2:	91 05       	cpc	r25, r1
    3de4:	b9 f0       	breq	.+46     	; 0x3e14 <DIO_vSetPortDirection+0x18e>
    3de6:	2b 81       	ldd	r18, Y+3	; 0x03
    3de8:	3c 81       	ldd	r19, Y+4	; 0x04
    3dea:	22 30       	cpi	r18, 0x02	; 2
    3dec:	31 05       	cpc	r19, r1
    3dee:	29 f0       	breq	.+10     	; 0x3dfa <DIO_vSetPortDirection+0x174>
    3df0:	8b 81       	ldd	r24, Y+3	; 0x03
    3df2:	9c 81       	ldd	r25, Y+4	; 0x04
    3df4:	00 97       	sbiw	r24, 0x00	; 0
    3df6:	31 f0       	breq	.+12     	; 0x3e04 <DIO_vSetPortDirection+0x17e>
    3df8:	13 c0       	rjmp	.+38     	; 0x3e20 <DIO_vSetPortDirection+0x19a>
		case OUTPUT:
			DDRD = SET_PORT;
    3dfa:	e1 e3       	ldi	r30, 0x31	; 49
    3dfc:	f0 e0       	ldi	r31, 0x00	; 0
    3dfe:	8f ef       	ldi	r24, 0xFF	; 255
    3e00:	80 83       	st	Z, r24
    3e02:	0e c0       	rjmp	.+28     	; 0x3e20 <DIO_vSetPortDirection+0x19a>
			break;
		case IPWR:
			DDRD = CLEAR_PORT;
    3e04:	e1 e3       	ldi	r30, 0x31	; 49
    3e06:	f0 e0       	ldi	r31, 0x00	; 0
    3e08:	10 82       	st	Z, r1
			PORTD = SET_PORT;
    3e0a:	e2 e3       	ldi	r30, 0x32	; 50
    3e0c:	f0 e0       	ldi	r31, 0x00	; 0
    3e0e:	8f ef       	ldi	r24, 0xFF	; 255
    3e10:	80 83       	st	Z, r24
    3e12:	06 c0       	rjmp	.+12     	; 0x3e20 <DIO_vSetPortDirection+0x19a>
			break;
		case IPWOR:
			DDRD = CLEAR_PORT;
    3e14:	e1 e3       	ldi	r30, 0x31	; 49
    3e16:	f0 e0       	ldi	r31, 0x00	; 0
    3e18:	10 82       	st	Z, r1
			PORTD = CLEAR_PORT;
    3e1a:	e2 e3       	ldi	r30, 0x32	; 50
    3e1c:	f0 e0       	ldi	r31, 0x00	; 0
    3e1e:	10 82       	st	Z, r1
			break;
		}
		break;
	}

}
    3e20:	2c 96       	adiw	r28, 0x0c	; 12
    3e22:	0f b6       	in	r0, 0x3f	; 63
    3e24:	f8 94       	cli
    3e26:	de bf       	out	0x3e, r29	; 62
    3e28:	0f be       	out	0x3f, r0	; 63
    3e2a:	cd bf       	out	0x3d, r28	; 61
    3e2c:	cf 91       	pop	r28
    3e2e:	df 91       	pop	r29
    3e30:	08 95       	ret

00003e32 <DIO_vWritePort>:
 * Set or Clear PortX
 * Input:POrtX and value
 * OUTPUT:Nothing
 *
 *******************************************************************************/
void DIO_vWritePort(uint8 Copy_u8PORT, uint8 Copy_u8value) {
    3e32:	df 93       	push	r29
    3e34:	cf 93       	push	r28
    3e36:	cd b7       	in	r28, 0x3d	; 61
    3e38:	de b7       	in	r29, 0x3e	; 62
    3e3a:	2c 97       	sbiw	r28, 0x0c	; 12
    3e3c:	0f b6       	in	r0, 0x3f	; 63
    3e3e:	f8 94       	cli
    3e40:	de bf       	out	0x3e, r29	; 62
    3e42:	0f be       	out	0x3f, r0	; 63
    3e44:	cd bf       	out	0x3d, r28	; 61
    3e46:	89 83       	std	Y+1, r24	; 0x01
    3e48:	6a 83       	std	Y+2, r22	; 0x02
	switch (Copy_u8PORT) {
    3e4a:	89 81       	ldd	r24, Y+1	; 0x01
    3e4c:	28 2f       	mov	r18, r24
    3e4e:	30 e0       	ldi	r19, 0x00	; 0
    3e50:	3c 87       	std	Y+12, r19	; 0x0c
    3e52:	2b 87       	std	Y+11, r18	; 0x0b
    3e54:	8b 85       	ldd	r24, Y+11	; 0x0b
    3e56:	9c 85       	ldd	r25, Y+12	; 0x0c
    3e58:	81 30       	cpi	r24, 0x01	; 1
    3e5a:	91 05       	cpc	r25, r1
    3e5c:	71 f1       	breq	.+92     	; 0x3eba <DIO_vWritePort+0x88>
    3e5e:	2b 85       	ldd	r18, Y+11	; 0x0b
    3e60:	3c 85       	ldd	r19, Y+12	; 0x0c
    3e62:	22 30       	cpi	r18, 0x02	; 2
    3e64:	31 05       	cpc	r19, r1
    3e66:	2c f4       	brge	.+10     	; 0x3e72 <DIO_vWritePort+0x40>
    3e68:	8b 85       	ldd	r24, Y+11	; 0x0b
    3e6a:	9c 85       	ldd	r25, Y+12	; 0x0c
    3e6c:	00 97       	sbiw	r24, 0x00	; 0
    3e6e:	69 f0       	breq	.+26     	; 0x3e8a <DIO_vWritePort+0x58>
    3e70:	6b c0       	rjmp	.+214    	; 0x3f48 <DIO_vWritePort+0x116>
    3e72:	2b 85       	ldd	r18, Y+11	; 0x0b
    3e74:	3c 85       	ldd	r19, Y+12	; 0x0c
    3e76:	22 30       	cpi	r18, 0x02	; 2
    3e78:	31 05       	cpc	r19, r1
    3e7a:	b9 f1       	breq	.+110    	; 0x3eea <DIO_vWritePort+0xb8>
    3e7c:	8b 85       	ldd	r24, Y+11	; 0x0b
    3e7e:	9c 85       	ldd	r25, Y+12	; 0x0c
    3e80:	83 30       	cpi	r24, 0x03	; 3
    3e82:	91 05       	cpc	r25, r1
    3e84:	09 f4       	brne	.+2      	; 0x3e88 <DIO_vWritePort+0x56>
    3e86:	49 c0       	rjmp	.+146    	; 0x3f1a <DIO_vWritePort+0xe8>
    3e88:	5f c0       	rjmp	.+190    	; 0x3f48 <DIO_vWritePort+0x116>
	case PORT_A:
		switch (Copy_u8value) {
    3e8a:	8a 81       	ldd	r24, Y+2	; 0x02
    3e8c:	28 2f       	mov	r18, r24
    3e8e:	30 e0       	ldi	r19, 0x00	; 0
    3e90:	3a 87       	std	Y+10, r19	; 0x0a
    3e92:	29 87       	std	Y+9, r18	; 0x09
    3e94:	89 85       	ldd	r24, Y+9	; 0x09
    3e96:	9a 85       	ldd	r25, Y+10	; 0x0a
    3e98:	00 97       	sbiw	r24, 0x00	; 0
    3e9a:	31 f0       	breq	.+12     	; 0x3ea8 <DIO_vWritePort+0x76>
    3e9c:	29 85       	ldd	r18, Y+9	; 0x09
    3e9e:	3a 85       	ldd	r19, Y+10	; 0x0a
    3ea0:	21 30       	cpi	r18, 0x01	; 1
    3ea2:	31 05       	cpc	r19, r1
    3ea4:	29 f0       	breq	.+10     	; 0x3eb0 <DIO_vWritePort+0x7e>
    3ea6:	50 c0       	rjmp	.+160    	; 0x3f48 <DIO_vWritePort+0x116>
		case LOW:
			PORTA = CLEAR_PORT;
    3ea8:	eb e3       	ldi	r30, 0x3B	; 59
    3eaa:	f0 e0       	ldi	r31, 0x00	; 0
    3eac:	10 82       	st	Z, r1
    3eae:	4c c0       	rjmp	.+152    	; 0x3f48 <DIO_vWritePort+0x116>
			break;
		case HIGH:
			PORTA = SET_PORT;
    3eb0:	eb e3       	ldi	r30, 0x3B	; 59
    3eb2:	f0 e0       	ldi	r31, 0x00	; 0
    3eb4:	8f ef       	ldi	r24, 0xFF	; 255
    3eb6:	80 83       	st	Z, r24
    3eb8:	47 c0       	rjmp	.+142    	; 0x3f48 <DIO_vWritePort+0x116>
			break;

		}
		break;
	case PORT_B:
		switch (Copy_u8value) {
    3eba:	8a 81       	ldd	r24, Y+2	; 0x02
    3ebc:	28 2f       	mov	r18, r24
    3ebe:	30 e0       	ldi	r19, 0x00	; 0
    3ec0:	38 87       	std	Y+8, r19	; 0x08
    3ec2:	2f 83       	std	Y+7, r18	; 0x07
    3ec4:	8f 81       	ldd	r24, Y+7	; 0x07
    3ec6:	98 85       	ldd	r25, Y+8	; 0x08
    3ec8:	00 97       	sbiw	r24, 0x00	; 0
    3eca:	31 f0       	breq	.+12     	; 0x3ed8 <DIO_vWritePort+0xa6>
    3ecc:	2f 81       	ldd	r18, Y+7	; 0x07
    3ece:	38 85       	ldd	r19, Y+8	; 0x08
    3ed0:	21 30       	cpi	r18, 0x01	; 1
    3ed2:	31 05       	cpc	r19, r1
    3ed4:	29 f0       	breq	.+10     	; 0x3ee0 <DIO_vWritePort+0xae>
    3ed6:	38 c0       	rjmp	.+112    	; 0x3f48 <DIO_vWritePort+0x116>
		case LOW:
			PORTB = CLEAR_PORT;
    3ed8:	e8 e3       	ldi	r30, 0x38	; 56
    3eda:	f0 e0       	ldi	r31, 0x00	; 0
    3edc:	10 82       	st	Z, r1
    3ede:	34 c0       	rjmp	.+104    	; 0x3f48 <DIO_vWritePort+0x116>
			break;
		case HIGH:
			PORTB = SET_PORT;
    3ee0:	e8 e3       	ldi	r30, 0x38	; 56
    3ee2:	f0 e0       	ldi	r31, 0x00	; 0
    3ee4:	8f ef       	ldi	r24, 0xFF	; 255
    3ee6:	80 83       	st	Z, r24
    3ee8:	2f c0       	rjmp	.+94     	; 0x3f48 <DIO_vWritePort+0x116>
			break;

		}
		break;
	case PORT_C:
		switch (Copy_u8value) {
    3eea:	8a 81       	ldd	r24, Y+2	; 0x02
    3eec:	28 2f       	mov	r18, r24
    3eee:	30 e0       	ldi	r19, 0x00	; 0
    3ef0:	3e 83       	std	Y+6, r19	; 0x06
    3ef2:	2d 83       	std	Y+5, r18	; 0x05
    3ef4:	8d 81       	ldd	r24, Y+5	; 0x05
    3ef6:	9e 81       	ldd	r25, Y+6	; 0x06
    3ef8:	00 97       	sbiw	r24, 0x00	; 0
    3efa:	31 f0       	breq	.+12     	; 0x3f08 <DIO_vWritePort+0xd6>
    3efc:	2d 81       	ldd	r18, Y+5	; 0x05
    3efe:	3e 81       	ldd	r19, Y+6	; 0x06
    3f00:	21 30       	cpi	r18, 0x01	; 1
    3f02:	31 05       	cpc	r19, r1
    3f04:	29 f0       	breq	.+10     	; 0x3f10 <DIO_vWritePort+0xde>
    3f06:	20 c0       	rjmp	.+64     	; 0x3f48 <DIO_vWritePort+0x116>
		case LOW:
			PORTC = CLEAR_PORT;
    3f08:	e5 e3       	ldi	r30, 0x35	; 53
    3f0a:	f0 e0       	ldi	r31, 0x00	; 0
    3f0c:	10 82       	st	Z, r1
    3f0e:	1c c0       	rjmp	.+56     	; 0x3f48 <DIO_vWritePort+0x116>
			break;
		case HIGH:
			PORTC = SET_PORT;
    3f10:	e5 e3       	ldi	r30, 0x35	; 53
    3f12:	f0 e0       	ldi	r31, 0x00	; 0
    3f14:	8f ef       	ldi	r24, 0xFF	; 255
    3f16:	80 83       	st	Z, r24
    3f18:	17 c0       	rjmp	.+46     	; 0x3f48 <DIO_vWritePort+0x116>
			break;

		}
		break;
	case PORT_D:
		switch (Copy_u8value) {
    3f1a:	8a 81       	ldd	r24, Y+2	; 0x02
    3f1c:	28 2f       	mov	r18, r24
    3f1e:	30 e0       	ldi	r19, 0x00	; 0
    3f20:	3c 83       	std	Y+4, r19	; 0x04
    3f22:	2b 83       	std	Y+3, r18	; 0x03
    3f24:	8b 81       	ldd	r24, Y+3	; 0x03
    3f26:	9c 81       	ldd	r25, Y+4	; 0x04
    3f28:	00 97       	sbiw	r24, 0x00	; 0
    3f2a:	31 f0       	breq	.+12     	; 0x3f38 <DIO_vWritePort+0x106>
    3f2c:	2b 81       	ldd	r18, Y+3	; 0x03
    3f2e:	3c 81       	ldd	r19, Y+4	; 0x04
    3f30:	21 30       	cpi	r18, 0x01	; 1
    3f32:	31 05       	cpc	r19, r1
    3f34:	29 f0       	breq	.+10     	; 0x3f40 <DIO_vWritePort+0x10e>
    3f36:	08 c0       	rjmp	.+16     	; 0x3f48 <DIO_vWritePort+0x116>
		case LOW:
			PORTD = CLEAR_PORT;
    3f38:	e2 e3       	ldi	r30, 0x32	; 50
    3f3a:	f0 e0       	ldi	r31, 0x00	; 0
    3f3c:	10 82       	st	Z, r1
    3f3e:	04 c0       	rjmp	.+8      	; 0x3f48 <DIO_vWritePort+0x116>
			break;
		case HIGH:
			PORTD = SET_PORT;
    3f40:	e2 e3       	ldi	r30, 0x32	; 50
    3f42:	f0 e0       	ldi	r31, 0x00	; 0
    3f44:	8f ef       	ldi	r24, 0xFF	; 255
    3f46:	80 83       	st	Z, r24
			break;

		}
		break;
	}
}
    3f48:	2c 96       	adiw	r28, 0x0c	; 12
    3f4a:	0f b6       	in	r0, 0x3f	; 63
    3f4c:	f8 94       	cli
    3f4e:	de bf       	out	0x3e, r29	; 62
    3f50:	0f be       	out	0x3f, r0	; 63
    3f52:	cd bf       	out	0x3d, r28	; 61
    3f54:	cf 91       	pop	r28
    3f56:	df 91       	pop	r29
    3f58:	08 95       	ret

00003f5a <DIO_vTogglrPort>:
 * Description:void DIO_vTogglrPort(port Copy_u8PORT)
 * toggle port
 * input:PORTX
 * OUTPUT:Nothing
 ****************************************************************************/
void DIO_vTogglrPort(uint8 Copy_u8PORT) {
    3f5a:	df 93       	push	r29
    3f5c:	cf 93       	push	r28
    3f5e:	00 d0       	rcall	.+0      	; 0x3f60 <DIO_vTogglrPort+0x6>
    3f60:	0f 92       	push	r0
    3f62:	cd b7       	in	r28, 0x3d	; 61
    3f64:	de b7       	in	r29, 0x3e	; 62
    3f66:	89 83       	std	Y+1, r24	; 0x01
	switch (Copy_u8PORT) {
    3f68:	89 81       	ldd	r24, Y+1	; 0x01
    3f6a:	28 2f       	mov	r18, r24
    3f6c:	30 e0       	ldi	r19, 0x00	; 0
    3f6e:	3b 83       	std	Y+3, r19	; 0x03
    3f70:	2a 83       	std	Y+2, r18	; 0x02
    3f72:	8a 81       	ldd	r24, Y+2	; 0x02
    3f74:	9b 81       	ldd	r25, Y+3	; 0x03
    3f76:	81 30       	cpi	r24, 0x01	; 1
    3f78:	91 05       	cpc	r25, r1
    3f7a:	01 f1       	breq	.+64     	; 0x3fbc <DIO_vTogglrPort+0x62>
    3f7c:	2a 81       	ldd	r18, Y+2	; 0x02
    3f7e:	3b 81       	ldd	r19, Y+3	; 0x03
    3f80:	22 30       	cpi	r18, 0x02	; 2
    3f82:	31 05       	cpc	r19, r1
    3f84:	2c f4       	brge	.+10     	; 0x3f90 <DIO_vTogglrPort+0x36>
    3f86:	8a 81       	ldd	r24, Y+2	; 0x02
    3f88:	9b 81       	ldd	r25, Y+3	; 0x03
    3f8a:	00 97       	sbiw	r24, 0x00	; 0
    3f8c:	61 f0       	breq	.+24     	; 0x3fa6 <DIO_vTogglrPort+0x4c>
    3f8e:	36 c0       	rjmp	.+108    	; 0x3ffc <DIO_vTogglrPort+0xa2>
    3f90:	2a 81       	ldd	r18, Y+2	; 0x02
    3f92:	3b 81       	ldd	r19, Y+3	; 0x03
    3f94:	22 30       	cpi	r18, 0x02	; 2
    3f96:	31 05       	cpc	r19, r1
    3f98:	e1 f0       	breq	.+56     	; 0x3fd2 <DIO_vTogglrPort+0x78>
    3f9a:	8a 81       	ldd	r24, Y+2	; 0x02
    3f9c:	9b 81       	ldd	r25, Y+3	; 0x03
    3f9e:	83 30       	cpi	r24, 0x03	; 3
    3fa0:	91 05       	cpc	r25, r1
    3fa2:	11 f1       	breq	.+68     	; 0x3fe8 <DIO_vTogglrPort+0x8e>
    3fa4:	2b c0       	rjmp	.+86     	; 0x3ffc <DIO_vTogglrPort+0xa2>
	case PORT_A:
		PORTA ^= PORTA;
    3fa6:	ab e3       	ldi	r26, 0x3B	; 59
    3fa8:	b0 e0       	ldi	r27, 0x00	; 0
    3faa:	eb e3       	ldi	r30, 0x3B	; 59
    3fac:	f0 e0       	ldi	r31, 0x00	; 0
    3fae:	90 81       	ld	r25, Z
    3fb0:	eb e3       	ldi	r30, 0x3B	; 59
    3fb2:	f0 e0       	ldi	r31, 0x00	; 0
    3fb4:	80 81       	ld	r24, Z
    3fb6:	89 27       	eor	r24, r25
    3fb8:	8c 93       	st	X, r24
    3fba:	20 c0       	rjmp	.+64     	; 0x3ffc <DIO_vTogglrPort+0xa2>
		break;
	case PORT_B:
		PORTB ^= PORTB;
    3fbc:	a8 e3       	ldi	r26, 0x38	; 56
    3fbe:	b0 e0       	ldi	r27, 0x00	; 0
    3fc0:	e8 e3       	ldi	r30, 0x38	; 56
    3fc2:	f0 e0       	ldi	r31, 0x00	; 0
    3fc4:	90 81       	ld	r25, Z
    3fc6:	e8 e3       	ldi	r30, 0x38	; 56
    3fc8:	f0 e0       	ldi	r31, 0x00	; 0
    3fca:	80 81       	ld	r24, Z
    3fcc:	89 27       	eor	r24, r25
    3fce:	8c 93       	st	X, r24
    3fd0:	15 c0       	rjmp	.+42     	; 0x3ffc <DIO_vTogglrPort+0xa2>
		break;
	case PORT_C:
		PORTC ^= PORTC;
    3fd2:	a5 e3       	ldi	r26, 0x35	; 53
    3fd4:	b0 e0       	ldi	r27, 0x00	; 0
    3fd6:	e5 e3       	ldi	r30, 0x35	; 53
    3fd8:	f0 e0       	ldi	r31, 0x00	; 0
    3fda:	90 81       	ld	r25, Z
    3fdc:	e5 e3       	ldi	r30, 0x35	; 53
    3fde:	f0 e0       	ldi	r31, 0x00	; 0
    3fe0:	80 81       	ld	r24, Z
    3fe2:	89 27       	eor	r24, r25
    3fe4:	8c 93       	st	X, r24
    3fe6:	0a c0       	rjmp	.+20     	; 0x3ffc <DIO_vTogglrPort+0xa2>
		break;
	case PORT_D:
		PORTD ^= PORTD;
    3fe8:	a2 e3       	ldi	r26, 0x32	; 50
    3fea:	b0 e0       	ldi	r27, 0x00	; 0
    3fec:	e2 e3       	ldi	r30, 0x32	; 50
    3fee:	f0 e0       	ldi	r31, 0x00	; 0
    3ff0:	90 81       	ld	r25, Z
    3ff2:	e2 e3       	ldi	r30, 0x32	; 50
    3ff4:	f0 e0       	ldi	r31, 0x00	; 0
    3ff6:	80 81       	ld	r24, Z
    3ff8:	89 27       	eor	r24, r25
    3ffa:	8c 93       	st	X, r24

	}

}
    3ffc:	0f 90       	pop	r0
    3ffe:	0f 90       	pop	r0
    4000:	0f 90       	pop	r0
    4002:	cf 91       	pop	r28
    4004:	df 91       	pop	r29
    4006:	08 95       	ret

00004008 <DIO_vWritePortValue>:

void DIO_vWritePortValue(uint8 Copy_u8PORT, uint8 Copy_u8value) {
    4008:	df 93       	push	r29
    400a:	cf 93       	push	r28
    400c:	00 d0       	rcall	.+0      	; 0x400e <DIO_vWritePortValue+0x6>
    400e:	00 d0       	rcall	.+0      	; 0x4010 <DIO_vWritePortValue+0x8>
    4010:	cd b7       	in	r28, 0x3d	; 61
    4012:	de b7       	in	r29, 0x3e	; 62
    4014:	89 83       	std	Y+1, r24	; 0x01
    4016:	6a 83       	std	Y+2, r22	; 0x02
	switch (Copy_u8PORT) {
    4018:	89 81       	ldd	r24, Y+1	; 0x01
    401a:	28 2f       	mov	r18, r24
    401c:	30 e0       	ldi	r19, 0x00	; 0
    401e:	3c 83       	std	Y+4, r19	; 0x04
    4020:	2b 83       	std	Y+3, r18	; 0x03
    4022:	8b 81       	ldd	r24, Y+3	; 0x03
    4024:	9c 81       	ldd	r25, Y+4	; 0x04
    4026:	81 30       	cpi	r24, 0x01	; 1
    4028:	91 05       	cpc	r25, r1
    402a:	d1 f0       	breq	.+52     	; 0x4060 <DIO_vWritePortValue+0x58>
    402c:	2b 81       	ldd	r18, Y+3	; 0x03
    402e:	3c 81       	ldd	r19, Y+4	; 0x04
    4030:	22 30       	cpi	r18, 0x02	; 2
    4032:	31 05       	cpc	r19, r1
    4034:	2c f4       	brge	.+10     	; 0x4040 <DIO_vWritePortValue+0x38>
    4036:	8b 81       	ldd	r24, Y+3	; 0x03
    4038:	9c 81       	ldd	r25, Y+4	; 0x04
    403a:	00 97       	sbiw	r24, 0x00	; 0
    403c:	61 f0       	breq	.+24     	; 0x4056 <DIO_vWritePortValue+0x4e>
    403e:	1e c0       	rjmp	.+60     	; 0x407c <DIO_vWritePortValue+0x74>
    4040:	2b 81       	ldd	r18, Y+3	; 0x03
    4042:	3c 81       	ldd	r19, Y+4	; 0x04
    4044:	22 30       	cpi	r18, 0x02	; 2
    4046:	31 05       	cpc	r19, r1
    4048:	81 f0       	breq	.+32     	; 0x406a <DIO_vWritePortValue+0x62>
    404a:	8b 81       	ldd	r24, Y+3	; 0x03
    404c:	9c 81       	ldd	r25, Y+4	; 0x04
    404e:	83 30       	cpi	r24, 0x03	; 3
    4050:	91 05       	cpc	r25, r1
    4052:	81 f0       	breq	.+32     	; 0x4074 <DIO_vWritePortValue+0x6c>
    4054:	13 c0       	rjmp	.+38     	; 0x407c <DIO_vWritePortValue+0x74>
	case PORT_A:
		PORTA = Copy_u8value;
    4056:	eb e3       	ldi	r30, 0x3B	; 59
    4058:	f0 e0       	ldi	r31, 0x00	; 0
    405a:	8a 81       	ldd	r24, Y+2	; 0x02
    405c:	80 83       	st	Z, r24
    405e:	0e c0       	rjmp	.+28     	; 0x407c <DIO_vWritePortValue+0x74>
		break;
	case PORT_B:
		PORTB = Copy_u8value;
    4060:	e8 e3       	ldi	r30, 0x38	; 56
    4062:	f0 e0       	ldi	r31, 0x00	; 0
    4064:	8a 81       	ldd	r24, Y+2	; 0x02
    4066:	80 83       	st	Z, r24
    4068:	09 c0       	rjmp	.+18     	; 0x407c <DIO_vWritePortValue+0x74>
		break;
	case PORT_C:
		PORTC = Copy_u8value;
    406a:	e5 e3       	ldi	r30, 0x35	; 53
    406c:	f0 e0       	ldi	r31, 0x00	; 0
    406e:	8a 81       	ldd	r24, Y+2	; 0x02
    4070:	80 83       	st	Z, r24
    4072:	04 c0       	rjmp	.+8      	; 0x407c <DIO_vWritePortValue+0x74>
		break;
	case PORT_D:
		PORTD = Copy_u8value;
    4074:	e2 e3       	ldi	r30, 0x32	; 50
    4076:	f0 e0       	ldi	r31, 0x00	; 0
    4078:	8a 81       	ldd	r24, Y+2	; 0x02
    407a:	80 83       	st	Z, r24
		break;

	}
}
    407c:	0f 90       	pop	r0
    407e:	0f 90       	pop	r0
    4080:	0f 90       	pop	r0
    4082:	0f 90       	pop	r0
    4084:	cf 91       	pop	r28
    4086:	df 91       	pop	r29
    4088:	08 95       	ret

0000408a <LCD_vWriteCommand>:
 * Description:
 * Input:
 * OUTPUT:
 * ***************************************************************/
void LCD_vWriteCommand(uint8 Command)
{
    408a:	df 93       	push	r29
    408c:	cf 93       	push	r28
    408e:	cd b7       	in	r28, 0x3d	; 61
    4090:	de b7       	in	r29, 0x3e	; 62
    4092:	6d 97       	sbiw	r28, 0x1d	; 29
    4094:	0f b6       	in	r0, 0x3f	; 63
    4096:	f8 94       	cli
    4098:	de bf       	out	0x3e, r29	; 62
    409a:	0f be       	out	0x3f, r0	; 63
    409c:	cd bf       	out	0x3d, r28	; 61
    409e:	8d 8f       	std	Y+29, r24	; 0x1d
	/*1- R/S equal to zero */
	DIO_vWritePin(CONFIG_PORT,RS_PIN,LOW);
    40a0:	82 e0       	ldi	r24, 0x02	; 2
    40a2:	65 e0       	ldi	r22, 0x05	; 5
    40a4:	40 e0       	ldi	r20, 0x00	; 0
    40a6:	0e 94 04 1c 	call	0x3808	; 0x3808 <DIO_vWritePin>
	/*2- R/W equal to zero */
	DIO_vWritePin(CONFIG_PORT,RW_PIN,LOW);
    40aa:	82 e0       	ldi	r24, 0x02	; 2
    40ac:	66 e0       	ldi	r22, 0x06	; 6
    40ae:	40 e0       	ldi	r20, 0x00	; 0
    40b0:	0e 94 04 1c 	call	0x3808	; 0x3808 <DIO_vWritePin>
	/*3- send high nibble */
	DIO_vWritePin(DATA_PORT,DATA_PIN4,((Command & 0x10)>>DATA_PIN4));
    40b4:	8d 8d       	ldd	r24, Y+29	; 0x1d
    40b6:	88 2f       	mov	r24, r24
    40b8:	90 e0       	ldi	r25, 0x00	; 0
    40ba:	80 71       	andi	r24, 0x10	; 16
    40bc:	90 70       	andi	r25, 0x00	; 0
    40be:	95 95       	asr	r25
    40c0:	87 95       	ror	r24
    40c2:	95 95       	asr	r25
    40c4:	87 95       	ror	r24
    40c6:	95 95       	asr	r25
    40c8:	87 95       	ror	r24
    40ca:	95 95       	asr	r25
    40cc:	87 95       	ror	r24
    40ce:	98 2f       	mov	r25, r24
    40d0:	80 e0       	ldi	r24, 0x00	; 0
    40d2:	64 e0       	ldi	r22, 0x04	; 4
    40d4:	49 2f       	mov	r20, r25
    40d6:	0e 94 04 1c 	call	0x3808	; 0x3808 <DIO_vWritePin>
	DIO_vWritePin(DATA_PORT,DATA_PIN5,((Command & 0x20)>>DATA_PIN5));
    40da:	8d 8d       	ldd	r24, Y+29	; 0x1d
    40dc:	88 2f       	mov	r24, r24
    40de:	90 e0       	ldi	r25, 0x00	; 0
    40e0:	80 72       	andi	r24, 0x20	; 32
    40e2:	90 70       	andi	r25, 0x00	; 0
    40e4:	95 95       	asr	r25
    40e6:	87 95       	ror	r24
    40e8:	95 95       	asr	r25
    40ea:	87 95       	ror	r24
    40ec:	95 95       	asr	r25
    40ee:	87 95       	ror	r24
    40f0:	95 95       	asr	r25
    40f2:	87 95       	ror	r24
    40f4:	95 95       	asr	r25
    40f6:	87 95       	ror	r24
    40f8:	98 2f       	mov	r25, r24
    40fa:	80 e0       	ldi	r24, 0x00	; 0
    40fc:	65 e0       	ldi	r22, 0x05	; 5
    40fe:	49 2f       	mov	r20, r25
    4100:	0e 94 04 1c 	call	0x3808	; 0x3808 <DIO_vWritePin>
	DIO_vWritePin(DATA_PORT,DATA_PIN6,((Command & 0x40)>>DATA_PIN6));
    4104:	8d 8d       	ldd	r24, Y+29	; 0x1d
    4106:	88 2f       	mov	r24, r24
    4108:	90 e0       	ldi	r25, 0x00	; 0
    410a:	80 74       	andi	r24, 0x40	; 64
    410c:	90 70       	andi	r25, 0x00	; 0
    410e:	08 2e       	mov	r0, r24
    4110:	89 2f       	mov	r24, r25
    4112:	00 0c       	add	r0, r0
    4114:	88 1f       	adc	r24, r24
    4116:	99 0b       	sbc	r25, r25
    4118:	00 0c       	add	r0, r0
    411a:	88 1f       	adc	r24, r24
    411c:	99 1f       	adc	r25, r25
    411e:	98 2f       	mov	r25, r24
    4120:	80 e0       	ldi	r24, 0x00	; 0
    4122:	66 e0       	ldi	r22, 0x06	; 6
    4124:	49 2f       	mov	r20, r25
    4126:	0e 94 04 1c 	call	0x3808	; 0x3808 <DIO_vWritePin>
	DIO_vWritePin(DATA_PORT,DATA_PIN7,((Command & 0x80)>>DATA_PIN7));
    412a:	8d 8d       	ldd	r24, Y+29	; 0x1d
    412c:	98 2f       	mov	r25, r24
    412e:	99 1f       	adc	r25, r25
    4130:	99 27       	eor	r25, r25
    4132:	99 1f       	adc	r25, r25
    4134:	80 e0       	ldi	r24, 0x00	; 0
    4136:	67 e0       	ldi	r22, 0x07	; 7
    4138:	49 2f       	mov	r20, r25
    413a:	0e 94 04 1c 	call	0x3808	; 0x3808 <DIO_vWritePin>
	DIO_vWritePin(CONFIG_PORT,ENABLE,HIGH);
    413e:	82 e0       	ldi	r24, 0x02	; 2
    4140:	67 e0       	ldi	r22, 0x07	; 7
    4142:	41 e0       	ldi	r20, 0x01	; 1
    4144:	0e 94 04 1c 	call	0x3808	; 0x3808 <DIO_vWritePin>
    4148:	80 e0       	ldi	r24, 0x00	; 0
    414a:	90 e0       	ldi	r25, 0x00	; 0
    414c:	a0 e0       	ldi	r26, 0x00	; 0
    414e:	b0 e4       	ldi	r27, 0x40	; 64
    4150:	89 8f       	std	Y+25, r24	; 0x19
    4152:	9a 8f       	std	Y+26, r25	; 0x1a
    4154:	ab 8f       	std	Y+27, r26	; 0x1b
    4156:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    4158:	69 8d       	ldd	r22, Y+25	; 0x19
    415a:	7a 8d       	ldd	r23, Y+26	; 0x1a
    415c:	8b 8d       	ldd	r24, Y+27	; 0x1b
    415e:	9c 8d       	ldd	r25, Y+28	; 0x1c
    4160:	20 e0       	ldi	r18, 0x00	; 0
    4162:	30 e0       	ldi	r19, 0x00	; 0
    4164:	4a ef       	ldi	r20, 0xFA	; 250
    4166:	54 e4       	ldi	r21, 0x44	; 68
    4168:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    416c:	dc 01       	movw	r26, r24
    416e:	cb 01       	movw	r24, r22
    4170:	8d 8b       	std	Y+21, r24	; 0x15
    4172:	9e 8b       	std	Y+22, r25	; 0x16
    4174:	af 8b       	std	Y+23, r26	; 0x17
    4176:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    4178:	6d 89       	ldd	r22, Y+21	; 0x15
    417a:	7e 89       	ldd	r23, Y+22	; 0x16
    417c:	8f 89       	ldd	r24, Y+23	; 0x17
    417e:	98 8d       	ldd	r25, Y+24	; 0x18
    4180:	20 e0       	ldi	r18, 0x00	; 0
    4182:	30 e0       	ldi	r19, 0x00	; 0
    4184:	40 e8       	ldi	r20, 0x80	; 128
    4186:	5f e3       	ldi	r21, 0x3F	; 63
    4188:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    418c:	88 23       	and	r24, r24
    418e:	2c f4       	brge	.+10     	; 0x419a <LCD_vWriteCommand+0x110>
		__ticks = 1;
    4190:	81 e0       	ldi	r24, 0x01	; 1
    4192:	90 e0       	ldi	r25, 0x00	; 0
    4194:	9c 8b       	std	Y+20, r25	; 0x14
    4196:	8b 8b       	std	Y+19, r24	; 0x13
    4198:	3f c0       	rjmp	.+126    	; 0x4218 <LCD_vWriteCommand+0x18e>
	else if (__tmp > 65535)
    419a:	6d 89       	ldd	r22, Y+21	; 0x15
    419c:	7e 89       	ldd	r23, Y+22	; 0x16
    419e:	8f 89       	ldd	r24, Y+23	; 0x17
    41a0:	98 8d       	ldd	r25, Y+24	; 0x18
    41a2:	20 e0       	ldi	r18, 0x00	; 0
    41a4:	3f ef       	ldi	r19, 0xFF	; 255
    41a6:	4f e7       	ldi	r20, 0x7F	; 127
    41a8:	57 e4       	ldi	r21, 0x47	; 71
    41aa:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    41ae:	18 16       	cp	r1, r24
    41b0:	4c f5       	brge	.+82     	; 0x4204 <LCD_vWriteCommand+0x17a>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    41b2:	69 8d       	ldd	r22, Y+25	; 0x19
    41b4:	7a 8d       	ldd	r23, Y+26	; 0x1a
    41b6:	8b 8d       	ldd	r24, Y+27	; 0x1b
    41b8:	9c 8d       	ldd	r25, Y+28	; 0x1c
    41ba:	20 e0       	ldi	r18, 0x00	; 0
    41bc:	30 e0       	ldi	r19, 0x00	; 0
    41be:	40 e2       	ldi	r20, 0x20	; 32
    41c0:	51 e4       	ldi	r21, 0x41	; 65
    41c2:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    41c6:	dc 01       	movw	r26, r24
    41c8:	cb 01       	movw	r24, r22
    41ca:	bc 01       	movw	r22, r24
    41cc:	cd 01       	movw	r24, r26
    41ce:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    41d2:	dc 01       	movw	r26, r24
    41d4:	cb 01       	movw	r24, r22
    41d6:	9c 8b       	std	Y+20, r25	; 0x14
    41d8:	8b 8b       	std	Y+19, r24	; 0x13
    41da:	0f c0       	rjmp	.+30     	; 0x41fa <LCD_vWriteCommand+0x170>
    41dc:	88 ec       	ldi	r24, 0xC8	; 200
    41de:	90 e0       	ldi	r25, 0x00	; 0
    41e0:	9a 8b       	std	Y+18, r25	; 0x12
    41e2:	89 8b       	std	Y+17, r24	; 0x11
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    41e4:	89 89       	ldd	r24, Y+17	; 0x11
    41e6:	9a 89       	ldd	r25, Y+18	; 0x12
    41e8:	01 97       	sbiw	r24, 0x01	; 1
    41ea:	f1 f7       	brne	.-4      	; 0x41e8 <LCD_vWriteCommand+0x15e>
    41ec:	9a 8b       	std	Y+18, r25	; 0x12
    41ee:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    41f0:	8b 89       	ldd	r24, Y+19	; 0x13
    41f2:	9c 89       	ldd	r25, Y+20	; 0x14
    41f4:	01 97       	sbiw	r24, 0x01	; 1
    41f6:	9c 8b       	std	Y+20, r25	; 0x14
    41f8:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    41fa:	8b 89       	ldd	r24, Y+19	; 0x13
    41fc:	9c 89       	ldd	r25, Y+20	; 0x14
    41fe:	00 97       	sbiw	r24, 0x00	; 0
    4200:	69 f7       	brne	.-38     	; 0x41dc <LCD_vWriteCommand+0x152>
    4202:	14 c0       	rjmp	.+40     	; 0x422c <LCD_vWriteCommand+0x1a2>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    4204:	6d 89       	ldd	r22, Y+21	; 0x15
    4206:	7e 89       	ldd	r23, Y+22	; 0x16
    4208:	8f 89       	ldd	r24, Y+23	; 0x17
    420a:	98 8d       	ldd	r25, Y+24	; 0x18
    420c:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    4210:	dc 01       	movw	r26, r24
    4212:	cb 01       	movw	r24, r22
    4214:	9c 8b       	std	Y+20, r25	; 0x14
    4216:	8b 8b       	std	Y+19, r24	; 0x13
    4218:	8b 89       	ldd	r24, Y+19	; 0x13
    421a:	9c 89       	ldd	r25, Y+20	; 0x14
    421c:	98 8b       	std	Y+16, r25	; 0x10
    421e:	8f 87       	std	Y+15, r24	; 0x0f
    4220:	8f 85       	ldd	r24, Y+15	; 0x0f
    4222:	98 89       	ldd	r25, Y+16	; 0x10
    4224:	01 97       	sbiw	r24, 0x01	; 1
    4226:	f1 f7       	brne	.-4      	; 0x4224 <LCD_vWriteCommand+0x19a>
    4228:	98 8b       	std	Y+16, r25	; 0x10
    422a:	8f 87       	std	Y+15, r24	; 0x0f
	_delay_ms(2);
	DIO_vWritePin(CONFIG_PORT,ENABLE,LOW);
    422c:	82 e0       	ldi	r24, 0x02	; 2
    422e:	67 e0       	ldi	r22, 0x07	; 7
    4230:	40 e0       	ldi	r20, 0x00	; 0
    4232:	0e 94 04 1c 	call	0x3808	; 0x3808 <DIO_vWritePin>
	/* send low Nibble */
	DIO_vWritePin(DATA_PORT,DATA_PIN4,((Command & 0x01)));
    4236:	8d 8d       	ldd	r24, Y+29	; 0x1d
    4238:	98 2f       	mov	r25, r24
    423a:	91 70       	andi	r25, 0x01	; 1
    423c:	80 e0       	ldi	r24, 0x00	; 0
    423e:	64 e0       	ldi	r22, 0x04	; 4
    4240:	49 2f       	mov	r20, r25
    4242:	0e 94 04 1c 	call	0x3808	; 0x3808 <DIO_vWritePin>
	DIO_vWritePin(DATA_PORT,DATA_PIN5,((Command & 0x02)>>(DATA_PIN5-CONSTANT)));
    4246:	8d 8d       	ldd	r24, Y+29	; 0x1d
    4248:	88 2f       	mov	r24, r24
    424a:	90 e0       	ldi	r25, 0x00	; 0
    424c:	82 70       	andi	r24, 0x02	; 2
    424e:	90 70       	andi	r25, 0x00	; 0
    4250:	95 95       	asr	r25
    4252:	87 95       	ror	r24
    4254:	98 2f       	mov	r25, r24
    4256:	80 e0       	ldi	r24, 0x00	; 0
    4258:	65 e0       	ldi	r22, 0x05	; 5
    425a:	49 2f       	mov	r20, r25
    425c:	0e 94 04 1c 	call	0x3808	; 0x3808 <DIO_vWritePin>
	DIO_vWritePin(DATA_PORT,DATA_PIN6,((Command & 0x04)>>(DATA_PIN6-CONSTANT)));
    4260:	8d 8d       	ldd	r24, Y+29	; 0x1d
    4262:	88 2f       	mov	r24, r24
    4264:	90 e0       	ldi	r25, 0x00	; 0
    4266:	84 70       	andi	r24, 0x04	; 4
    4268:	90 70       	andi	r25, 0x00	; 0
    426a:	95 95       	asr	r25
    426c:	87 95       	ror	r24
    426e:	95 95       	asr	r25
    4270:	87 95       	ror	r24
    4272:	98 2f       	mov	r25, r24
    4274:	80 e0       	ldi	r24, 0x00	; 0
    4276:	66 e0       	ldi	r22, 0x06	; 6
    4278:	49 2f       	mov	r20, r25
    427a:	0e 94 04 1c 	call	0x3808	; 0x3808 <DIO_vWritePin>
	DIO_vWritePin(DATA_PORT,DATA_PIN7,((Command & 0x08)>>(DATA_PIN7-CONSTANT)));
    427e:	8d 8d       	ldd	r24, Y+29	; 0x1d
    4280:	88 2f       	mov	r24, r24
    4282:	90 e0       	ldi	r25, 0x00	; 0
    4284:	88 70       	andi	r24, 0x08	; 8
    4286:	90 70       	andi	r25, 0x00	; 0
    4288:	95 95       	asr	r25
    428a:	87 95       	ror	r24
    428c:	95 95       	asr	r25
    428e:	87 95       	ror	r24
    4290:	95 95       	asr	r25
    4292:	87 95       	ror	r24
    4294:	98 2f       	mov	r25, r24
    4296:	80 e0       	ldi	r24, 0x00	; 0
    4298:	67 e0       	ldi	r22, 0x07	; 7
    429a:	49 2f       	mov	r20, r25
    429c:	0e 94 04 1c 	call	0x3808	; 0x3808 <DIO_vWritePin>
	DIO_vWritePin(CONFIG_PORT,ENABLE,HIGH);
    42a0:	82 e0       	ldi	r24, 0x02	; 2
    42a2:	67 e0       	ldi	r22, 0x07	; 7
    42a4:	41 e0       	ldi	r20, 0x01	; 1
    42a6:	0e 94 04 1c 	call	0x3808	; 0x3808 <DIO_vWritePin>
    42aa:	80 e0       	ldi	r24, 0x00	; 0
    42ac:	90 e0       	ldi	r25, 0x00	; 0
    42ae:	a0 e0       	ldi	r26, 0x00	; 0
    42b0:	b0 e4       	ldi	r27, 0x40	; 64
    42b2:	8b 87       	std	Y+11, r24	; 0x0b
    42b4:	9c 87       	std	Y+12, r25	; 0x0c
    42b6:	ad 87       	std	Y+13, r26	; 0x0d
    42b8:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    42ba:	6b 85       	ldd	r22, Y+11	; 0x0b
    42bc:	7c 85       	ldd	r23, Y+12	; 0x0c
    42be:	8d 85       	ldd	r24, Y+13	; 0x0d
    42c0:	9e 85       	ldd	r25, Y+14	; 0x0e
    42c2:	20 e0       	ldi	r18, 0x00	; 0
    42c4:	30 e0       	ldi	r19, 0x00	; 0
    42c6:	4a ef       	ldi	r20, 0xFA	; 250
    42c8:	54 e4       	ldi	r21, 0x44	; 68
    42ca:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    42ce:	dc 01       	movw	r26, r24
    42d0:	cb 01       	movw	r24, r22
    42d2:	8f 83       	std	Y+7, r24	; 0x07
    42d4:	98 87       	std	Y+8, r25	; 0x08
    42d6:	a9 87       	std	Y+9, r26	; 0x09
    42d8:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    42da:	6f 81       	ldd	r22, Y+7	; 0x07
    42dc:	78 85       	ldd	r23, Y+8	; 0x08
    42de:	89 85       	ldd	r24, Y+9	; 0x09
    42e0:	9a 85       	ldd	r25, Y+10	; 0x0a
    42e2:	20 e0       	ldi	r18, 0x00	; 0
    42e4:	30 e0       	ldi	r19, 0x00	; 0
    42e6:	40 e8       	ldi	r20, 0x80	; 128
    42e8:	5f e3       	ldi	r21, 0x3F	; 63
    42ea:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    42ee:	88 23       	and	r24, r24
    42f0:	2c f4       	brge	.+10     	; 0x42fc <LCD_vWriteCommand+0x272>
		__ticks = 1;
    42f2:	81 e0       	ldi	r24, 0x01	; 1
    42f4:	90 e0       	ldi	r25, 0x00	; 0
    42f6:	9e 83       	std	Y+6, r25	; 0x06
    42f8:	8d 83       	std	Y+5, r24	; 0x05
    42fa:	3f c0       	rjmp	.+126    	; 0x437a <LCD_vWriteCommand+0x2f0>
	else if (__tmp > 65535)
    42fc:	6f 81       	ldd	r22, Y+7	; 0x07
    42fe:	78 85       	ldd	r23, Y+8	; 0x08
    4300:	89 85       	ldd	r24, Y+9	; 0x09
    4302:	9a 85       	ldd	r25, Y+10	; 0x0a
    4304:	20 e0       	ldi	r18, 0x00	; 0
    4306:	3f ef       	ldi	r19, 0xFF	; 255
    4308:	4f e7       	ldi	r20, 0x7F	; 127
    430a:	57 e4       	ldi	r21, 0x47	; 71
    430c:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    4310:	18 16       	cp	r1, r24
    4312:	4c f5       	brge	.+82     	; 0x4366 <LCD_vWriteCommand+0x2dc>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    4314:	6b 85       	ldd	r22, Y+11	; 0x0b
    4316:	7c 85       	ldd	r23, Y+12	; 0x0c
    4318:	8d 85       	ldd	r24, Y+13	; 0x0d
    431a:	9e 85       	ldd	r25, Y+14	; 0x0e
    431c:	20 e0       	ldi	r18, 0x00	; 0
    431e:	30 e0       	ldi	r19, 0x00	; 0
    4320:	40 e2       	ldi	r20, 0x20	; 32
    4322:	51 e4       	ldi	r21, 0x41	; 65
    4324:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    4328:	dc 01       	movw	r26, r24
    432a:	cb 01       	movw	r24, r22
    432c:	bc 01       	movw	r22, r24
    432e:	cd 01       	movw	r24, r26
    4330:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    4334:	dc 01       	movw	r26, r24
    4336:	cb 01       	movw	r24, r22
    4338:	9e 83       	std	Y+6, r25	; 0x06
    433a:	8d 83       	std	Y+5, r24	; 0x05
    433c:	0f c0       	rjmp	.+30     	; 0x435c <LCD_vWriteCommand+0x2d2>
    433e:	88 ec       	ldi	r24, 0xC8	; 200
    4340:	90 e0       	ldi	r25, 0x00	; 0
    4342:	9c 83       	std	Y+4, r25	; 0x04
    4344:	8b 83       	std	Y+3, r24	; 0x03
    4346:	8b 81       	ldd	r24, Y+3	; 0x03
    4348:	9c 81       	ldd	r25, Y+4	; 0x04
    434a:	01 97       	sbiw	r24, 0x01	; 1
    434c:	f1 f7       	brne	.-4      	; 0x434a <LCD_vWriteCommand+0x2c0>
    434e:	9c 83       	std	Y+4, r25	; 0x04
    4350:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    4352:	8d 81       	ldd	r24, Y+5	; 0x05
    4354:	9e 81       	ldd	r25, Y+6	; 0x06
    4356:	01 97       	sbiw	r24, 0x01	; 1
    4358:	9e 83       	std	Y+6, r25	; 0x06
    435a:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    435c:	8d 81       	ldd	r24, Y+5	; 0x05
    435e:	9e 81       	ldd	r25, Y+6	; 0x06
    4360:	00 97       	sbiw	r24, 0x00	; 0
    4362:	69 f7       	brne	.-38     	; 0x433e <LCD_vWriteCommand+0x2b4>
    4364:	14 c0       	rjmp	.+40     	; 0x438e <LCD_vWriteCommand+0x304>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    4366:	6f 81       	ldd	r22, Y+7	; 0x07
    4368:	78 85       	ldd	r23, Y+8	; 0x08
    436a:	89 85       	ldd	r24, Y+9	; 0x09
    436c:	9a 85       	ldd	r25, Y+10	; 0x0a
    436e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    4372:	dc 01       	movw	r26, r24
    4374:	cb 01       	movw	r24, r22
    4376:	9e 83       	std	Y+6, r25	; 0x06
    4378:	8d 83       	std	Y+5, r24	; 0x05
    437a:	8d 81       	ldd	r24, Y+5	; 0x05
    437c:	9e 81       	ldd	r25, Y+6	; 0x06
    437e:	9a 83       	std	Y+2, r25	; 0x02
    4380:	89 83       	std	Y+1, r24	; 0x01
    4382:	89 81       	ldd	r24, Y+1	; 0x01
    4384:	9a 81       	ldd	r25, Y+2	; 0x02
    4386:	01 97       	sbiw	r24, 0x01	; 1
    4388:	f1 f7       	brne	.-4      	; 0x4386 <LCD_vWriteCommand+0x2fc>
    438a:	9a 83       	std	Y+2, r25	; 0x02
    438c:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(2);
	DIO_vWritePin(CONFIG_PORT,ENABLE,LOW);
    438e:	82 e0       	ldi	r24, 0x02	; 2
    4390:	67 e0       	ldi	r22, 0x07	; 7
    4392:	40 e0       	ldi	r20, 0x00	; 0
    4394:	0e 94 04 1c 	call	0x3808	; 0x3808 <DIO_vWritePin>

}
    4398:	6d 96       	adiw	r28, 0x1d	; 29
    439a:	0f b6       	in	r0, 0x3f	; 63
    439c:	f8 94       	cli
    439e:	de bf       	out	0x3e, r29	; 62
    43a0:	0f be       	out	0x3f, r0	; 63
    43a2:	cd bf       	out	0x3d, r28	; 61
    43a4:	cf 91       	pop	r28
    43a6:	df 91       	pop	r29
    43a8:	08 95       	ret

000043aa <LCD_vWriteChar>:
 * Description:
 * Input:
 * OUTPUT:
 * ***************************************************************/
void LCD_vWriteChar(uint8 Data)
{
    43aa:	df 93       	push	r29
    43ac:	cf 93       	push	r28
    43ae:	cd b7       	in	r28, 0x3d	; 61
    43b0:	de b7       	in	r29, 0x3e	; 62
    43b2:	6d 97       	sbiw	r28, 0x1d	; 29
    43b4:	0f b6       	in	r0, 0x3f	; 63
    43b6:	f8 94       	cli
    43b8:	de bf       	out	0x3e, r29	; 62
    43ba:	0f be       	out	0x3f, r0	; 63
    43bc:	cd bf       	out	0x3d, r28	; 61
    43be:	8d 8f       	std	Y+29, r24	; 0x1d
	/*1- R/S equal to one */
	DIO_vWritePin(CONFIG_PORT,RS_PIN,HIGH);
    43c0:	82 e0       	ldi	r24, 0x02	; 2
    43c2:	65 e0       	ldi	r22, 0x05	; 5
    43c4:	41 e0       	ldi	r20, 0x01	; 1
    43c6:	0e 94 04 1c 	call	0x3808	; 0x3808 <DIO_vWritePin>
	/*2- R/W equal to zero */
	DIO_vWritePin(CONFIG_PORT,RW_PIN,LOW);
    43ca:	82 e0       	ldi	r24, 0x02	; 2
    43cc:	66 e0       	ldi	r22, 0x06	; 6
    43ce:	40 e0       	ldi	r20, 0x00	; 0
    43d0:	0e 94 04 1c 	call	0x3808	; 0x3808 <DIO_vWritePin>
	/*3- send high nibble */
	DIO_vWritePin(DATA_PORT,DATA_PIN4,((Data & 0x10)>>DATA_PIN4));
    43d4:	8d 8d       	ldd	r24, Y+29	; 0x1d
    43d6:	88 2f       	mov	r24, r24
    43d8:	90 e0       	ldi	r25, 0x00	; 0
    43da:	80 71       	andi	r24, 0x10	; 16
    43dc:	90 70       	andi	r25, 0x00	; 0
    43de:	95 95       	asr	r25
    43e0:	87 95       	ror	r24
    43e2:	95 95       	asr	r25
    43e4:	87 95       	ror	r24
    43e6:	95 95       	asr	r25
    43e8:	87 95       	ror	r24
    43ea:	95 95       	asr	r25
    43ec:	87 95       	ror	r24
    43ee:	98 2f       	mov	r25, r24
    43f0:	80 e0       	ldi	r24, 0x00	; 0
    43f2:	64 e0       	ldi	r22, 0x04	; 4
    43f4:	49 2f       	mov	r20, r25
    43f6:	0e 94 04 1c 	call	0x3808	; 0x3808 <DIO_vWritePin>
	DIO_vWritePin(DATA_PORT,DATA_PIN5,((Data & 0x20)>>DATA_PIN5));
    43fa:	8d 8d       	ldd	r24, Y+29	; 0x1d
    43fc:	88 2f       	mov	r24, r24
    43fe:	90 e0       	ldi	r25, 0x00	; 0
    4400:	80 72       	andi	r24, 0x20	; 32
    4402:	90 70       	andi	r25, 0x00	; 0
    4404:	95 95       	asr	r25
    4406:	87 95       	ror	r24
    4408:	95 95       	asr	r25
    440a:	87 95       	ror	r24
    440c:	95 95       	asr	r25
    440e:	87 95       	ror	r24
    4410:	95 95       	asr	r25
    4412:	87 95       	ror	r24
    4414:	95 95       	asr	r25
    4416:	87 95       	ror	r24
    4418:	98 2f       	mov	r25, r24
    441a:	80 e0       	ldi	r24, 0x00	; 0
    441c:	65 e0       	ldi	r22, 0x05	; 5
    441e:	49 2f       	mov	r20, r25
    4420:	0e 94 04 1c 	call	0x3808	; 0x3808 <DIO_vWritePin>
	DIO_vWritePin(DATA_PORT,DATA_PIN6,((Data & 0x40)>>DATA_PIN6));
    4424:	8d 8d       	ldd	r24, Y+29	; 0x1d
    4426:	88 2f       	mov	r24, r24
    4428:	90 e0       	ldi	r25, 0x00	; 0
    442a:	80 74       	andi	r24, 0x40	; 64
    442c:	90 70       	andi	r25, 0x00	; 0
    442e:	08 2e       	mov	r0, r24
    4430:	89 2f       	mov	r24, r25
    4432:	00 0c       	add	r0, r0
    4434:	88 1f       	adc	r24, r24
    4436:	99 0b       	sbc	r25, r25
    4438:	00 0c       	add	r0, r0
    443a:	88 1f       	adc	r24, r24
    443c:	99 1f       	adc	r25, r25
    443e:	98 2f       	mov	r25, r24
    4440:	80 e0       	ldi	r24, 0x00	; 0
    4442:	66 e0       	ldi	r22, 0x06	; 6
    4444:	49 2f       	mov	r20, r25
    4446:	0e 94 04 1c 	call	0x3808	; 0x3808 <DIO_vWritePin>
	DIO_vWritePin(DATA_PORT,DATA_PIN7,((Data & 0x80)>>DATA_PIN7));
    444a:	8d 8d       	ldd	r24, Y+29	; 0x1d
    444c:	98 2f       	mov	r25, r24
    444e:	99 1f       	adc	r25, r25
    4450:	99 27       	eor	r25, r25
    4452:	99 1f       	adc	r25, r25
    4454:	80 e0       	ldi	r24, 0x00	; 0
    4456:	67 e0       	ldi	r22, 0x07	; 7
    4458:	49 2f       	mov	r20, r25
    445a:	0e 94 04 1c 	call	0x3808	; 0x3808 <DIO_vWritePin>
	DIO_vWritePin(CONFIG_PORT,ENABLE,HIGH);
    445e:	82 e0       	ldi	r24, 0x02	; 2
    4460:	67 e0       	ldi	r22, 0x07	; 7
    4462:	41 e0       	ldi	r20, 0x01	; 1
    4464:	0e 94 04 1c 	call	0x3808	; 0x3808 <DIO_vWritePin>
    4468:	80 e0       	ldi	r24, 0x00	; 0
    446a:	90 e0       	ldi	r25, 0x00	; 0
    446c:	a0 e0       	ldi	r26, 0x00	; 0
    446e:	b0 e4       	ldi	r27, 0x40	; 64
    4470:	89 8f       	std	Y+25, r24	; 0x19
    4472:	9a 8f       	std	Y+26, r25	; 0x1a
    4474:	ab 8f       	std	Y+27, r26	; 0x1b
    4476:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    4478:	69 8d       	ldd	r22, Y+25	; 0x19
    447a:	7a 8d       	ldd	r23, Y+26	; 0x1a
    447c:	8b 8d       	ldd	r24, Y+27	; 0x1b
    447e:	9c 8d       	ldd	r25, Y+28	; 0x1c
    4480:	20 e0       	ldi	r18, 0x00	; 0
    4482:	30 e0       	ldi	r19, 0x00	; 0
    4484:	4a ef       	ldi	r20, 0xFA	; 250
    4486:	54 e4       	ldi	r21, 0x44	; 68
    4488:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    448c:	dc 01       	movw	r26, r24
    448e:	cb 01       	movw	r24, r22
    4490:	8d 8b       	std	Y+21, r24	; 0x15
    4492:	9e 8b       	std	Y+22, r25	; 0x16
    4494:	af 8b       	std	Y+23, r26	; 0x17
    4496:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    4498:	6d 89       	ldd	r22, Y+21	; 0x15
    449a:	7e 89       	ldd	r23, Y+22	; 0x16
    449c:	8f 89       	ldd	r24, Y+23	; 0x17
    449e:	98 8d       	ldd	r25, Y+24	; 0x18
    44a0:	20 e0       	ldi	r18, 0x00	; 0
    44a2:	30 e0       	ldi	r19, 0x00	; 0
    44a4:	40 e8       	ldi	r20, 0x80	; 128
    44a6:	5f e3       	ldi	r21, 0x3F	; 63
    44a8:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    44ac:	88 23       	and	r24, r24
    44ae:	2c f4       	brge	.+10     	; 0x44ba <LCD_vWriteChar+0x110>
		__ticks = 1;
    44b0:	81 e0       	ldi	r24, 0x01	; 1
    44b2:	90 e0       	ldi	r25, 0x00	; 0
    44b4:	9c 8b       	std	Y+20, r25	; 0x14
    44b6:	8b 8b       	std	Y+19, r24	; 0x13
    44b8:	3f c0       	rjmp	.+126    	; 0x4538 <LCD_vWriteChar+0x18e>
	else if (__tmp > 65535)
    44ba:	6d 89       	ldd	r22, Y+21	; 0x15
    44bc:	7e 89       	ldd	r23, Y+22	; 0x16
    44be:	8f 89       	ldd	r24, Y+23	; 0x17
    44c0:	98 8d       	ldd	r25, Y+24	; 0x18
    44c2:	20 e0       	ldi	r18, 0x00	; 0
    44c4:	3f ef       	ldi	r19, 0xFF	; 255
    44c6:	4f e7       	ldi	r20, 0x7F	; 127
    44c8:	57 e4       	ldi	r21, 0x47	; 71
    44ca:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    44ce:	18 16       	cp	r1, r24
    44d0:	4c f5       	brge	.+82     	; 0x4524 <LCD_vWriteChar+0x17a>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    44d2:	69 8d       	ldd	r22, Y+25	; 0x19
    44d4:	7a 8d       	ldd	r23, Y+26	; 0x1a
    44d6:	8b 8d       	ldd	r24, Y+27	; 0x1b
    44d8:	9c 8d       	ldd	r25, Y+28	; 0x1c
    44da:	20 e0       	ldi	r18, 0x00	; 0
    44dc:	30 e0       	ldi	r19, 0x00	; 0
    44de:	40 e2       	ldi	r20, 0x20	; 32
    44e0:	51 e4       	ldi	r21, 0x41	; 65
    44e2:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    44e6:	dc 01       	movw	r26, r24
    44e8:	cb 01       	movw	r24, r22
    44ea:	bc 01       	movw	r22, r24
    44ec:	cd 01       	movw	r24, r26
    44ee:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    44f2:	dc 01       	movw	r26, r24
    44f4:	cb 01       	movw	r24, r22
    44f6:	9c 8b       	std	Y+20, r25	; 0x14
    44f8:	8b 8b       	std	Y+19, r24	; 0x13
    44fa:	0f c0       	rjmp	.+30     	; 0x451a <LCD_vWriteChar+0x170>
    44fc:	88 ec       	ldi	r24, 0xC8	; 200
    44fe:	90 e0       	ldi	r25, 0x00	; 0
    4500:	9a 8b       	std	Y+18, r25	; 0x12
    4502:	89 8b       	std	Y+17, r24	; 0x11
    4504:	89 89       	ldd	r24, Y+17	; 0x11
    4506:	9a 89       	ldd	r25, Y+18	; 0x12
    4508:	01 97       	sbiw	r24, 0x01	; 1
    450a:	f1 f7       	brne	.-4      	; 0x4508 <LCD_vWriteChar+0x15e>
    450c:	9a 8b       	std	Y+18, r25	; 0x12
    450e:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    4510:	8b 89       	ldd	r24, Y+19	; 0x13
    4512:	9c 89       	ldd	r25, Y+20	; 0x14
    4514:	01 97       	sbiw	r24, 0x01	; 1
    4516:	9c 8b       	std	Y+20, r25	; 0x14
    4518:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    451a:	8b 89       	ldd	r24, Y+19	; 0x13
    451c:	9c 89       	ldd	r25, Y+20	; 0x14
    451e:	00 97       	sbiw	r24, 0x00	; 0
    4520:	69 f7       	brne	.-38     	; 0x44fc <LCD_vWriteChar+0x152>
    4522:	14 c0       	rjmp	.+40     	; 0x454c <LCD_vWriteChar+0x1a2>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    4524:	6d 89       	ldd	r22, Y+21	; 0x15
    4526:	7e 89       	ldd	r23, Y+22	; 0x16
    4528:	8f 89       	ldd	r24, Y+23	; 0x17
    452a:	98 8d       	ldd	r25, Y+24	; 0x18
    452c:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    4530:	dc 01       	movw	r26, r24
    4532:	cb 01       	movw	r24, r22
    4534:	9c 8b       	std	Y+20, r25	; 0x14
    4536:	8b 8b       	std	Y+19, r24	; 0x13
    4538:	8b 89       	ldd	r24, Y+19	; 0x13
    453a:	9c 89       	ldd	r25, Y+20	; 0x14
    453c:	98 8b       	std	Y+16, r25	; 0x10
    453e:	8f 87       	std	Y+15, r24	; 0x0f
    4540:	8f 85       	ldd	r24, Y+15	; 0x0f
    4542:	98 89       	ldd	r25, Y+16	; 0x10
    4544:	01 97       	sbiw	r24, 0x01	; 1
    4546:	f1 f7       	brne	.-4      	; 0x4544 <LCD_vWriteChar+0x19a>
    4548:	98 8b       	std	Y+16, r25	; 0x10
    454a:	8f 87       	std	Y+15, r24	; 0x0f
	_delay_ms(2);
	DIO_vWritePin(CONFIG_PORT,ENABLE,LOW);
    454c:	82 e0       	ldi	r24, 0x02	; 2
    454e:	67 e0       	ldi	r22, 0x07	; 7
    4550:	40 e0       	ldi	r20, 0x00	; 0
    4552:	0e 94 04 1c 	call	0x3808	; 0x3808 <DIO_vWritePin>
	/* send low Nibble */
	DIO_vWritePin(DATA_PORT,DATA_PIN4,((Data & 0x01)));
    4556:	8d 8d       	ldd	r24, Y+29	; 0x1d
    4558:	98 2f       	mov	r25, r24
    455a:	91 70       	andi	r25, 0x01	; 1
    455c:	80 e0       	ldi	r24, 0x00	; 0
    455e:	64 e0       	ldi	r22, 0x04	; 4
    4560:	49 2f       	mov	r20, r25
    4562:	0e 94 04 1c 	call	0x3808	; 0x3808 <DIO_vWritePin>
	DIO_vWritePin(DATA_PORT,DATA_PIN5,((Data & 0x02)>>(DATA_PIN5-CONSTANT)));
    4566:	8d 8d       	ldd	r24, Y+29	; 0x1d
    4568:	88 2f       	mov	r24, r24
    456a:	90 e0       	ldi	r25, 0x00	; 0
    456c:	82 70       	andi	r24, 0x02	; 2
    456e:	90 70       	andi	r25, 0x00	; 0
    4570:	95 95       	asr	r25
    4572:	87 95       	ror	r24
    4574:	98 2f       	mov	r25, r24
    4576:	80 e0       	ldi	r24, 0x00	; 0
    4578:	65 e0       	ldi	r22, 0x05	; 5
    457a:	49 2f       	mov	r20, r25
    457c:	0e 94 04 1c 	call	0x3808	; 0x3808 <DIO_vWritePin>
	DIO_vWritePin(DATA_PORT,DATA_PIN6,((Data & 0x04)>>(DATA_PIN6-CONSTANT)));
    4580:	8d 8d       	ldd	r24, Y+29	; 0x1d
    4582:	88 2f       	mov	r24, r24
    4584:	90 e0       	ldi	r25, 0x00	; 0
    4586:	84 70       	andi	r24, 0x04	; 4
    4588:	90 70       	andi	r25, 0x00	; 0
    458a:	95 95       	asr	r25
    458c:	87 95       	ror	r24
    458e:	95 95       	asr	r25
    4590:	87 95       	ror	r24
    4592:	98 2f       	mov	r25, r24
    4594:	80 e0       	ldi	r24, 0x00	; 0
    4596:	66 e0       	ldi	r22, 0x06	; 6
    4598:	49 2f       	mov	r20, r25
    459a:	0e 94 04 1c 	call	0x3808	; 0x3808 <DIO_vWritePin>
	DIO_vWritePin(DATA_PORT,DATA_PIN7,((Data & 0x08)>>(DATA_PIN7-CONSTANT)));
    459e:	8d 8d       	ldd	r24, Y+29	; 0x1d
    45a0:	88 2f       	mov	r24, r24
    45a2:	90 e0       	ldi	r25, 0x00	; 0
    45a4:	88 70       	andi	r24, 0x08	; 8
    45a6:	90 70       	andi	r25, 0x00	; 0
    45a8:	95 95       	asr	r25
    45aa:	87 95       	ror	r24
    45ac:	95 95       	asr	r25
    45ae:	87 95       	ror	r24
    45b0:	95 95       	asr	r25
    45b2:	87 95       	ror	r24
    45b4:	98 2f       	mov	r25, r24
    45b6:	80 e0       	ldi	r24, 0x00	; 0
    45b8:	67 e0       	ldi	r22, 0x07	; 7
    45ba:	49 2f       	mov	r20, r25
    45bc:	0e 94 04 1c 	call	0x3808	; 0x3808 <DIO_vWritePin>
	DIO_vWritePin(CONFIG_PORT,ENABLE,HIGH);
    45c0:	82 e0       	ldi	r24, 0x02	; 2
    45c2:	67 e0       	ldi	r22, 0x07	; 7
    45c4:	41 e0       	ldi	r20, 0x01	; 1
    45c6:	0e 94 04 1c 	call	0x3808	; 0x3808 <DIO_vWritePin>
    45ca:	80 e0       	ldi	r24, 0x00	; 0
    45cc:	90 e0       	ldi	r25, 0x00	; 0
    45ce:	a0 e0       	ldi	r26, 0x00	; 0
    45d0:	b0 e4       	ldi	r27, 0x40	; 64
    45d2:	8b 87       	std	Y+11, r24	; 0x0b
    45d4:	9c 87       	std	Y+12, r25	; 0x0c
    45d6:	ad 87       	std	Y+13, r26	; 0x0d
    45d8:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    45da:	6b 85       	ldd	r22, Y+11	; 0x0b
    45dc:	7c 85       	ldd	r23, Y+12	; 0x0c
    45de:	8d 85       	ldd	r24, Y+13	; 0x0d
    45e0:	9e 85       	ldd	r25, Y+14	; 0x0e
    45e2:	20 e0       	ldi	r18, 0x00	; 0
    45e4:	30 e0       	ldi	r19, 0x00	; 0
    45e6:	4a ef       	ldi	r20, 0xFA	; 250
    45e8:	54 e4       	ldi	r21, 0x44	; 68
    45ea:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    45ee:	dc 01       	movw	r26, r24
    45f0:	cb 01       	movw	r24, r22
    45f2:	8f 83       	std	Y+7, r24	; 0x07
    45f4:	98 87       	std	Y+8, r25	; 0x08
    45f6:	a9 87       	std	Y+9, r26	; 0x09
    45f8:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    45fa:	6f 81       	ldd	r22, Y+7	; 0x07
    45fc:	78 85       	ldd	r23, Y+8	; 0x08
    45fe:	89 85       	ldd	r24, Y+9	; 0x09
    4600:	9a 85       	ldd	r25, Y+10	; 0x0a
    4602:	20 e0       	ldi	r18, 0x00	; 0
    4604:	30 e0       	ldi	r19, 0x00	; 0
    4606:	40 e8       	ldi	r20, 0x80	; 128
    4608:	5f e3       	ldi	r21, 0x3F	; 63
    460a:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    460e:	88 23       	and	r24, r24
    4610:	2c f4       	brge	.+10     	; 0x461c <LCD_vWriteChar+0x272>
		__ticks = 1;
    4612:	81 e0       	ldi	r24, 0x01	; 1
    4614:	90 e0       	ldi	r25, 0x00	; 0
    4616:	9e 83       	std	Y+6, r25	; 0x06
    4618:	8d 83       	std	Y+5, r24	; 0x05
    461a:	3f c0       	rjmp	.+126    	; 0x469a <LCD_vWriteChar+0x2f0>
	else if (__tmp > 65535)
    461c:	6f 81       	ldd	r22, Y+7	; 0x07
    461e:	78 85       	ldd	r23, Y+8	; 0x08
    4620:	89 85       	ldd	r24, Y+9	; 0x09
    4622:	9a 85       	ldd	r25, Y+10	; 0x0a
    4624:	20 e0       	ldi	r18, 0x00	; 0
    4626:	3f ef       	ldi	r19, 0xFF	; 255
    4628:	4f e7       	ldi	r20, 0x7F	; 127
    462a:	57 e4       	ldi	r21, 0x47	; 71
    462c:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    4630:	18 16       	cp	r1, r24
    4632:	4c f5       	brge	.+82     	; 0x4686 <LCD_vWriteChar+0x2dc>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    4634:	6b 85       	ldd	r22, Y+11	; 0x0b
    4636:	7c 85       	ldd	r23, Y+12	; 0x0c
    4638:	8d 85       	ldd	r24, Y+13	; 0x0d
    463a:	9e 85       	ldd	r25, Y+14	; 0x0e
    463c:	20 e0       	ldi	r18, 0x00	; 0
    463e:	30 e0       	ldi	r19, 0x00	; 0
    4640:	40 e2       	ldi	r20, 0x20	; 32
    4642:	51 e4       	ldi	r21, 0x41	; 65
    4644:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    4648:	dc 01       	movw	r26, r24
    464a:	cb 01       	movw	r24, r22
    464c:	bc 01       	movw	r22, r24
    464e:	cd 01       	movw	r24, r26
    4650:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    4654:	dc 01       	movw	r26, r24
    4656:	cb 01       	movw	r24, r22
    4658:	9e 83       	std	Y+6, r25	; 0x06
    465a:	8d 83       	std	Y+5, r24	; 0x05
    465c:	0f c0       	rjmp	.+30     	; 0x467c <LCD_vWriteChar+0x2d2>
    465e:	88 ec       	ldi	r24, 0xC8	; 200
    4660:	90 e0       	ldi	r25, 0x00	; 0
    4662:	9c 83       	std	Y+4, r25	; 0x04
    4664:	8b 83       	std	Y+3, r24	; 0x03
    4666:	8b 81       	ldd	r24, Y+3	; 0x03
    4668:	9c 81       	ldd	r25, Y+4	; 0x04
    466a:	01 97       	sbiw	r24, 0x01	; 1
    466c:	f1 f7       	brne	.-4      	; 0x466a <LCD_vWriteChar+0x2c0>
    466e:	9c 83       	std	Y+4, r25	; 0x04
    4670:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    4672:	8d 81       	ldd	r24, Y+5	; 0x05
    4674:	9e 81       	ldd	r25, Y+6	; 0x06
    4676:	01 97       	sbiw	r24, 0x01	; 1
    4678:	9e 83       	std	Y+6, r25	; 0x06
    467a:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    467c:	8d 81       	ldd	r24, Y+5	; 0x05
    467e:	9e 81       	ldd	r25, Y+6	; 0x06
    4680:	00 97       	sbiw	r24, 0x00	; 0
    4682:	69 f7       	brne	.-38     	; 0x465e <LCD_vWriteChar+0x2b4>
    4684:	14 c0       	rjmp	.+40     	; 0x46ae <LCD_vWriteChar+0x304>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    4686:	6f 81       	ldd	r22, Y+7	; 0x07
    4688:	78 85       	ldd	r23, Y+8	; 0x08
    468a:	89 85       	ldd	r24, Y+9	; 0x09
    468c:	9a 85       	ldd	r25, Y+10	; 0x0a
    468e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    4692:	dc 01       	movw	r26, r24
    4694:	cb 01       	movw	r24, r22
    4696:	9e 83       	std	Y+6, r25	; 0x06
    4698:	8d 83       	std	Y+5, r24	; 0x05
    469a:	8d 81       	ldd	r24, Y+5	; 0x05
    469c:	9e 81       	ldd	r25, Y+6	; 0x06
    469e:	9a 83       	std	Y+2, r25	; 0x02
    46a0:	89 83       	std	Y+1, r24	; 0x01
    46a2:	89 81       	ldd	r24, Y+1	; 0x01
    46a4:	9a 81       	ldd	r25, Y+2	; 0x02
    46a6:	01 97       	sbiw	r24, 0x01	; 1
    46a8:	f1 f7       	brne	.-4      	; 0x46a6 <LCD_vWriteChar+0x2fc>
    46aa:	9a 83       	std	Y+2, r25	; 0x02
    46ac:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(2);
	DIO_vWritePin(CONFIG_PORT,ENABLE,LOW);
    46ae:	82 e0       	ldi	r24, 0x02	; 2
    46b0:	67 e0       	ldi	r22, 0x07	; 7
    46b2:	40 e0       	ldi	r20, 0x00	; 0
    46b4:	0e 94 04 1c 	call	0x3808	; 0x3808 <DIO_vWritePin>

}
    46b8:	6d 96       	adiw	r28, 0x1d	; 29
    46ba:	0f b6       	in	r0, 0x3f	; 63
    46bc:	f8 94       	cli
    46be:	de bf       	out	0x3e, r29	; 62
    46c0:	0f be       	out	0x3f, r0	; 63
    46c2:	cd bf       	out	0x3d, r28	; 61
    46c4:	cf 91       	pop	r28
    46c6:	df 91       	pop	r29
    46c8:	08 95       	ret

000046ca <LCD_vInit>:
 * Description:
 * Input:
 * OUTPUT:
 * ********************************************************/
void LCD_vInit()
{
    46ca:	df 93       	push	r29
    46cc:	cf 93       	push	r28
    46ce:	cd b7       	in	r28, 0x3d	; 61
    46d0:	de b7       	in	r29, 0x3e	; 62
    46d2:	6c 97       	sbiw	r28, 0x1c	; 28
    46d4:	0f b6       	in	r0, 0x3f	; 63
    46d6:	f8 94       	cli
    46d8:	de bf       	out	0x3e, r29	; 62
    46da:	0f be       	out	0x3f, r0	; 63
    46dc:	cd bf       	out	0x3d, r28	; 61
	/* Init Pins direction for the lcd */
	DIO_vSetPinDirection(CONFIG_PORT,RS_PIN,OUTPUT);
    46de:	82 e0       	ldi	r24, 0x02	; 2
    46e0:	65 e0       	ldi	r22, 0x05	; 5
    46e2:	42 e0       	ldi	r20, 0x02	; 2
    46e4:	0e 94 ed 19 	call	0x33da	; 0x33da <DIO_vSetPinDirection>
	DIO_vSetPinDirection(CONFIG_PORT,RW_PIN,OUTPUT);
    46e8:	82 e0       	ldi	r24, 0x02	; 2
    46ea:	66 e0       	ldi	r22, 0x06	; 6
    46ec:	42 e0       	ldi	r20, 0x02	; 2
    46ee:	0e 94 ed 19 	call	0x33da	; 0x33da <DIO_vSetPinDirection>
	DIO_vSetPinDirection(CONFIG_PORT,ENABLE,OUTPUT);
    46f2:	82 e0       	ldi	r24, 0x02	; 2
    46f4:	67 e0       	ldi	r22, 0x07	; 7
    46f6:	42 e0       	ldi	r20, 0x02	; 2
    46f8:	0e 94 ed 19 	call	0x33da	; 0x33da <DIO_vSetPinDirection>
	DIO_vSetPinDirection(DATA_PORT,DATA_PIN4,OUTPUT);
    46fc:	80 e0       	ldi	r24, 0x00	; 0
    46fe:	64 e0       	ldi	r22, 0x04	; 4
    4700:	42 e0       	ldi	r20, 0x02	; 2
    4702:	0e 94 ed 19 	call	0x33da	; 0x33da <DIO_vSetPinDirection>
	DIO_vSetPinDirection(DATA_PORT,DATA_PIN5,OUTPUT);
    4706:	80 e0       	ldi	r24, 0x00	; 0
    4708:	65 e0       	ldi	r22, 0x05	; 5
    470a:	42 e0       	ldi	r20, 0x02	; 2
    470c:	0e 94 ed 19 	call	0x33da	; 0x33da <DIO_vSetPinDirection>
	DIO_vSetPinDirection(DATA_PORT,DATA_PIN6,OUTPUT);
    4710:	80 e0       	ldi	r24, 0x00	; 0
    4712:	66 e0       	ldi	r22, 0x06	; 6
    4714:	42 e0       	ldi	r20, 0x02	; 2
    4716:	0e 94 ed 19 	call	0x33da	; 0x33da <DIO_vSetPinDirection>
	DIO_vSetPinDirection(DATA_PORT,DATA_PIN7,OUTPUT);
    471a:	80 e0       	ldi	r24, 0x00	; 0
    471c:	67 e0       	ldi	r22, 0x07	; 7
    471e:	42 e0       	ldi	r20, 0x02	; 2
    4720:	0e 94 ed 19 	call	0x33da	; 0x33da <DIO_vSetPinDirection>
	DIO_vWritePin(CONFIG_PORT,ENABLE,LOW);
    4724:	82 e0       	ldi	r24, 0x02	; 2
    4726:	67 e0       	ldi	r22, 0x07	; 7
    4728:	40 e0       	ldi	r20, 0x00	; 0
    472a:	0e 94 04 1c 	call	0x3808	; 0x3808 <DIO_vWritePin>
    472e:	80 e0       	ldi	r24, 0x00	; 0
    4730:	90 e0       	ldi	r25, 0x00	; 0
    4732:	a8 e4       	ldi	r26, 0x48	; 72
    4734:	b2 e4       	ldi	r27, 0x42	; 66
    4736:	89 8f       	std	Y+25, r24	; 0x19
    4738:	9a 8f       	std	Y+26, r25	; 0x1a
    473a:	ab 8f       	std	Y+27, r26	; 0x1b
    473c:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    473e:	69 8d       	ldd	r22, Y+25	; 0x19
    4740:	7a 8d       	ldd	r23, Y+26	; 0x1a
    4742:	8b 8d       	ldd	r24, Y+27	; 0x1b
    4744:	9c 8d       	ldd	r25, Y+28	; 0x1c
    4746:	20 e0       	ldi	r18, 0x00	; 0
    4748:	30 e0       	ldi	r19, 0x00	; 0
    474a:	4a ef       	ldi	r20, 0xFA	; 250
    474c:	54 e4       	ldi	r21, 0x44	; 68
    474e:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    4752:	dc 01       	movw	r26, r24
    4754:	cb 01       	movw	r24, r22
    4756:	8d 8b       	std	Y+21, r24	; 0x15
    4758:	9e 8b       	std	Y+22, r25	; 0x16
    475a:	af 8b       	std	Y+23, r26	; 0x17
    475c:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    475e:	6d 89       	ldd	r22, Y+21	; 0x15
    4760:	7e 89       	ldd	r23, Y+22	; 0x16
    4762:	8f 89       	ldd	r24, Y+23	; 0x17
    4764:	98 8d       	ldd	r25, Y+24	; 0x18
    4766:	20 e0       	ldi	r18, 0x00	; 0
    4768:	30 e0       	ldi	r19, 0x00	; 0
    476a:	40 e8       	ldi	r20, 0x80	; 128
    476c:	5f e3       	ldi	r21, 0x3F	; 63
    476e:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    4772:	88 23       	and	r24, r24
    4774:	2c f4       	brge	.+10     	; 0x4780 <LCD_vInit+0xb6>
		__ticks = 1;
    4776:	81 e0       	ldi	r24, 0x01	; 1
    4778:	90 e0       	ldi	r25, 0x00	; 0
    477a:	9c 8b       	std	Y+20, r25	; 0x14
    477c:	8b 8b       	std	Y+19, r24	; 0x13
    477e:	3f c0       	rjmp	.+126    	; 0x47fe <LCD_vInit+0x134>
	else if (__tmp > 65535)
    4780:	6d 89       	ldd	r22, Y+21	; 0x15
    4782:	7e 89       	ldd	r23, Y+22	; 0x16
    4784:	8f 89       	ldd	r24, Y+23	; 0x17
    4786:	98 8d       	ldd	r25, Y+24	; 0x18
    4788:	20 e0       	ldi	r18, 0x00	; 0
    478a:	3f ef       	ldi	r19, 0xFF	; 255
    478c:	4f e7       	ldi	r20, 0x7F	; 127
    478e:	57 e4       	ldi	r21, 0x47	; 71
    4790:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    4794:	18 16       	cp	r1, r24
    4796:	4c f5       	brge	.+82     	; 0x47ea <LCD_vInit+0x120>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    4798:	69 8d       	ldd	r22, Y+25	; 0x19
    479a:	7a 8d       	ldd	r23, Y+26	; 0x1a
    479c:	8b 8d       	ldd	r24, Y+27	; 0x1b
    479e:	9c 8d       	ldd	r25, Y+28	; 0x1c
    47a0:	20 e0       	ldi	r18, 0x00	; 0
    47a2:	30 e0       	ldi	r19, 0x00	; 0
    47a4:	40 e2       	ldi	r20, 0x20	; 32
    47a6:	51 e4       	ldi	r21, 0x41	; 65
    47a8:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    47ac:	dc 01       	movw	r26, r24
    47ae:	cb 01       	movw	r24, r22
    47b0:	bc 01       	movw	r22, r24
    47b2:	cd 01       	movw	r24, r26
    47b4:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    47b8:	dc 01       	movw	r26, r24
    47ba:	cb 01       	movw	r24, r22
    47bc:	9c 8b       	std	Y+20, r25	; 0x14
    47be:	8b 8b       	std	Y+19, r24	; 0x13
    47c0:	0f c0       	rjmp	.+30     	; 0x47e0 <LCD_vInit+0x116>
    47c2:	88 ec       	ldi	r24, 0xC8	; 200
    47c4:	90 e0       	ldi	r25, 0x00	; 0
    47c6:	9a 8b       	std	Y+18, r25	; 0x12
    47c8:	89 8b       	std	Y+17, r24	; 0x11
    47ca:	89 89       	ldd	r24, Y+17	; 0x11
    47cc:	9a 89       	ldd	r25, Y+18	; 0x12
    47ce:	01 97       	sbiw	r24, 0x01	; 1
    47d0:	f1 f7       	brne	.-4      	; 0x47ce <LCD_vInit+0x104>
    47d2:	9a 8b       	std	Y+18, r25	; 0x12
    47d4:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    47d6:	8b 89       	ldd	r24, Y+19	; 0x13
    47d8:	9c 89       	ldd	r25, Y+20	; 0x14
    47da:	01 97       	sbiw	r24, 0x01	; 1
    47dc:	9c 8b       	std	Y+20, r25	; 0x14
    47de:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    47e0:	8b 89       	ldd	r24, Y+19	; 0x13
    47e2:	9c 89       	ldd	r25, Y+20	; 0x14
    47e4:	00 97       	sbiw	r24, 0x00	; 0
    47e6:	69 f7       	brne	.-38     	; 0x47c2 <LCD_vInit+0xf8>
    47e8:	14 c0       	rjmp	.+40     	; 0x4812 <LCD_vInit+0x148>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    47ea:	6d 89       	ldd	r22, Y+21	; 0x15
    47ec:	7e 89       	ldd	r23, Y+22	; 0x16
    47ee:	8f 89       	ldd	r24, Y+23	; 0x17
    47f0:	98 8d       	ldd	r25, Y+24	; 0x18
    47f2:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    47f6:	dc 01       	movw	r26, r24
    47f8:	cb 01       	movw	r24, r22
    47fa:	9c 8b       	std	Y+20, r25	; 0x14
    47fc:	8b 8b       	std	Y+19, r24	; 0x13
    47fe:	8b 89       	ldd	r24, Y+19	; 0x13
    4800:	9c 89       	ldd	r25, Y+20	; 0x14
    4802:	98 8b       	std	Y+16, r25	; 0x10
    4804:	8f 87       	std	Y+15, r24	; 0x0f
    4806:	8f 85       	ldd	r24, Y+15	; 0x0f
    4808:	98 89       	ldd	r25, Y+16	; 0x10
    480a:	01 97       	sbiw	r24, 0x01	; 1
    480c:	f1 f7       	brne	.-4      	; 0x480a <LCD_vInit+0x140>
    480e:	98 8b       	std	Y+16, r25	; 0x10
    4810:	8f 87       	std	Y+15, r24	; 0x0f
	_delay_ms(50);
	/* Init the LCD*/
	LCD_vWriteCommand(LCD_INIT_PHASE_ONE);
    4812:	83 e3       	ldi	r24, 0x33	; 51
    4814:	0e 94 45 20 	call	0x408a	; 0x408a <LCD_vWriteCommand>
	LCD_vWriteCommand(LCD_INIT_PHASE_TWO);
    4818:	82 e3       	ldi	r24, 0x32	; 50
    481a:	0e 94 45 20 	call	0x408a	; 0x408a <LCD_vWriteCommand>
	LCD_vWriteCommand(LCD_INIT_PHASE_THREE);
    481e:	88 e2       	ldi	r24, 0x28	; 40
    4820:	0e 94 45 20 	call	0x408a	; 0x408a <LCD_vWriteCommand>
	LCD_vWriteCommand(LCD_DISPLAY_OPTIONS);
    4824:	8e e0       	ldi	r24, 0x0E	; 14
    4826:	0e 94 45 20 	call	0x408a	; 0x408a <LCD_vWriteCommand>
	LCD_vWriteCommand(LCD_CLEAR);
    482a:	81 e0       	ldi	r24, 0x01	; 1
    482c:	0e 94 45 20 	call	0x408a	; 0x408a <LCD_vWriteCommand>
	LCD_vWriteCommand(LCD_INCREMENT_CURSOR);
    4830:	86 e0       	ldi	r24, 0x06	; 6
    4832:	0e 94 45 20 	call	0x408a	; 0x408a <LCD_vWriteCommand>
    4836:	80 e0       	ldi	r24, 0x00	; 0
    4838:	90 e0       	ldi	r25, 0x00	; 0
    483a:	a0 e8       	ldi	r26, 0x80	; 128
    483c:	bf e3       	ldi	r27, 0x3F	; 63
    483e:	8b 87       	std	Y+11, r24	; 0x0b
    4840:	9c 87       	std	Y+12, r25	; 0x0c
    4842:	ad 87       	std	Y+13, r26	; 0x0d
    4844:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    4846:	6b 85       	ldd	r22, Y+11	; 0x0b
    4848:	7c 85       	ldd	r23, Y+12	; 0x0c
    484a:	8d 85       	ldd	r24, Y+13	; 0x0d
    484c:	9e 85       	ldd	r25, Y+14	; 0x0e
    484e:	20 e0       	ldi	r18, 0x00	; 0
    4850:	30 e0       	ldi	r19, 0x00	; 0
    4852:	4a ef       	ldi	r20, 0xFA	; 250
    4854:	54 e4       	ldi	r21, 0x44	; 68
    4856:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    485a:	dc 01       	movw	r26, r24
    485c:	cb 01       	movw	r24, r22
    485e:	8f 83       	std	Y+7, r24	; 0x07
    4860:	98 87       	std	Y+8, r25	; 0x08
    4862:	a9 87       	std	Y+9, r26	; 0x09
    4864:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    4866:	6f 81       	ldd	r22, Y+7	; 0x07
    4868:	78 85       	ldd	r23, Y+8	; 0x08
    486a:	89 85       	ldd	r24, Y+9	; 0x09
    486c:	9a 85       	ldd	r25, Y+10	; 0x0a
    486e:	20 e0       	ldi	r18, 0x00	; 0
    4870:	30 e0       	ldi	r19, 0x00	; 0
    4872:	40 e8       	ldi	r20, 0x80	; 128
    4874:	5f e3       	ldi	r21, 0x3F	; 63
    4876:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    487a:	88 23       	and	r24, r24
    487c:	2c f4       	brge	.+10     	; 0x4888 <LCD_vInit+0x1be>
		__ticks = 1;
    487e:	81 e0       	ldi	r24, 0x01	; 1
    4880:	90 e0       	ldi	r25, 0x00	; 0
    4882:	9e 83       	std	Y+6, r25	; 0x06
    4884:	8d 83       	std	Y+5, r24	; 0x05
    4886:	3f c0       	rjmp	.+126    	; 0x4906 <LCD_vInit+0x23c>
	else if (__tmp > 65535)
    4888:	6f 81       	ldd	r22, Y+7	; 0x07
    488a:	78 85       	ldd	r23, Y+8	; 0x08
    488c:	89 85       	ldd	r24, Y+9	; 0x09
    488e:	9a 85       	ldd	r25, Y+10	; 0x0a
    4890:	20 e0       	ldi	r18, 0x00	; 0
    4892:	3f ef       	ldi	r19, 0xFF	; 255
    4894:	4f e7       	ldi	r20, 0x7F	; 127
    4896:	57 e4       	ldi	r21, 0x47	; 71
    4898:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    489c:	18 16       	cp	r1, r24
    489e:	4c f5       	brge	.+82     	; 0x48f2 <LCD_vInit+0x228>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    48a0:	6b 85       	ldd	r22, Y+11	; 0x0b
    48a2:	7c 85       	ldd	r23, Y+12	; 0x0c
    48a4:	8d 85       	ldd	r24, Y+13	; 0x0d
    48a6:	9e 85       	ldd	r25, Y+14	; 0x0e
    48a8:	20 e0       	ldi	r18, 0x00	; 0
    48aa:	30 e0       	ldi	r19, 0x00	; 0
    48ac:	40 e2       	ldi	r20, 0x20	; 32
    48ae:	51 e4       	ldi	r21, 0x41	; 65
    48b0:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    48b4:	dc 01       	movw	r26, r24
    48b6:	cb 01       	movw	r24, r22
    48b8:	bc 01       	movw	r22, r24
    48ba:	cd 01       	movw	r24, r26
    48bc:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    48c0:	dc 01       	movw	r26, r24
    48c2:	cb 01       	movw	r24, r22
    48c4:	9e 83       	std	Y+6, r25	; 0x06
    48c6:	8d 83       	std	Y+5, r24	; 0x05
    48c8:	0f c0       	rjmp	.+30     	; 0x48e8 <LCD_vInit+0x21e>
    48ca:	88 ec       	ldi	r24, 0xC8	; 200
    48cc:	90 e0       	ldi	r25, 0x00	; 0
    48ce:	9c 83       	std	Y+4, r25	; 0x04
    48d0:	8b 83       	std	Y+3, r24	; 0x03
    48d2:	8b 81       	ldd	r24, Y+3	; 0x03
    48d4:	9c 81       	ldd	r25, Y+4	; 0x04
    48d6:	01 97       	sbiw	r24, 0x01	; 1
    48d8:	f1 f7       	brne	.-4      	; 0x48d6 <LCD_vInit+0x20c>
    48da:	9c 83       	std	Y+4, r25	; 0x04
    48dc:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    48de:	8d 81       	ldd	r24, Y+5	; 0x05
    48e0:	9e 81       	ldd	r25, Y+6	; 0x06
    48e2:	01 97       	sbiw	r24, 0x01	; 1
    48e4:	9e 83       	std	Y+6, r25	; 0x06
    48e6:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    48e8:	8d 81       	ldd	r24, Y+5	; 0x05
    48ea:	9e 81       	ldd	r25, Y+6	; 0x06
    48ec:	00 97       	sbiw	r24, 0x00	; 0
    48ee:	69 f7       	brne	.-38     	; 0x48ca <LCD_vInit+0x200>
    48f0:	14 c0       	rjmp	.+40     	; 0x491a <LCD_vInit+0x250>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    48f2:	6f 81       	ldd	r22, Y+7	; 0x07
    48f4:	78 85       	ldd	r23, Y+8	; 0x08
    48f6:	89 85       	ldd	r24, Y+9	; 0x09
    48f8:	9a 85       	ldd	r25, Y+10	; 0x0a
    48fa:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    48fe:	dc 01       	movw	r26, r24
    4900:	cb 01       	movw	r24, r22
    4902:	9e 83       	std	Y+6, r25	; 0x06
    4904:	8d 83       	std	Y+5, r24	; 0x05
    4906:	8d 81       	ldd	r24, Y+5	; 0x05
    4908:	9e 81       	ldd	r25, Y+6	; 0x06
    490a:	9a 83       	std	Y+2, r25	; 0x02
    490c:	89 83       	std	Y+1, r24	; 0x01
    490e:	89 81       	ldd	r24, Y+1	; 0x01
    4910:	9a 81       	ldd	r25, Y+2	; 0x02
    4912:	01 97       	sbiw	r24, 0x01	; 1
    4914:	f1 f7       	brne	.-4      	; 0x4912 <LCD_vInit+0x248>
    4916:	9a 83       	std	Y+2, r25	; 0x02
    4918:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(1);
}
    491a:	6c 96       	adiw	r28, 0x1c	; 28
    491c:	0f b6       	in	r0, 0x3f	; 63
    491e:	f8 94       	cli
    4920:	de bf       	out	0x3e, r29	; 62
    4922:	0f be       	out	0x3f, r0	; 63
    4924:	cd bf       	out	0x3d, r28	; 61
    4926:	cf 91       	pop	r28
    4928:	df 91       	pop	r29
    492a:	08 95       	ret

0000492c <LCD_vGotoxy>:
 * Description:
 * Input:
 * OUTPUT:
 * ********************************************************/
void LCD_vGotoxy(uint8 Row,uint8 Col)
{
    492c:	df 93       	push	r29
    492e:	cf 93       	push	r28
    4930:	00 d0       	rcall	.+0      	; 0x4932 <LCD_vGotoxy+0x6>
    4932:	00 d0       	rcall	.+0      	; 0x4934 <LCD_vGotoxy+0x8>
    4934:	0f 92       	push	r0
    4936:	cd b7       	in	r28, 0x3d	; 61
    4938:	de b7       	in	r29, 0x3e	; 62
    493a:	8a 83       	std	Y+2, r24	; 0x02
    493c:	6b 83       	std	Y+3, r22	; 0x03
	uint8 Local_Address=0;
    493e:	19 82       	std	Y+1, r1	; 0x01
	switch(Row)
    4940:	8a 81       	ldd	r24, Y+2	; 0x02
    4942:	28 2f       	mov	r18, r24
    4944:	30 e0       	ldi	r19, 0x00	; 0
    4946:	3d 83       	std	Y+5, r19	; 0x05
    4948:	2c 83       	std	Y+4, r18	; 0x04
    494a:	8c 81       	ldd	r24, Y+4	; 0x04
    494c:	9d 81       	ldd	r25, Y+5	; 0x05
    494e:	81 30       	cpi	r24, 0x01	; 1
    4950:	91 05       	cpc	r25, r1
    4952:	31 f0       	breq	.+12     	; 0x4960 <LCD_vGotoxy+0x34>
    4954:	2c 81       	ldd	r18, Y+4	; 0x04
    4956:	3d 81       	ldd	r19, Y+5	; 0x05
    4958:	22 30       	cpi	r18, 0x02	; 2
    495a:	31 05       	cpc	r19, r1
    495c:	29 f0       	breq	.+10     	; 0x4968 <LCD_vGotoxy+0x3c>
    495e:	07 c0       	rjmp	.+14     	; 0x496e <LCD_vGotoxy+0x42>
	{
	case ROW_ONE:
		Local_Address = 0x80 + Col;
    4960:	8b 81       	ldd	r24, Y+3	; 0x03
    4962:	80 58       	subi	r24, 0x80	; 128
    4964:	89 83       	std	Y+1, r24	; 0x01
    4966:	03 c0       	rjmp	.+6      	; 0x496e <LCD_vGotoxy+0x42>
		break;
	case ROW_TWO:
		Local_Address= 0xC0 + Col;
    4968:	8b 81       	ldd	r24, Y+3	; 0x03
    496a:	80 54       	subi	r24, 0x40	; 64
    496c:	89 83       	std	Y+1, r24	; 0x01
		break;

	}
	/*send Command to go to that address*/
	LCD_vWriteCommand(Local_Address);
    496e:	89 81       	ldd	r24, Y+1	; 0x01
    4970:	0e 94 45 20 	call	0x408a	; 0x408a <LCD_vWriteCommand>

}
    4974:	0f 90       	pop	r0
    4976:	0f 90       	pop	r0
    4978:	0f 90       	pop	r0
    497a:	0f 90       	pop	r0
    497c:	0f 90       	pop	r0
    497e:	cf 91       	pop	r28
    4980:	df 91       	pop	r29
    4982:	08 95       	ret

00004984 <LCD_vClear>:
 * Description:
 * Input:
 * OUTPUT:
 * ********************************************************/
void LCD_vClear()
{
    4984:	df 93       	push	r29
    4986:	cf 93       	push	r28
    4988:	cd b7       	in	r28, 0x3d	; 61
    498a:	de b7       	in	r29, 0x3e	; 62
	LCD_vWriteCommand(LCD_CLEAR);
    498c:	81 e0       	ldi	r24, 0x01	; 1
    498e:	0e 94 45 20 	call	0x408a	; 0x408a <LCD_vWriteCommand>
}
    4992:	cf 91       	pop	r28
    4994:	df 91       	pop	r29
    4996:	08 95       	ret

00004998 <LCD_vSendString>:
 * Description:
 * Input:
 * OUTPUT:
 * ********************************************************/
void LCD_vSendString(uint8 String[])
{
    4998:	df 93       	push	r29
    499a:	cf 93       	push	r28
    499c:	00 d0       	rcall	.+0      	; 0x499e <LCD_vSendString+0x6>
    499e:	0f 92       	push	r0
    49a0:	cd b7       	in	r28, 0x3d	; 61
    49a2:	de b7       	in	r29, 0x3e	; 62
    49a4:	9b 83       	std	Y+3, r25	; 0x03
    49a6:	8a 83       	std	Y+2, r24	; 0x02
	    uint8 n=0;
    49a8:	19 82       	std	Y+1, r1	; 0x01
    49aa:	0e c0       	rjmp	.+28     	; 0x49c8 <LCD_vSendString+0x30>
		while(String[n]!='\0')
		{
			LCD_vWriteChar(String[n]);
    49ac:	89 81       	ldd	r24, Y+1	; 0x01
    49ae:	28 2f       	mov	r18, r24
    49b0:	30 e0       	ldi	r19, 0x00	; 0
    49b2:	8a 81       	ldd	r24, Y+2	; 0x02
    49b4:	9b 81       	ldd	r25, Y+3	; 0x03
    49b6:	fc 01       	movw	r30, r24
    49b8:	e2 0f       	add	r30, r18
    49ba:	f3 1f       	adc	r31, r19
    49bc:	80 81       	ld	r24, Z
    49be:	0e 94 d5 21 	call	0x43aa	; 0x43aa <LCD_vWriteChar>
			n++;
    49c2:	89 81       	ldd	r24, Y+1	; 0x01
    49c4:	8f 5f       	subi	r24, 0xFF	; 255
    49c6:	89 83       	std	Y+1, r24	; 0x01
 * OUTPUT:
 * ********************************************************/
void LCD_vSendString(uint8 String[])
{
	    uint8 n=0;
		while(String[n]!='\0')
    49c8:	89 81       	ldd	r24, Y+1	; 0x01
    49ca:	28 2f       	mov	r18, r24
    49cc:	30 e0       	ldi	r19, 0x00	; 0
    49ce:	8a 81       	ldd	r24, Y+2	; 0x02
    49d0:	9b 81       	ldd	r25, Y+3	; 0x03
    49d2:	fc 01       	movw	r30, r24
    49d4:	e2 0f       	add	r30, r18
    49d6:	f3 1f       	adc	r31, r19
    49d8:	80 81       	ld	r24, Z
    49da:	88 23       	and	r24, r24
    49dc:	39 f7       	brne	.-50     	; 0x49ac <LCD_vSendString+0x14>
		{
			LCD_vWriteChar(String[n]);
			n++;
		}
}
    49de:	0f 90       	pop	r0
    49e0:	0f 90       	pop	r0
    49e2:	0f 90       	pop	r0
    49e4:	cf 91       	pop	r28
    49e6:	df 91       	pop	r29
    49e8:	08 95       	ret

000049ea <Log_voidPrintNumber>:



void Log_voidPrintNumber(u16 Copy_u16Val)
{
    49ea:	df 93       	push	r29
    49ec:	cf 93       	push	r28
    49ee:	00 d0       	rcall	.+0      	; 0x49f0 <Log_voidPrintNumber+0x6>
    49f0:	0f 92       	push	r0
    49f2:	cd b7       	in	r28, 0x3d	; 61
    49f4:	de b7       	in	r29, 0x3e	; 62
    49f6:	9b 83       	std	Y+3, r25	; 0x03
    49f8:	8a 83       	std	Y+2, r24	; 0x02
	u8 Local_u8Factor;

	if (Copy_u16Val >= (u16)10000)
    49fa:	8a 81       	ldd	r24, Y+2	; 0x02
    49fc:	9b 81       	ldd	r25, Y+3	; 0x03
    49fe:	27 e2       	ldi	r18, 0x27	; 39
    4a00:	80 31       	cpi	r24, 0x10	; 16
    4a02:	92 07       	cpc	r25, r18
    4a04:	08 f4       	brcc	.+2      	; 0x4a08 <Log_voidPrintNumber+0x1e>
    4a06:	87 c0       	rjmp	.+270    	; 0x4b16 <Log_voidPrintNumber+0x12c>
	{
		Local_u8Factor = (u8)(Copy_u16Val / (u16) 10000);
    4a08:	8a 81       	ldd	r24, Y+2	; 0x02
    4a0a:	9b 81       	ldd	r25, Y+3	; 0x03
    4a0c:	20 e1       	ldi	r18, 0x10	; 16
    4a0e:	37 e2       	ldi	r19, 0x27	; 39
    4a10:	b9 01       	movw	r22, r18
    4a12:	0e 94 dc 2b 	call	0x57b8	; 0x57b8 <__udivmodhi4>
    4a16:	cb 01       	movw	r24, r22
    4a18:	89 83       	std	Y+1, r24	; 0x01
		LCD_vWriteChar(Local_u8Factor+48);
    4a1a:	89 81       	ldd	r24, Y+1	; 0x01
    4a1c:	80 5d       	subi	r24, 0xD0	; 208
    4a1e:	0e 94 d5 21 	call	0x43aa	; 0x43aa <LCD_vWriteChar>
		Copy_u16Val = Copy_u16Val - (u16)(Local_u8Factor * (u16)10000);
    4a22:	89 81       	ldd	r24, Y+1	; 0x01
    4a24:	28 2f       	mov	r18, r24
    4a26:	30 e0       	ldi	r19, 0x00	; 0
    4a28:	80 e1       	ldi	r24, 0x10	; 16
    4a2a:	97 e2       	ldi	r25, 0x27	; 39
    4a2c:	a9 01       	movw	r20, r18
    4a2e:	48 9f       	mul	r20, r24
    4a30:	90 01       	movw	r18, r0
    4a32:	49 9f       	mul	r20, r25
    4a34:	30 0d       	add	r19, r0
    4a36:	58 9f       	mul	r21, r24
    4a38:	30 0d       	add	r19, r0
    4a3a:	11 24       	eor	r1, r1
    4a3c:	8a 81       	ldd	r24, Y+2	; 0x02
    4a3e:	9b 81       	ldd	r25, Y+3	; 0x03
    4a40:	82 1b       	sub	r24, r18
    4a42:	93 0b       	sbc	r25, r19
    4a44:	9b 83       	std	Y+3, r25	; 0x03
    4a46:	8a 83       	std	Y+2, r24	; 0x02

		Local_u8Factor = (u8)(Copy_u16Val / (u16) 1000);
    4a48:	8a 81       	ldd	r24, Y+2	; 0x02
    4a4a:	9b 81       	ldd	r25, Y+3	; 0x03
    4a4c:	28 ee       	ldi	r18, 0xE8	; 232
    4a4e:	33 e0       	ldi	r19, 0x03	; 3
    4a50:	b9 01       	movw	r22, r18
    4a52:	0e 94 dc 2b 	call	0x57b8	; 0x57b8 <__udivmodhi4>
    4a56:	cb 01       	movw	r24, r22
    4a58:	89 83       	std	Y+1, r24	; 0x01
		LCD_vWriteChar(Local_u8Factor+48);
    4a5a:	89 81       	ldd	r24, Y+1	; 0x01
    4a5c:	80 5d       	subi	r24, 0xD0	; 208
    4a5e:	0e 94 d5 21 	call	0x43aa	; 0x43aa <LCD_vWriteChar>
		Copy_u16Val = Copy_u16Val - (u16)(Local_u8Factor * (u16)1000);
    4a62:	89 81       	ldd	r24, Y+1	; 0x01
    4a64:	28 2f       	mov	r18, r24
    4a66:	30 e0       	ldi	r19, 0x00	; 0
    4a68:	88 ee       	ldi	r24, 0xE8	; 232
    4a6a:	93 e0       	ldi	r25, 0x03	; 3
    4a6c:	a9 01       	movw	r20, r18
    4a6e:	48 9f       	mul	r20, r24
    4a70:	90 01       	movw	r18, r0
    4a72:	49 9f       	mul	r20, r25
    4a74:	30 0d       	add	r19, r0
    4a76:	58 9f       	mul	r21, r24
    4a78:	30 0d       	add	r19, r0
    4a7a:	11 24       	eor	r1, r1
    4a7c:	8a 81       	ldd	r24, Y+2	; 0x02
    4a7e:	9b 81       	ldd	r25, Y+3	; 0x03
    4a80:	82 1b       	sub	r24, r18
    4a82:	93 0b       	sbc	r25, r19
    4a84:	9b 83       	std	Y+3, r25	; 0x03
    4a86:	8a 83       	std	Y+2, r24	; 0x02

		Local_u8Factor = (u8)(Copy_u16Val / (u16) 100);
    4a88:	8a 81       	ldd	r24, Y+2	; 0x02
    4a8a:	9b 81       	ldd	r25, Y+3	; 0x03
    4a8c:	24 e6       	ldi	r18, 0x64	; 100
    4a8e:	30 e0       	ldi	r19, 0x00	; 0
    4a90:	b9 01       	movw	r22, r18
    4a92:	0e 94 dc 2b 	call	0x57b8	; 0x57b8 <__udivmodhi4>
    4a96:	cb 01       	movw	r24, r22
    4a98:	89 83       	std	Y+1, r24	; 0x01
		LCD_vWriteChar(Local_u8Factor+48);
    4a9a:	89 81       	ldd	r24, Y+1	; 0x01
    4a9c:	80 5d       	subi	r24, 0xD0	; 208
    4a9e:	0e 94 d5 21 	call	0x43aa	; 0x43aa <LCD_vWriteChar>
		Copy_u16Val = Copy_u16Val - (u16)(Local_u8Factor * (u8)100);
    4aa2:	89 81       	ldd	r24, Y+1	; 0x01
    4aa4:	28 2f       	mov	r18, r24
    4aa6:	30 e0       	ldi	r19, 0x00	; 0
    4aa8:	8c e9       	ldi	r24, 0x9C	; 156
    4aaa:	9f ef       	ldi	r25, 0xFF	; 255
    4aac:	ac 01       	movw	r20, r24
    4aae:	24 9f       	mul	r18, r20
    4ab0:	c0 01       	movw	r24, r0
    4ab2:	25 9f       	mul	r18, r21
    4ab4:	90 0d       	add	r25, r0
    4ab6:	34 9f       	mul	r19, r20
    4ab8:	90 0d       	add	r25, r0
    4aba:	11 24       	eor	r1, r1
    4abc:	9c 01       	movw	r18, r24
    4abe:	8a 81       	ldd	r24, Y+2	; 0x02
    4ac0:	9b 81       	ldd	r25, Y+3	; 0x03
    4ac2:	82 0f       	add	r24, r18
    4ac4:	93 1f       	adc	r25, r19
    4ac6:	9b 83       	std	Y+3, r25	; 0x03
    4ac8:	8a 83       	std	Y+2, r24	; 0x02

		Local_u8Factor = (u8)(Copy_u16Val / (u16) 10);
    4aca:	8a 81       	ldd	r24, Y+2	; 0x02
    4acc:	9b 81       	ldd	r25, Y+3	; 0x03
    4ace:	2a e0       	ldi	r18, 0x0A	; 10
    4ad0:	30 e0       	ldi	r19, 0x00	; 0
    4ad2:	b9 01       	movw	r22, r18
    4ad4:	0e 94 dc 2b 	call	0x57b8	; 0x57b8 <__udivmodhi4>
    4ad8:	cb 01       	movw	r24, r22
    4ada:	89 83       	std	Y+1, r24	; 0x01
		LCD_vWriteChar(Local_u8Factor+48);
    4adc:	89 81       	ldd	r24, Y+1	; 0x01
    4ade:	80 5d       	subi	r24, 0xD0	; 208
    4ae0:	0e 94 d5 21 	call	0x43aa	; 0x43aa <LCD_vWriteChar>
		Local_u8Factor = Copy_u16Val - (u16)(Local_u8Factor * (u8)10);
    4ae4:	89 81       	ldd	r24, Y+1	; 0x01
    4ae6:	88 2f       	mov	r24, r24
    4ae8:	90 e0       	ldi	r25, 0x00	; 0
    4aea:	9c 01       	movw	r18, r24
    4aec:	22 0f       	add	r18, r18
    4aee:	33 1f       	adc	r19, r19
    4af0:	c9 01       	movw	r24, r18
    4af2:	88 0f       	add	r24, r24
    4af4:	99 1f       	adc	r25, r25
    4af6:	88 0f       	add	r24, r24
    4af8:	99 1f       	adc	r25, r25
    4afa:	82 0f       	add	r24, r18
    4afc:	93 1f       	adc	r25, r19
    4afe:	90 95       	com	r25
    4b00:	81 95       	neg	r24
    4b02:	9f 4f       	sbci	r25, 0xFF	; 255
    4b04:	98 2f       	mov	r25, r24
    4b06:	8a 81       	ldd	r24, Y+2	; 0x02
    4b08:	89 0f       	add	r24, r25
    4b0a:	89 83       	std	Y+1, r24	; 0x01
		LCD_vWriteChar(Local_u8Factor+48);
    4b0c:	89 81       	ldd	r24, Y+1	; 0x01
    4b0e:	80 5d       	subi	r24, 0xD0	; 208
    4b10:	0e 94 d5 21 	call	0x43aa	; 0x43aa <LCD_vWriteChar>
    4b14:	e7 c0       	rjmp	.+462    	; 0x4ce4 <Log_voidPrintNumber+0x2fa>

	}

	else if (Copy_u16Val >= (u16) 1000 )
    4b16:	8a 81       	ldd	r24, Y+2	; 0x02
    4b18:	9b 81       	ldd	r25, Y+3	; 0x03
    4b1a:	53 e0       	ldi	r21, 0x03	; 3
    4b1c:	88 3e       	cpi	r24, 0xE8	; 232
    4b1e:	95 07       	cpc	r25, r21
    4b20:	08 f4       	brcc	.+2      	; 0x4b24 <Log_voidPrintNumber+0x13a>
    4b22:	67 c0       	rjmp	.+206    	; 0x4bf2 <Log_voidPrintNumber+0x208>
	{
		Local_u8Factor = (u8)(Copy_u16Val / (u16) 1000);
    4b24:	8a 81       	ldd	r24, Y+2	; 0x02
    4b26:	9b 81       	ldd	r25, Y+3	; 0x03
    4b28:	28 ee       	ldi	r18, 0xE8	; 232
    4b2a:	33 e0       	ldi	r19, 0x03	; 3
    4b2c:	b9 01       	movw	r22, r18
    4b2e:	0e 94 dc 2b 	call	0x57b8	; 0x57b8 <__udivmodhi4>
    4b32:	cb 01       	movw	r24, r22
    4b34:	89 83       	std	Y+1, r24	; 0x01
		LCD_vWriteChar(Local_u8Factor+48);
    4b36:	89 81       	ldd	r24, Y+1	; 0x01
    4b38:	80 5d       	subi	r24, 0xD0	; 208
    4b3a:	0e 94 d5 21 	call	0x43aa	; 0x43aa <LCD_vWriteChar>
		Copy_u16Val = Copy_u16Val - (u16)(Local_u8Factor * (u16)1000);
    4b3e:	89 81       	ldd	r24, Y+1	; 0x01
    4b40:	28 2f       	mov	r18, r24
    4b42:	30 e0       	ldi	r19, 0x00	; 0
    4b44:	88 ee       	ldi	r24, 0xE8	; 232
    4b46:	93 e0       	ldi	r25, 0x03	; 3
    4b48:	a9 01       	movw	r20, r18
    4b4a:	48 9f       	mul	r20, r24
    4b4c:	90 01       	movw	r18, r0
    4b4e:	49 9f       	mul	r20, r25
    4b50:	30 0d       	add	r19, r0
    4b52:	58 9f       	mul	r21, r24
    4b54:	30 0d       	add	r19, r0
    4b56:	11 24       	eor	r1, r1
    4b58:	8a 81       	ldd	r24, Y+2	; 0x02
    4b5a:	9b 81       	ldd	r25, Y+3	; 0x03
    4b5c:	82 1b       	sub	r24, r18
    4b5e:	93 0b       	sbc	r25, r19
    4b60:	9b 83       	std	Y+3, r25	; 0x03
    4b62:	8a 83       	std	Y+2, r24	; 0x02

		Local_u8Factor = (u8)(Copy_u16Val / (u16) 100);
    4b64:	8a 81       	ldd	r24, Y+2	; 0x02
    4b66:	9b 81       	ldd	r25, Y+3	; 0x03
    4b68:	24 e6       	ldi	r18, 0x64	; 100
    4b6a:	30 e0       	ldi	r19, 0x00	; 0
    4b6c:	b9 01       	movw	r22, r18
    4b6e:	0e 94 dc 2b 	call	0x57b8	; 0x57b8 <__udivmodhi4>
    4b72:	cb 01       	movw	r24, r22
    4b74:	89 83       	std	Y+1, r24	; 0x01
		LCD_vWriteChar(Local_u8Factor+48);
    4b76:	89 81       	ldd	r24, Y+1	; 0x01
    4b78:	80 5d       	subi	r24, 0xD0	; 208
    4b7a:	0e 94 d5 21 	call	0x43aa	; 0x43aa <LCD_vWriteChar>
		Copy_u16Val = Copy_u16Val - (u16)(Local_u8Factor * (u8)100);
    4b7e:	89 81       	ldd	r24, Y+1	; 0x01
    4b80:	28 2f       	mov	r18, r24
    4b82:	30 e0       	ldi	r19, 0x00	; 0
    4b84:	8c e9       	ldi	r24, 0x9C	; 156
    4b86:	9f ef       	ldi	r25, 0xFF	; 255
    4b88:	ac 01       	movw	r20, r24
    4b8a:	24 9f       	mul	r18, r20
    4b8c:	c0 01       	movw	r24, r0
    4b8e:	25 9f       	mul	r18, r21
    4b90:	90 0d       	add	r25, r0
    4b92:	34 9f       	mul	r19, r20
    4b94:	90 0d       	add	r25, r0
    4b96:	11 24       	eor	r1, r1
    4b98:	9c 01       	movw	r18, r24
    4b9a:	8a 81       	ldd	r24, Y+2	; 0x02
    4b9c:	9b 81       	ldd	r25, Y+3	; 0x03
    4b9e:	82 0f       	add	r24, r18
    4ba0:	93 1f       	adc	r25, r19
    4ba2:	9b 83       	std	Y+3, r25	; 0x03
    4ba4:	8a 83       	std	Y+2, r24	; 0x02

		Local_u8Factor = (u8)(Copy_u16Val / (u16) 10);
    4ba6:	8a 81       	ldd	r24, Y+2	; 0x02
    4ba8:	9b 81       	ldd	r25, Y+3	; 0x03
    4baa:	2a e0       	ldi	r18, 0x0A	; 10
    4bac:	30 e0       	ldi	r19, 0x00	; 0
    4bae:	b9 01       	movw	r22, r18
    4bb0:	0e 94 dc 2b 	call	0x57b8	; 0x57b8 <__udivmodhi4>
    4bb4:	cb 01       	movw	r24, r22
    4bb6:	89 83       	std	Y+1, r24	; 0x01
		LCD_vWriteChar(Local_u8Factor+48);
    4bb8:	89 81       	ldd	r24, Y+1	; 0x01
    4bba:	80 5d       	subi	r24, 0xD0	; 208
    4bbc:	0e 94 d5 21 	call	0x43aa	; 0x43aa <LCD_vWriteChar>
		Local_u8Factor = Copy_u16Val - (u16)(Local_u8Factor * (u8)10);
    4bc0:	89 81       	ldd	r24, Y+1	; 0x01
    4bc2:	88 2f       	mov	r24, r24
    4bc4:	90 e0       	ldi	r25, 0x00	; 0
    4bc6:	9c 01       	movw	r18, r24
    4bc8:	22 0f       	add	r18, r18
    4bca:	33 1f       	adc	r19, r19
    4bcc:	c9 01       	movw	r24, r18
    4bce:	88 0f       	add	r24, r24
    4bd0:	99 1f       	adc	r25, r25
    4bd2:	88 0f       	add	r24, r24
    4bd4:	99 1f       	adc	r25, r25
    4bd6:	82 0f       	add	r24, r18
    4bd8:	93 1f       	adc	r25, r19
    4bda:	90 95       	com	r25
    4bdc:	81 95       	neg	r24
    4bde:	9f 4f       	sbci	r25, 0xFF	; 255
    4be0:	98 2f       	mov	r25, r24
    4be2:	8a 81       	ldd	r24, Y+2	; 0x02
    4be4:	89 0f       	add	r24, r25
    4be6:	89 83       	std	Y+1, r24	; 0x01
		LCD_vWriteChar(Local_u8Factor+48);
    4be8:	89 81       	ldd	r24, Y+1	; 0x01
    4bea:	80 5d       	subi	r24, 0xD0	; 208
    4bec:	0e 94 d5 21 	call	0x43aa	; 0x43aa <LCD_vWriteChar>
    4bf0:	79 c0       	rjmp	.+242    	; 0x4ce4 <Log_voidPrintNumber+0x2fa>
	}

	else if (Copy_u16Val >= (u8)100 )
    4bf2:	8a 81       	ldd	r24, Y+2	; 0x02
    4bf4:	9b 81       	ldd	r25, Y+3	; 0x03
    4bf6:	84 36       	cpi	r24, 0x64	; 100
    4bf8:	91 05       	cpc	r25, r1
    4bfa:	08 f4       	brcc	.+2      	; 0x4bfe <Log_voidPrintNumber+0x214>
    4bfc:	47 c0       	rjmp	.+142    	; 0x4c8c <Log_voidPrintNumber+0x2a2>
	{
		Local_u8Factor = (u8)(Copy_u16Val / (u16) 100);
    4bfe:	8a 81       	ldd	r24, Y+2	; 0x02
    4c00:	9b 81       	ldd	r25, Y+3	; 0x03
    4c02:	24 e6       	ldi	r18, 0x64	; 100
    4c04:	30 e0       	ldi	r19, 0x00	; 0
    4c06:	b9 01       	movw	r22, r18
    4c08:	0e 94 dc 2b 	call	0x57b8	; 0x57b8 <__udivmodhi4>
    4c0c:	cb 01       	movw	r24, r22
    4c0e:	89 83       	std	Y+1, r24	; 0x01
		LCD_vWriteChar(Local_u8Factor+48);
    4c10:	89 81       	ldd	r24, Y+1	; 0x01
    4c12:	80 5d       	subi	r24, 0xD0	; 208
    4c14:	0e 94 d5 21 	call	0x43aa	; 0x43aa <LCD_vWriteChar>
		Copy_u16Val = Copy_u16Val - (u16)(Local_u8Factor * (u8)100);
    4c18:	89 81       	ldd	r24, Y+1	; 0x01
    4c1a:	28 2f       	mov	r18, r24
    4c1c:	30 e0       	ldi	r19, 0x00	; 0
    4c1e:	8c e9       	ldi	r24, 0x9C	; 156
    4c20:	9f ef       	ldi	r25, 0xFF	; 255
    4c22:	ac 01       	movw	r20, r24
    4c24:	24 9f       	mul	r18, r20
    4c26:	c0 01       	movw	r24, r0
    4c28:	25 9f       	mul	r18, r21
    4c2a:	90 0d       	add	r25, r0
    4c2c:	34 9f       	mul	r19, r20
    4c2e:	90 0d       	add	r25, r0
    4c30:	11 24       	eor	r1, r1
    4c32:	9c 01       	movw	r18, r24
    4c34:	8a 81       	ldd	r24, Y+2	; 0x02
    4c36:	9b 81       	ldd	r25, Y+3	; 0x03
    4c38:	82 0f       	add	r24, r18
    4c3a:	93 1f       	adc	r25, r19
    4c3c:	9b 83       	std	Y+3, r25	; 0x03
    4c3e:	8a 83       	std	Y+2, r24	; 0x02

		Local_u8Factor = (u8)(Copy_u16Val / (u16) 10);
    4c40:	8a 81       	ldd	r24, Y+2	; 0x02
    4c42:	9b 81       	ldd	r25, Y+3	; 0x03
    4c44:	2a e0       	ldi	r18, 0x0A	; 10
    4c46:	30 e0       	ldi	r19, 0x00	; 0
    4c48:	b9 01       	movw	r22, r18
    4c4a:	0e 94 dc 2b 	call	0x57b8	; 0x57b8 <__udivmodhi4>
    4c4e:	cb 01       	movw	r24, r22
    4c50:	89 83       	std	Y+1, r24	; 0x01
		LCD_vWriteChar(Local_u8Factor+48);
    4c52:	89 81       	ldd	r24, Y+1	; 0x01
    4c54:	80 5d       	subi	r24, 0xD0	; 208
    4c56:	0e 94 d5 21 	call	0x43aa	; 0x43aa <LCD_vWriteChar>
		Local_u8Factor = Copy_u16Val - (u16)(Local_u8Factor * (u8)10);
    4c5a:	89 81       	ldd	r24, Y+1	; 0x01
    4c5c:	88 2f       	mov	r24, r24
    4c5e:	90 e0       	ldi	r25, 0x00	; 0
    4c60:	9c 01       	movw	r18, r24
    4c62:	22 0f       	add	r18, r18
    4c64:	33 1f       	adc	r19, r19
    4c66:	c9 01       	movw	r24, r18
    4c68:	88 0f       	add	r24, r24
    4c6a:	99 1f       	adc	r25, r25
    4c6c:	88 0f       	add	r24, r24
    4c6e:	99 1f       	adc	r25, r25
    4c70:	82 0f       	add	r24, r18
    4c72:	93 1f       	adc	r25, r19
    4c74:	90 95       	com	r25
    4c76:	81 95       	neg	r24
    4c78:	9f 4f       	sbci	r25, 0xFF	; 255
    4c7a:	98 2f       	mov	r25, r24
    4c7c:	8a 81       	ldd	r24, Y+2	; 0x02
    4c7e:	89 0f       	add	r24, r25
    4c80:	89 83       	std	Y+1, r24	; 0x01
		LCD_vWriteChar(Local_u8Factor+48);
    4c82:	89 81       	ldd	r24, Y+1	; 0x01
    4c84:	80 5d       	subi	r24, 0xD0	; 208
    4c86:	0e 94 d5 21 	call	0x43aa	; 0x43aa <LCD_vWriteChar>
    4c8a:	2c c0       	rjmp	.+88     	; 0x4ce4 <Log_voidPrintNumber+0x2fa>
	}

	else if (Copy_u16Val >= (u8) 10 )
    4c8c:	8a 81       	ldd	r24, Y+2	; 0x02
    4c8e:	9b 81       	ldd	r25, Y+3	; 0x03
    4c90:	8a 30       	cpi	r24, 0x0A	; 10
    4c92:	91 05       	cpc	r25, r1
    4c94:	18 f1       	brcs	.+70     	; 0x4cdc <Log_voidPrintNumber+0x2f2>
	{
		Local_u8Factor = (u8)((u8)Copy_u16Val / (u8) 10);
    4c96:	8a 81       	ldd	r24, Y+2	; 0x02
    4c98:	9a e0       	ldi	r25, 0x0A	; 10
    4c9a:	69 2f       	mov	r22, r25
    4c9c:	0e 94 d0 2b 	call	0x57a0	; 0x57a0 <__udivmodqi4>
    4ca0:	89 83       	std	Y+1, r24	; 0x01
		LCD_vWriteChar(Local_u8Factor+48);
    4ca2:	89 81       	ldd	r24, Y+1	; 0x01
    4ca4:	80 5d       	subi	r24, 0xD0	; 208
    4ca6:	0e 94 d5 21 	call	0x43aa	; 0x43aa <LCD_vWriteChar>
		Local_u8Factor = Copy_u16Val - (u16)(Local_u8Factor * (u8)10);
    4caa:	89 81       	ldd	r24, Y+1	; 0x01
    4cac:	88 2f       	mov	r24, r24
    4cae:	90 e0       	ldi	r25, 0x00	; 0
    4cb0:	9c 01       	movw	r18, r24
    4cb2:	22 0f       	add	r18, r18
    4cb4:	33 1f       	adc	r19, r19
    4cb6:	c9 01       	movw	r24, r18
    4cb8:	88 0f       	add	r24, r24
    4cba:	99 1f       	adc	r25, r25
    4cbc:	88 0f       	add	r24, r24
    4cbe:	99 1f       	adc	r25, r25
    4cc0:	82 0f       	add	r24, r18
    4cc2:	93 1f       	adc	r25, r19
    4cc4:	90 95       	com	r25
    4cc6:	81 95       	neg	r24
    4cc8:	9f 4f       	sbci	r25, 0xFF	; 255
    4cca:	98 2f       	mov	r25, r24
    4ccc:	8a 81       	ldd	r24, Y+2	; 0x02
    4cce:	89 0f       	add	r24, r25
    4cd0:	89 83       	std	Y+1, r24	; 0x01
		LCD_vWriteChar(Local_u8Factor+48);
    4cd2:	89 81       	ldd	r24, Y+1	; 0x01
    4cd4:	80 5d       	subi	r24, 0xD0	; 208
    4cd6:	0e 94 d5 21 	call	0x43aa	; 0x43aa <LCD_vWriteChar>
    4cda:	04 c0       	rjmp	.+8      	; 0x4ce4 <Log_voidPrintNumber+0x2fa>
	}

	else
	{
		LCD_vWriteChar(Copy_u16Val+48);
    4cdc:	8a 81       	ldd	r24, Y+2	; 0x02
    4cde:	80 5d       	subi	r24, 0xD0	; 208
    4ce0:	0e 94 d5 21 	call	0x43aa	; 0x43aa <LCD_vWriteChar>
	}
}
    4ce4:	0f 90       	pop	r0
    4ce6:	0f 90       	pop	r0
    4ce8:	0f 90       	pop	r0
    4cea:	cf 91       	pop	r28
    4cec:	df 91       	pop	r29
    4cee:	08 95       	ret

00004cf0 <HLCD_voidWriteNumber>:
void HLCD_voidWriteNumber(u16 Copy_u16Number){
    4cf0:	df 93       	push	r29
    4cf2:	cf 93       	push	r28
    4cf4:	00 d0       	rcall	.+0      	; 0x4cf6 <HLCD_voidWriteNumber+0x6>
    4cf6:	cd b7       	in	r28, 0x3d	; 61
    4cf8:	de b7       	in	r29, 0x3e	; 62
    4cfa:	9a 83       	std	Y+2, r25	; 0x02
    4cfc:	89 83       	std	Y+1, r24	; 0x01

	if(Copy_u16Number < 10 ){
    4cfe:	89 81       	ldd	r24, Y+1	; 0x01
    4d00:	9a 81       	ldd	r25, Y+2	; 0x02
    4d02:	8a 30       	cpi	r24, 0x0A	; 10
    4d04:	91 05       	cpc	r25, r1
    4d06:	28 f4       	brcc	.+10     	; 0x4d12 <HLCD_voidWriteNumber+0x22>
		LCD_vWriteChar(Copy_u16Number + '0') ;
    4d08:	89 81       	ldd	r24, Y+1	; 0x01
    4d0a:	80 5d       	subi	r24, 0xD0	; 208
    4d0c:	0e 94 d5 21 	call	0x43aa	; 0x43aa <LCD_vWriteChar>
    4d10:	c8 c0       	rjmp	.+400    	; 0x4ea2 <HLCD_voidWriteNumber+0x1b2>

	}
	else if(Copy_u16Number < 100 ){
    4d12:	89 81       	ldd	r24, Y+1	; 0x01
    4d14:	9a 81       	ldd	r25, Y+2	; 0x02
    4d16:	84 36       	cpi	r24, 0x64	; 100
    4d18:	91 05       	cpc	r25, r1
    4d1a:	b0 f4       	brcc	.+44     	; 0x4d48 <HLCD_voidWriteNumber+0x58>
		LCD_vWriteChar((Copy_u16Number/10) + '0') ;
    4d1c:	89 81       	ldd	r24, Y+1	; 0x01
    4d1e:	9a 81       	ldd	r25, Y+2	; 0x02
    4d20:	2a e0       	ldi	r18, 0x0A	; 10
    4d22:	30 e0       	ldi	r19, 0x00	; 0
    4d24:	b9 01       	movw	r22, r18
    4d26:	0e 94 dc 2b 	call	0x57b8	; 0x57b8 <__udivmodhi4>
    4d2a:	cb 01       	movw	r24, r22
    4d2c:	80 5d       	subi	r24, 0xD0	; 208
    4d2e:	0e 94 d5 21 	call	0x43aa	; 0x43aa <LCD_vWriteChar>
		LCD_vWriteChar((Copy_u16Number%10) + '0') ;
    4d32:	89 81       	ldd	r24, Y+1	; 0x01
    4d34:	9a 81       	ldd	r25, Y+2	; 0x02
    4d36:	2a e0       	ldi	r18, 0x0A	; 10
    4d38:	30 e0       	ldi	r19, 0x00	; 0
    4d3a:	b9 01       	movw	r22, r18
    4d3c:	0e 94 dc 2b 	call	0x57b8	; 0x57b8 <__udivmodhi4>
    4d40:	80 5d       	subi	r24, 0xD0	; 208
    4d42:	0e 94 d5 21 	call	0x43aa	; 0x43aa <LCD_vWriteChar>
    4d46:	ad c0       	rjmp	.+346    	; 0x4ea2 <HLCD_voidWriteNumber+0x1b2>
	}
	else if(Copy_u16Number < 1000 ){
    4d48:	89 81       	ldd	r24, Y+1	; 0x01
    4d4a:	9a 81       	ldd	r25, Y+2	; 0x02
    4d4c:	23 e0       	ldi	r18, 0x03	; 3
    4d4e:	88 3e       	cpi	r24, 0xE8	; 232
    4d50:	92 07       	cpc	r25, r18
    4d52:	30 f5       	brcc	.+76     	; 0x4da0 <HLCD_voidWriteNumber+0xb0>
		LCD_vWriteChar((Copy_u16Number/100)   + '0') ;
    4d54:	89 81       	ldd	r24, Y+1	; 0x01
    4d56:	9a 81       	ldd	r25, Y+2	; 0x02
    4d58:	24 e6       	ldi	r18, 0x64	; 100
    4d5a:	30 e0       	ldi	r19, 0x00	; 0
    4d5c:	b9 01       	movw	r22, r18
    4d5e:	0e 94 dc 2b 	call	0x57b8	; 0x57b8 <__udivmodhi4>
    4d62:	cb 01       	movw	r24, r22
    4d64:	80 5d       	subi	r24, 0xD0	; 208
    4d66:	0e 94 d5 21 	call	0x43aa	; 0x43aa <LCD_vWriteChar>
		LCD_vWriteChar((Copy_u16Number/10)%10 + '0') ;
    4d6a:	89 81       	ldd	r24, Y+1	; 0x01
    4d6c:	9a 81       	ldd	r25, Y+2	; 0x02
    4d6e:	2a e0       	ldi	r18, 0x0A	; 10
    4d70:	30 e0       	ldi	r19, 0x00	; 0
    4d72:	b9 01       	movw	r22, r18
    4d74:	0e 94 dc 2b 	call	0x57b8	; 0x57b8 <__udivmodhi4>
    4d78:	cb 01       	movw	r24, r22
    4d7a:	2a e0       	ldi	r18, 0x0A	; 10
    4d7c:	30 e0       	ldi	r19, 0x00	; 0
    4d7e:	b9 01       	movw	r22, r18
    4d80:	0e 94 dc 2b 	call	0x57b8	; 0x57b8 <__udivmodhi4>
    4d84:	80 5d       	subi	r24, 0xD0	; 208
    4d86:	0e 94 d5 21 	call	0x43aa	; 0x43aa <LCD_vWriteChar>
		LCD_vWriteChar((Copy_u16Number%10)    + '0') ;
    4d8a:	89 81       	ldd	r24, Y+1	; 0x01
    4d8c:	9a 81       	ldd	r25, Y+2	; 0x02
    4d8e:	2a e0       	ldi	r18, 0x0A	; 10
    4d90:	30 e0       	ldi	r19, 0x00	; 0
    4d92:	b9 01       	movw	r22, r18
    4d94:	0e 94 dc 2b 	call	0x57b8	; 0x57b8 <__udivmodhi4>
    4d98:	80 5d       	subi	r24, 0xD0	; 208
    4d9a:	0e 94 d5 21 	call	0x43aa	; 0x43aa <LCD_vWriteChar>
    4d9e:	81 c0       	rjmp	.+258    	; 0x4ea2 <HLCD_voidWriteNumber+0x1b2>
	}
	else if(Copy_u16Number < 10000 ){
    4da0:	89 81       	ldd	r24, Y+1	; 0x01
    4da2:	9a 81       	ldd	r25, Y+2	; 0x02
    4da4:	27 e2       	ldi	r18, 0x27	; 39
    4da6:	80 31       	cpi	r24, 0x10	; 16
    4da8:	92 07       	cpc	r25, r18
    4daa:	b0 f5       	brcc	.+108    	; 0x4e18 <HLCD_voidWriteNumber+0x128>
		LCD_vWriteChar((Copy_u16Number/1000)   + '0') ;
    4dac:	89 81       	ldd	r24, Y+1	; 0x01
    4dae:	9a 81       	ldd	r25, Y+2	; 0x02
    4db0:	28 ee       	ldi	r18, 0xE8	; 232
    4db2:	33 e0       	ldi	r19, 0x03	; 3
    4db4:	b9 01       	movw	r22, r18
    4db6:	0e 94 dc 2b 	call	0x57b8	; 0x57b8 <__udivmodhi4>
    4dba:	cb 01       	movw	r24, r22
    4dbc:	80 5d       	subi	r24, 0xD0	; 208
    4dbe:	0e 94 d5 21 	call	0x43aa	; 0x43aa <LCD_vWriteChar>
		LCD_vWriteChar((Copy_u16Number/100)%10   + '0') ;
    4dc2:	89 81       	ldd	r24, Y+1	; 0x01
    4dc4:	9a 81       	ldd	r25, Y+2	; 0x02
    4dc6:	24 e6       	ldi	r18, 0x64	; 100
    4dc8:	30 e0       	ldi	r19, 0x00	; 0
    4dca:	b9 01       	movw	r22, r18
    4dcc:	0e 94 dc 2b 	call	0x57b8	; 0x57b8 <__udivmodhi4>
    4dd0:	cb 01       	movw	r24, r22
    4dd2:	2a e0       	ldi	r18, 0x0A	; 10
    4dd4:	30 e0       	ldi	r19, 0x00	; 0
    4dd6:	b9 01       	movw	r22, r18
    4dd8:	0e 94 dc 2b 	call	0x57b8	; 0x57b8 <__udivmodhi4>
    4ddc:	80 5d       	subi	r24, 0xD0	; 208
    4dde:	0e 94 d5 21 	call	0x43aa	; 0x43aa <LCD_vWriteChar>
		LCD_vWriteChar((Copy_u16Number/10)%10 + '0') ;
    4de2:	89 81       	ldd	r24, Y+1	; 0x01
    4de4:	9a 81       	ldd	r25, Y+2	; 0x02
    4de6:	2a e0       	ldi	r18, 0x0A	; 10
    4de8:	30 e0       	ldi	r19, 0x00	; 0
    4dea:	b9 01       	movw	r22, r18
    4dec:	0e 94 dc 2b 	call	0x57b8	; 0x57b8 <__udivmodhi4>
    4df0:	cb 01       	movw	r24, r22
    4df2:	2a e0       	ldi	r18, 0x0A	; 10
    4df4:	30 e0       	ldi	r19, 0x00	; 0
    4df6:	b9 01       	movw	r22, r18
    4df8:	0e 94 dc 2b 	call	0x57b8	; 0x57b8 <__udivmodhi4>
    4dfc:	80 5d       	subi	r24, 0xD0	; 208
    4dfe:	0e 94 d5 21 	call	0x43aa	; 0x43aa <LCD_vWriteChar>
		LCD_vWriteChar((Copy_u16Number%10)    + '0') ;
    4e02:	89 81       	ldd	r24, Y+1	; 0x01
    4e04:	9a 81       	ldd	r25, Y+2	; 0x02
    4e06:	2a e0       	ldi	r18, 0x0A	; 10
    4e08:	30 e0       	ldi	r19, 0x00	; 0
    4e0a:	b9 01       	movw	r22, r18
    4e0c:	0e 94 dc 2b 	call	0x57b8	; 0x57b8 <__udivmodhi4>
    4e10:	80 5d       	subi	r24, 0xD0	; 208
    4e12:	0e 94 d5 21 	call	0x43aa	; 0x43aa <LCD_vWriteChar>
    4e16:	45 c0       	rjmp	.+138    	; 0x4ea2 <HLCD_voidWriteNumber+0x1b2>
	}
	else if(Copy_u16Number < 100000 ){
		LCD_vWriteChar((Copy_u16Number/10000)   + '0') ;
    4e18:	89 81       	ldd	r24, Y+1	; 0x01
    4e1a:	9a 81       	ldd	r25, Y+2	; 0x02
    4e1c:	20 e1       	ldi	r18, 0x10	; 16
    4e1e:	37 e2       	ldi	r19, 0x27	; 39
    4e20:	b9 01       	movw	r22, r18
    4e22:	0e 94 dc 2b 	call	0x57b8	; 0x57b8 <__udivmodhi4>
    4e26:	cb 01       	movw	r24, r22
    4e28:	80 5d       	subi	r24, 0xD0	; 208
    4e2a:	0e 94 d5 21 	call	0x43aa	; 0x43aa <LCD_vWriteChar>
		LCD_vWriteChar((Copy_u16Number/1000)%10   + '0') ;
    4e2e:	89 81       	ldd	r24, Y+1	; 0x01
    4e30:	9a 81       	ldd	r25, Y+2	; 0x02
    4e32:	28 ee       	ldi	r18, 0xE8	; 232
    4e34:	33 e0       	ldi	r19, 0x03	; 3
    4e36:	b9 01       	movw	r22, r18
    4e38:	0e 94 dc 2b 	call	0x57b8	; 0x57b8 <__udivmodhi4>
    4e3c:	cb 01       	movw	r24, r22
    4e3e:	2a e0       	ldi	r18, 0x0A	; 10
    4e40:	30 e0       	ldi	r19, 0x00	; 0
    4e42:	b9 01       	movw	r22, r18
    4e44:	0e 94 dc 2b 	call	0x57b8	; 0x57b8 <__udivmodhi4>
    4e48:	80 5d       	subi	r24, 0xD0	; 208
    4e4a:	0e 94 d5 21 	call	0x43aa	; 0x43aa <LCD_vWriteChar>
		LCD_vWriteChar((Copy_u16Number/100)%10 + '0') ;
    4e4e:	89 81       	ldd	r24, Y+1	; 0x01
    4e50:	9a 81       	ldd	r25, Y+2	; 0x02
    4e52:	24 e6       	ldi	r18, 0x64	; 100
    4e54:	30 e0       	ldi	r19, 0x00	; 0
    4e56:	b9 01       	movw	r22, r18
    4e58:	0e 94 dc 2b 	call	0x57b8	; 0x57b8 <__udivmodhi4>
    4e5c:	cb 01       	movw	r24, r22
    4e5e:	2a e0       	ldi	r18, 0x0A	; 10
    4e60:	30 e0       	ldi	r19, 0x00	; 0
    4e62:	b9 01       	movw	r22, r18
    4e64:	0e 94 dc 2b 	call	0x57b8	; 0x57b8 <__udivmodhi4>
    4e68:	80 5d       	subi	r24, 0xD0	; 208
    4e6a:	0e 94 d5 21 	call	0x43aa	; 0x43aa <LCD_vWriteChar>
		LCD_vWriteChar((Copy_u16Number/10)%10    + '0') ;
    4e6e:	89 81       	ldd	r24, Y+1	; 0x01
    4e70:	9a 81       	ldd	r25, Y+2	; 0x02
    4e72:	2a e0       	ldi	r18, 0x0A	; 10
    4e74:	30 e0       	ldi	r19, 0x00	; 0
    4e76:	b9 01       	movw	r22, r18
    4e78:	0e 94 dc 2b 	call	0x57b8	; 0x57b8 <__udivmodhi4>
    4e7c:	cb 01       	movw	r24, r22
    4e7e:	2a e0       	ldi	r18, 0x0A	; 10
    4e80:	30 e0       	ldi	r19, 0x00	; 0
    4e82:	b9 01       	movw	r22, r18
    4e84:	0e 94 dc 2b 	call	0x57b8	; 0x57b8 <__udivmodhi4>
    4e88:	80 5d       	subi	r24, 0xD0	; 208
    4e8a:	0e 94 d5 21 	call	0x43aa	; 0x43aa <LCD_vWriteChar>
		LCD_vWriteChar((Copy_u16Number%10)     + '0') ;
    4e8e:	89 81       	ldd	r24, Y+1	; 0x01
    4e90:	9a 81       	ldd	r25, Y+2	; 0x02
    4e92:	2a e0       	ldi	r18, 0x0A	; 10
    4e94:	30 e0       	ldi	r19, 0x00	; 0
    4e96:	b9 01       	movw	r22, r18
    4e98:	0e 94 dc 2b 	call	0x57b8	; 0x57b8 <__udivmodhi4>
    4e9c:	80 5d       	subi	r24, 0xD0	; 208
    4e9e:	0e 94 d5 21 	call	0x43aa	; 0x43aa <LCD_vWriteChar>
	}
}
    4ea2:	0f 90       	pop	r0
    4ea4:	0f 90       	pop	r0
    4ea6:	cf 91       	pop	r28
    4ea8:	df 91       	pop	r29
    4eaa:	08 95       	ret

00004eac <Keybad_Initia>:

const u8 Keybad_value[keybad_rows][keybad_colum]={{55,56,57,45} ,{52,53,54,43} ,{49,50,51,42} ,{46,48,61,47}	};


void Keybad_Initia(void)
{
    4eac:	df 93       	push	r29
    4eae:	cf 93       	push	r28
    4eb0:	cd b7       	in	r28, 0x3d	; 61
    4eb2:	de b7       	in	r29, 0x3e	; 62
	DIO_vSetPinDirection(KEYBAD_PORT,R0,OUTPUT);
    4eb4:	83 e0       	ldi	r24, 0x03	; 3
    4eb6:	60 e0       	ldi	r22, 0x00	; 0
    4eb8:	42 e0       	ldi	r20, 0x02	; 2
    4eba:	0e 94 ed 19 	call	0x33da	; 0x33da <DIO_vSetPinDirection>
	DIO_vSetPinDirection(KEYBAD_PORT,R1,OUTPUT);
    4ebe:	83 e0       	ldi	r24, 0x03	; 3
    4ec0:	61 e0       	ldi	r22, 0x01	; 1
    4ec2:	42 e0       	ldi	r20, 0x02	; 2
    4ec4:	0e 94 ed 19 	call	0x33da	; 0x33da <DIO_vSetPinDirection>
	DIO_vSetPinDirection(KEYBAD_PORT,R2,OUTPUT);
    4ec8:	83 e0       	ldi	r24, 0x03	; 3
    4eca:	62 e0       	ldi	r22, 0x02	; 2
    4ecc:	42 e0       	ldi	r20, 0x02	; 2
    4ece:	0e 94 ed 19 	call	0x33da	; 0x33da <DIO_vSetPinDirection>
	DIO_vSetPinDirection(KEYBAD_PORT,R3,OUTPUT);
    4ed2:	83 e0       	ldi	r24, 0x03	; 3
    4ed4:	63 e0       	ldi	r22, 0x03	; 3
    4ed6:	42 e0       	ldi	r20, 0x02	; 2
    4ed8:	0e 94 ed 19 	call	0x33da	; 0x33da <DIO_vSetPinDirection>

	DIO_vSetPinDirection(KEYBAD_PORT,C0,INPUT);
    4edc:	83 e0       	ldi	r24, 0x03	; 3
    4ede:	64 e0       	ldi	r22, 0x04	; 4
    4ee0:	40 e0       	ldi	r20, 0x00	; 0
    4ee2:	0e 94 ed 19 	call	0x33da	; 0x33da <DIO_vSetPinDirection>
	DIO_vSetPinDirection(KEYBAD_PORT,C1,INPUT);
    4ee6:	83 e0       	ldi	r24, 0x03	; 3
    4ee8:	65 e0       	ldi	r22, 0x05	; 5
    4eea:	40 e0       	ldi	r20, 0x00	; 0
    4eec:	0e 94 ed 19 	call	0x33da	; 0x33da <DIO_vSetPinDirection>
	DIO_vSetPinDirection(KEYBAD_PORT,C2,INPUT);
    4ef0:	83 e0       	ldi	r24, 0x03	; 3
    4ef2:	66 e0       	ldi	r22, 0x06	; 6
    4ef4:	40 e0       	ldi	r20, 0x00	; 0
    4ef6:	0e 94 ed 19 	call	0x33da	; 0x33da <DIO_vSetPinDirection>
	DIO_vSetPinDirection(KEYBAD_PORT,C3,INPUT);
    4efa:	83 e0       	ldi	r24, 0x03	; 3
    4efc:	67 e0       	ldi	r22, 0x07	; 7
    4efe:	40 e0       	ldi	r20, 0x00	; 0
    4f00:	0e 94 ed 19 	call	0x33da	; 0x33da <DIO_vSetPinDirection>

	DIO_vWritePort(KEYBAD_PORT,HIGH);
    4f04:	83 e0       	ldi	r24, 0x03	; 3
    4f06:	61 e0       	ldi	r22, 0x01	; 1
    4f08:	0e 94 19 1f 	call	0x3e32	; 0x3e32 <DIO_vWritePort>

}
    4f0c:	cf 91       	pop	r28
    4f0e:	df 91       	pop	r29
    4f10:	08 95       	ret

00004f12 <Keybad_getpressed>:

u8 Keybad_getpressed(void)
{
    4f12:	df 93       	push	r29
    4f14:	cf 93       	push	r28
    4f16:	cd b7       	in	r28, 0x3d	; 61
    4f18:	de b7       	in	r29, 0x3e	; 62
    4f1a:	61 97       	sbiw	r28, 0x11	; 17
    4f1c:	0f b6       	in	r0, 0x3f	; 63
    4f1e:	f8 94       	cli
    4f20:	de bf       	out	0x3e, r29	; 62
    4f22:	0f be       	out	0x3f, r0	; 63
    4f24:	cd bf       	out	0x3d, r28	; 61
u8 Rowcount=0;
    4f26:	19 8a       	std	Y+17, r1	; 0x11
u8 Colcount=0;
    4f28:	18 8a       	std	Y+16, r1	; 0x10
u8 Result=0;
    4f2a:	1f 86       	std	Y+15, r1	; 0x0f
for(Rowcount=ROW_INITI;Rowcount<ROW_END;Rowcount++)
    4f2c:	19 8a       	std	Y+17, r1	; 0x11
    4f2e:	ab c0       	rjmp	.+342    	; 0x5086 <Keybad_getpressed+0x174>
{
	DIO_vWritePin(KEYBAD_PORT,Rowcount,LOW);
    4f30:	83 e0       	ldi	r24, 0x03	; 3
    4f32:	69 89       	ldd	r22, Y+17	; 0x11
    4f34:	40 e0       	ldi	r20, 0x00	; 0
    4f36:	0e 94 04 1c 	call	0x3808	; 0x3808 <DIO_vWritePin>

	for(Colcount=COLUM_INITI;Colcount<COLUM_END;Colcount++)
    4f3a:	84 e0       	ldi	r24, 0x04	; 4
    4f3c:	88 8b       	std	Y+16, r24	; 0x10
    4f3e:	97 c0       	rjmp	.+302    	; 0x506e <Keybad_getpressed+0x15c>
	{
		if (DIO_u8GetPinValue(KEYBAD_PORT,Colcount)==LOW)
    4f40:	83 e0       	ldi	r24, 0x03	; 3
    4f42:	68 89       	ldd	r22, Y+16	; 0x10
    4f44:	0e 94 1b 1d 	call	0x3a36	; 0x3a36 <DIO_u8GetPinValue>
    4f48:	88 23       	and	r24, r24
    4f4a:	09 f0       	breq	.+2      	; 0x4f4e <Keybad_getpressed+0x3c>
    4f4c:	8d c0       	rjmp	.+282    	; 0x5068 <Keybad_getpressed+0x156>
		{

			Result=Keybad_value[Rowcount-ROW_INITI][Colcount-COLUM_INITI];
    4f4e:	89 89       	ldd	r24, Y+17	; 0x11
    4f50:	48 2f       	mov	r20, r24
    4f52:	50 e0       	ldi	r21, 0x00	; 0
    4f54:	88 89       	ldd	r24, Y+16	; 0x10
    4f56:	88 2f       	mov	r24, r24
    4f58:	90 e0       	ldi	r25, 0x00	; 0
    4f5a:	9c 01       	movw	r18, r24
    4f5c:	24 50       	subi	r18, 0x04	; 4
    4f5e:	30 40       	sbci	r19, 0x00	; 0
    4f60:	ca 01       	movw	r24, r20
    4f62:	88 0f       	add	r24, r24
    4f64:	99 1f       	adc	r25, r25
    4f66:	88 0f       	add	r24, r24
    4f68:	99 1f       	adc	r25, r25
    4f6a:	82 0f       	add	r24, r18
    4f6c:	93 1f       	adc	r25, r19
    4f6e:	fc 01       	movw	r30, r24
    4f70:	ec 5d       	subi	r30, 0xDC	; 220
    4f72:	fe 4f       	sbci	r31, 0xFE	; 254
    4f74:	80 81       	ld	r24, Z
    4f76:	8f 87       	std	Y+15, r24	; 0x0f

			while(DIO_u8GetPinValue(KEYBAD_PORT,Colcount)==LOW);
    4f78:	83 e0       	ldi	r24, 0x03	; 3
    4f7a:	68 89       	ldd	r22, Y+16	; 0x10
    4f7c:	0e 94 1b 1d 	call	0x3a36	; 0x3a36 <DIO_u8GetPinValue>
    4f80:	88 23       	and	r24, r24
    4f82:	d1 f3       	breq	.-12     	; 0x4f78 <Keybad_getpressed+0x66>
    4f84:	80 e0       	ldi	r24, 0x00	; 0
    4f86:	90 e0       	ldi	r25, 0x00	; 0
    4f88:	a0 e2       	ldi	r26, 0x20	; 32
    4f8a:	b1 e4       	ldi	r27, 0x41	; 65
    4f8c:	8b 87       	std	Y+11, r24	; 0x0b
    4f8e:	9c 87       	std	Y+12, r25	; 0x0c
    4f90:	ad 87       	std	Y+13, r26	; 0x0d
    4f92:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    4f94:	6b 85       	ldd	r22, Y+11	; 0x0b
    4f96:	7c 85       	ldd	r23, Y+12	; 0x0c
    4f98:	8d 85       	ldd	r24, Y+13	; 0x0d
    4f9a:	9e 85       	ldd	r25, Y+14	; 0x0e
    4f9c:	20 e0       	ldi	r18, 0x00	; 0
    4f9e:	30 e0       	ldi	r19, 0x00	; 0
    4fa0:	4a ef       	ldi	r20, 0xFA	; 250
    4fa2:	54 e4       	ldi	r21, 0x44	; 68
    4fa4:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    4fa8:	dc 01       	movw	r26, r24
    4faa:	cb 01       	movw	r24, r22
    4fac:	8f 83       	std	Y+7, r24	; 0x07
    4fae:	98 87       	std	Y+8, r25	; 0x08
    4fb0:	a9 87       	std	Y+9, r26	; 0x09
    4fb2:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    4fb4:	6f 81       	ldd	r22, Y+7	; 0x07
    4fb6:	78 85       	ldd	r23, Y+8	; 0x08
    4fb8:	89 85       	ldd	r24, Y+9	; 0x09
    4fba:	9a 85       	ldd	r25, Y+10	; 0x0a
    4fbc:	20 e0       	ldi	r18, 0x00	; 0
    4fbe:	30 e0       	ldi	r19, 0x00	; 0
    4fc0:	40 e8       	ldi	r20, 0x80	; 128
    4fc2:	5f e3       	ldi	r21, 0x3F	; 63
    4fc4:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    4fc8:	88 23       	and	r24, r24
    4fca:	2c f4       	brge	.+10     	; 0x4fd6 <Keybad_getpressed+0xc4>
		__ticks = 1;
    4fcc:	81 e0       	ldi	r24, 0x01	; 1
    4fce:	90 e0       	ldi	r25, 0x00	; 0
    4fd0:	9e 83       	std	Y+6, r25	; 0x06
    4fd2:	8d 83       	std	Y+5, r24	; 0x05
    4fd4:	3f c0       	rjmp	.+126    	; 0x5054 <Keybad_getpressed+0x142>
	else if (__tmp > 65535)
    4fd6:	6f 81       	ldd	r22, Y+7	; 0x07
    4fd8:	78 85       	ldd	r23, Y+8	; 0x08
    4fda:	89 85       	ldd	r24, Y+9	; 0x09
    4fdc:	9a 85       	ldd	r25, Y+10	; 0x0a
    4fde:	20 e0       	ldi	r18, 0x00	; 0
    4fe0:	3f ef       	ldi	r19, 0xFF	; 255
    4fe2:	4f e7       	ldi	r20, 0x7F	; 127
    4fe4:	57 e4       	ldi	r21, 0x47	; 71
    4fe6:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    4fea:	18 16       	cp	r1, r24
    4fec:	4c f5       	brge	.+82     	; 0x5040 <Keybad_getpressed+0x12e>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    4fee:	6b 85       	ldd	r22, Y+11	; 0x0b
    4ff0:	7c 85       	ldd	r23, Y+12	; 0x0c
    4ff2:	8d 85       	ldd	r24, Y+13	; 0x0d
    4ff4:	9e 85       	ldd	r25, Y+14	; 0x0e
    4ff6:	20 e0       	ldi	r18, 0x00	; 0
    4ff8:	30 e0       	ldi	r19, 0x00	; 0
    4ffa:	40 e2       	ldi	r20, 0x20	; 32
    4ffc:	51 e4       	ldi	r21, 0x41	; 65
    4ffe:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    5002:	dc 01       	movw	r26, r24
    5004:	cb 01       	movw	r24, r22
    5006:	bc 01       	movw	r22, r24
    5008:	cd 01       	movw	r24, r26
    500a:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    500e:	dc 01       	movw	r26, r24
    5010:	cb 01       	movw	r24, r22
    5012:	9e 83       	std	Y+6, r25	; 0x06
    5014:	8d 83       	std	Y+5, r24	; 0x05
    5016:	0f c0       	rjmp	.+30     	; 0x5036 <Keybad_getpressed+0x124>
    5018:	88 ec       	ldi	r24, 0xC8	; 200
    501a:	90 e0       	ldi	r25, 0x00	; 0
    501c:	9c 83       	std	Y+4, r25	; 0x04
    501e:	8b 83       	std	Y+3, r24	; 0x03
    5020:	8b 81       	ldd	r24, Y+3	; 0x03
    5022:	9c 81       	ldd	r25, Y+4	; 0x04
    5024:	01 97       	sbiw	r24, 0x01	; 1
    5026:	f1 f7       	brne	.-4      	; 0x5024 <Keybad_getpressed+0x112>
    5028:	9c 83       	std	Y+4, r25	; 0x04
    502a:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    502c:	8d 81       	ldd	r24, Y+5	; 0x05
    502e:	9e 81       	ldd	r25, Y+6	; 0x06
    5030:	01 97       	sbiw	r24, 0x01	; 1
    5032:	9e 83       	std	Y+6, r25	; 0x06
    5034:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    5036:	8d 81       	ldd	r24, Y+5	; 0x05
    5038:	9e 81       	ldd	r25, Y+6	; 0x06
    503a:	00 97       	sbiw	r24, 0x00	; 0
    503c:	69 f7       	brne	.-38     	; 0x5018 <Keybad_getpressed+0x106>
    503e:	14 c0       	rjmp	.+40     	; 0x5068 <Keybad_getpressed+0x156>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    5040:	6f 81       	ldd	r22, Y+7	; 0x07
    5042:	78 85       	ldd	r23, Y+8	; 0x08
    5044:	89 85       	ldd	r24, Y+9	; 0x09
    5046:	9a 85       	ldd	r25, Y+10	; 0x0a
    5048:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    504c:	dc 01       	movw	r26, r24
    504e:	cb 01       	movw	r24, r22
    5050:	9e 83       	std	Y+6, r25	; 0x06
    5052:	8d 83       	std	Y+5, r24	; 0x05
    5054:	8d 81       	ldd	r24, Y+5	; 0x05
    5056:	9e 81       	ldd	r25, Y+6	; 0x06
    5058:	9a 83       	std	Y+2, r25	; 0x02
    505a:	89 83       	std	Y+1, r24	; 0x01
    505c:	89 81       	ldd	r24, Y+1	; 0x01
    505e:	9a 81       	ldd	r25, Y+2	; 0x02
    5060:	01 97       	sbiw	r24, 0x01	; 1
    5062:	f1 f7       	brne	.-4      	; 0x5060 <Keybad_getpressed+0x14e>
    5064:	9a 83       	std	Y+2, r25	; 0x02
    5066:	89 83       	std	Y+1, r24	; 0x01
u8 Result=0;
for(Rowcount=ROW_INITI;Rowcount<ROW_END;Rowcount++)
{
	DIO_vWritePin(KEYBAD_PORT,Rowcount,LOW);

	for(Colcount=COLUM_INITI;Colcount<COLUM_END;Colcount++)
    5068:	88 89       	ldd	r24, Y+16	; 0x10
    506a:	8f 5f       	subi	r24, 0xFF	; 255
    506c:	88 8b       	std	Y+16, r24	; 0x10
    506e:	88 89       	ldd	r24, Y+16	; 0x10
    5070:	88 30       	cpi	r24, 0x08	; 8
    5072:	08 f4       	brcc	.+2      	; 0x5076 <Keybad_getpressed+0x164>
    5074:	65 cf       	rjmp	.-310    	; 0x4f40 <Keybad_getpressed+0x2e>

			_delay_ms(10);
		}
	}

	DIO_vWritePin(KEYBAD_PORT,Rowcount,HIGH);
    5076:	83 e0       	ldi	r24, 0x03	; 3
    5078:	69 89       	ldd	r22, Y+17	; 0x11
    507a:	41 e0       	ldi	r20, 0x01	; 1
    507c:	0e 94 04 1c 	call	0x3808	; 0x3808 <DIO_vWritePin>
u8 Keybad_getpressed(void)
{
u8 Rowcount=0;
u8 Colcount=0;
u8 Result=0;
for(Rowcount=ROW_INITI;Rowcount<ROW_END;Rowcount++)
    5080:	89 89       	ldd	r24, Y+17	; 0x11
    5082:	8f 5f       	subi	r24, 0xFF	; 255
    5084:	89 8b       	std	Y+17, r24	; 0x11
    5086:	89 89       	ldd	r24, Y+17	; 0x11
    5088:	84 30       	cpi	r24, 0x04	; 4
    508a:	08 f4       	brcc	.+2      	; 0x508e <Keybad_getpressed+0x17c>
    508c:	51 cf       	rjmp	.-350    	; 0x4f30 <Keybad_getpressed+0x1e>

	DIO_vWritePin(KEYBAD_PORT,Rowcount,HIGH);


}
return Result;
    508e:	8f 85       	ldd	r24, Y+15	; 0x0f

}
    5090:	61 96       	adiw	r28, 0x11	; 17
    5092:	0f b6       	in	r0, 0x3f	; 63
    5094:	f8 94       	cli
    5096:	de bf       	out	0x3e, r29	; 62
    5098:	0f be       	out	0x3f, r0	; 63
    509a:	cd bf       	out	0x3d, r28	; 61
    509c:	cf 91       	pop	r28
    509e:	df 91       	pop	r29
    50a0:	08 95       	ret

000050a2 <System_Intia>:
xSemaphoreHandle TASK;
xSemaphoreHandle TASK2;
u8 flag=0;
u8 choose[1]={0};
void System_Intia(void)
{
    50a2:	df 93       	push	r29
    50a4:	cf 93       	push	r28
    50a6:	cd b7       	in	r28, 0x3d	; 61
    50a8:	de b7       	in	r29, 0x3e	; 62
	DIO_vSetPinDirection(PORT_A,0,OUTPUT);
    50aa:	80 e0       	ldi	r24, 0x00	; 0
    50ac:	60 e0       	ldi	r22, 0x00	; 0
    50ae:	42 e0       	ldi	r20, 0x02	; 2
    50b0:	0e 94 ed 19 	call	0x33da	; 0x33da <DIO_vSetPinDirection>
	DIO_vSetPortDirection(PORT_B,OUTPUT);
    50b4:	81 e0       	ldi	r24, 0x01	; 1
    50b6:	62 e0       	ldi	r22, 0x02	; 2
    50b8:	0e 94 43 1e 	call	0x3c86	; 0x3c86 <DIO_vSetPortDirection>
	Syc=xSemaphoreCreateCounting(1,0);
    50bc:	81 e0       	ldi	r24, 0x01	; 1
    50be:	60 e0       	ldi	r22, 0x00	; 0
    50c0:	0e 94 e8 0d 	call	0x1bd0	; 0x1bd0 <xQueueCreateCountingSemaphore>
    50c4:	90 93 db 05 	sts	0x05DB, r25
    50c8:	80 93 da 05 	sts	0x05DA, r24
	Syc2=xSemaphoreCreateCounting(1,0);
    50cc:	81 e0       	ldi	r24, 0x01	; 1
    50ce:	60 e0       	ldi	r22, 0x00	; 0
    50d0:	0e 94 e8 0d 	call	0x1bd0	; 0x1bd0 <xQueueCreateCountingSemaphore>
    50d4:	90 93 dd 05 	sts	0x05DD, r25
    50d8:	80 93 dc 05 	sts	0x05DC, r24
	MUTEX =xSemaphoreCreateMutex();
    50dc:	0e 94 9d 0d 	call	0x1b3a	; 0x1b3a <xQueueCreateMutex>
    50e0:	90 93 d5 05 	sts	0x05D5, r25
    50e4:	80 93 d4 05 	sts	0x05D4, r24
	TASK=xSemaphoreCreateCounting(1,0);
    50e8:	81 e0       	ldi	r24, 0x01	; 1
    50ea:	60 e0       	ldi	r22, 0x00	; 0
    50ec:	0e 94 e8 0d 	call	0x1bd0	; 0x1bd0 <xQueueCreateCountingSemaphore>
    50f0:	90 93 d9 05 	sts	0x05D9, r25
    50f4:	80 93 d8 05 	sts	0x05D8, r24
	TASK2=xSemaphoreCreateCounting(1,0);
    50f8:	81 e0       	ldi	r24, 0x01	; 1
    50fa:	60 e0       	ldi	r22, 0x00	; 0
    50fc:	0e 94 e8 0d 	call	0x1bd0	; 0x1bd0 <xQueueCreateCountingSemaphore>
    5100:	90 93 d3 05 	sts	0x05D3, r25
    5104:	80 93 d2 05 	sts	0x05D2, r24
	LCD_vInit();
    5108:	0e 94 65 23 	call	0x46ca	; 0x46ca <LCD_vInit>
	Keybad_Initia();
    510c:	0e 94 56 27 	call	0x4eac	; 0x4eac <Keybad_Initia>

}
    5110:	cf 91       	pop	r28
    5112:	df 91       	pop	r29
    5114:	08 95       	ret

00005116 <main>:



int main(void)
{
    5116:	af 92       	push	r10
    5118:	bf 92       	push	r11
    511a:	cf 92       	push	r12
    511c:	df 92       	push	r13
    511e:	ef 92       	push	r14
    5120:	ff 92       	push	r15
    5122:	0f 93       	push	r16
    5124:	df 93       	push	r29
    5126:	cf 93       	push	r28
    5128:	cd b7       	in	r28, 0x3d	; 61
    512a:	de b7       	in	r29, 0x3e	; 62

	System_Intia();
    512c:	0e 94 51 28 	call	0x50a2	; 0x50a2 <System_Intia>
	xTaskCreate(SIGN_IN,NULL,150,NULL,2,&SIGN);
    5130:	8c ef       	ldi	r24, 0xFC	; 252
    5132:	98 e2       	ldi	r25, 0x28	; 40
    5134:	e6 ed       	ldi	r30, 0xD6	; 214
    5136:	f5 e0       	ldi	r31, 0x05	; 5
    5138:	60 e0       	ldi	r22, 0x00	; 0
    513a:	70 e0       	ldi	r23, 0x00	; 0
    513c:	46 e9       	ldi	r20, 0x96	; 150
    513e:	50 e0       	ldi	r21, 0x00	; 0
    5140:	20 e0       	ldi	r18, 0x00	; 0
    5142:	30 e0       	ldi	r19, 0x00	; 0
    5144:	02 e0       	ldi	r16, 0x02	; 2
    5146:	7f 01       	movw	r14, r30
    5148:	cc 24       	eor	r12, r12
    514a:	dd 24       	eor	r13, r13
    514c:	aa 24       	eor	r10, r10
    514e:	bb 24       	eor	r11, r11
    5150:	0e 94 0d 12 	call	0x241a	; 0x241a <xTaskGenericCreate>
	xTaskCreate(CHECK,NULL,80,NULL,1,NULL);
    5154:	81 e2       	ldi	r24, 0x21	; 33
    5156:	9a e2       	ldi	r25, 0x2A	; 42
    5158:	60 e0       	ldi	r22, 0x00	; 0
    515a:	70 e0       	ldi	r23, 0x00	; 0
    515c:	40 e5       	ldi	r20, 0x50	; 80
    515e:	50 e0       	ldi	r21, 0x00	; 0
    5160:	20 e0       	ldi	r18, 0x00	; 0
    5162:	30 e0       	ldi	r19, 0x00	; 0
    5164:	01 e0       	ldi	r16, 0x01	; 1
    5166:	ee 24       	eor	r14, r14
    5168:	ff 24       	eor	r15, r15
    516a:	cc 24       	eor	r12, r12
    516c:	dd 24       	eor	r13, r13
    516e:	aa 24       	eor	r10, r10
    5170:	bb 24       	eor	r11, r11
    5172:	0e 94 0d 12 	call	0x241a	; 0x241a <xTaskGenericCreate>
	xTaskCreate(LOG_IN,NULL,150,NULL,1,NULL);
    5176:	86 e6       	ldi	r24, 0x66	; 102
    5178:	9a e2       	ldi	r25, 0x2A	; 42
    517a:	60 e0       	ldi	r22, 0x00	; 0
    517c:	70 e0       	ldi	r23, 0x00	; 0
    517e:	46 e9       	ldi	r20, 0x96	; 150
    5180:	50 e0       	ldi	r21, 0x00	; 0
    5182:	20 e0       	ldi	r18, 0x00	; 0
    5184:	30 e0       	ldi	r19, 0x00	; 0
    5186:	01 e0       	ldi	r16, 0x01	; 1
    5188:	ee 24       	eor	r14, r14
    518a:	ff 24       	eor	r15, r15
    518c:	cc 24       	eor	r12, r12
    518e:	dd 24       	eor	r13, r13
    5190:	aa 24       	eor	r10, r10
    5192:	bb 24       	eor	r11, r11
    5194:	0e 94 0d 12 	call	0x241a	; 0x241a <xTaskGenericCreate>
	xTaskCreate(LEDS,NULL,80,NULL,1,NULL);
    5198:	8f e9       	ldi	r24, 0x9F	; 159
    519a:	9b e2       	ldi	r25, 0x2B	; 43
    519c:	60 e0       	ldi	r22, 0x00	; 0
    519e:	70 e0       	ldi	r23, 0x00	; 0
    51a0:	40 e5       	ldi	r20, 0x50	; 80
    51a2:	50 e0       	ldi	r21, 0x00	; 0
    51a4:	20 e0       	ldi	r18, 0x00	; 0
    51a6:	30 e0       	ldi	r19, 0x00	; 0
    51a8:	01 e0       	ldi	r16, 0x01	; 1
    51aa:	ee 24       	eor	r14, r14
    51ac:	ff 24       	eor	r15, r15
    51ae:	cc 24       	eor	r12, r12
    51b0:	dd 24       	eor	r13, r13
    51b2:	aa 24       	eor	r10, r10
    51b4:	bb 24       	eor	r11, r11
    51b6:	0e 94 0d 12 	call	0x241a	; 0x241a <xTaskGenericCreate>
	xTaskCreate(Motor,NULL,80,NULL,1,NULL);
    51ba:	89 e7       	ldi	r24, 0x79	; 121
    51bc:	9b e2       	ldi	r25, 0x2B	; 43
    51be:	60 e0       	ldi	r22, 0x00	; 0
    51c0:	70 e0       	ldi	r23, 0x00	; 0
    51c2:	40 e5       	ldi	r20, 0x50	; 80
    51c4:	50 e0       	ldi	r21, 0x00	; 0
    51c6:	20 e0       	ldi	r18, 0x00	; 0
    51c8:	30 e0       	ldi	r19, 0x00	; 0
    51ca:	01 e0       	ldi	r16, 0x01	; 1
    51cc:	ee 24       	eor	r14, r14
    51ce:	ff 24       	eor	r15, r15
    51d0:	cc 24       	eor	r12, r12
    51d2:	dd 24       	eor	r13, r13
    51d4:	aa 24       	eor	r10, r10
    51d6:	bb 24       	eor	r11, r11
    51d8:	0e 94 0d 12 	call	0x241a	; 0x241a <xTaskGenericCreate>

	vTaskStartScheduler();
    51dc:	0e 94 06 14 	call	0x280c	; 0x280c <vTaskStartScheduler>

return 0;
    51e0:	80 e0       	ldi	r24, 0x00	; 0
    51e2:	90 e0       	ldi	r25, 0x00	; 0
}
    51e4:	cf 91       	pop	r28
    51e6:	df 91       	pop	r29
    51e8:	0f 91       	pop	r16
    51ea:	ff 90       	pop	r15
    51ec:	ef 90       	pop	r14
    51ee:	df 90       	pop	r13
    51f0:	cf 90       	pop	r12
    51f2:	bf 90       	pop	r11
    51f4:	af 90       	pop	r10
    51f6:	08 95       	ret

000051f8 <SIGN_IN>:

void SIGN_IN(void *pvParmater)
{
    51f8:	0f 93       	push	r16
    51fa:	1f 93       	push	r17
    51fc:	df 93       	push	r29
    51fe:	cf 93       	push	r28
    5200:	00 d0       	rcall	.+0      	; 0x5202 <SIGN_IN+0xa>
    5202:	00 d0       	rcall	.+0      	; 0x5204 <SIGN_IN+0xc>
    5204:	cd b7       	in	r28, 0x3d	; 61
    5206:	de b7       	in	r29, 0x3e	; 62
    5208:	9c 83       	std	Y+4, r25	; 0x04
    520a:	8b 83       	std	Y+3, r24	; 0x03
	u8 ret ;
	u8 counter=0 ;
    520c:	19 82       	std	Y+1, r1	; 0x01

	LCD_vSendString("Enter New Pass:");
    520e:	85 e6       	ldi	r24, 0x65	; 101
    5210:	90 e0       	ldi	r25, 0x00	; 0
    5212:	0e 94 cc 24 	call	0x4998	; 0x4998 <LCD_vSendString>
    5216:	07 c1       	rjmp	.+526    	; 0x5426 <SIGN_IN+0x22e>
				while(address<=Max_num_of_passowrd)
				{


				*(password_desired+address)=Keybad_getpressed(); // assign numbers into array1
    5218:	80 91 cf 05 	lds	r24, 0x05CF
    521c:	88 2f       	mov	r24, r24
    521e:	90 e0       	ldi	r25, 0x00	; 0
    5220:	8c 01       	movw	r16, r24
    5222:	05 54       	subi	r16, 0x45	; 69
    5224:	1a 4f       	sbci	r17, 0xFA	; 250
    5226:	0e 94 89 27 	call	0x4f12	; 0x4f12 <Keybad_getpressed>
    522a:	f8 01       	movw	r30, r16
    522c:	80 83       	st	Z, r24
				if(*(password_desired+address) == '=')
    522e:	80 91 cf 05 	lds	r24, 0x05CF
    5232:	88 2f       	mov	r24, r24
    5234:	90 e0       	ldi	r25, 0x00	; 0
    5236:	fc 01       	movw	r30, r24
    5238:	e5 54       	subi	r30, 0x45	; 69
    523a:	fa 4f       	sbci	r31, 0xFA	; 250
    523c:	80 81       	ld	r24, Z
    523e:	8d 33       	cpi	r24, 0x3D	; 61
    5240:	09 f0       	breq	.+2      	; 0x5244 <SIGN_IN+0x4c>
    5242:	c1 c0       	rjmp	.+386    	; 0x53c6 <SIGN_IN+0x1ce>
				  {
					*(password_desired+address)=0;
    5244:	80 91 cf 05 	lds	r24, 0x05CF
    5248:	88 2f       	mov	r24, r24
    524a:	90 e0       	ldi	r25, 0x00	; 0
    524c:	fc 01       	movw	r30, r24
    524e:	e5 54       	subi	r30, 0x45	; 69
    5250:	fa 4f       	sbci	r31, 0xFA	; 250
    5252:	10 82       	st	Z, r1
					 LCD_vClear();
    5254:	0e 94 c2 24 	call	0x4984	; 0x4984 <LCD_vClear>
				     LCD_vGotoxy(1,0);
    5258:	81 e0       	ldi	r24, 0x01	; 1
    525a:	60 e0       	ldi	r22, 0x00	; 0
    525c:	0e 94 96 24 	call	0x492c	; 0x492c <LCD_vGotoxy>
				     LCD_vSendString("Enter Pass Again:");
    5260:	85 e7       	ldi	r24, 0x75	; 117
    5262:	90 e0       	ldi	r25, 0x00	; 0
    5264:	0e 94 cc 24 	call	0x4998	; 0x4998 <LCD_vSendString>
				     address=0;
    5268:	10 92 cf 05 	sts	0x05CF, r1
    526c:	a6 c0       	rjmp	.+332    	; 0x53ba <SIGN_IN+0x1c2>
				     repeat :
				     while(address<=Max_num_of_passowrd)
				     	{

				    *(password_desired2+address)=Keybad_getpressed(); // assign numbers into array2
    526e:	80 91 cf 05 	lds	r24, 0x05CF
    5272:	88 2f       	mov	r24, r24
    5274:	90 e0       	ldi	r25, 0x00	; 0
    5276:	8c 01       	movw	r16, r24
    5278:	0b 53       	subi	r16, 0x3B	; 59
    527a:	1a 4f       	sbci	r17, 0xFA	; 250
    527c:	0e 94 89 27 	call	0x4f12	; 0x4f12 <Keybad_getpressed>
    5280:	f8 01       	movw	r30, r16
    5282:	80 83       	st	Z, r24
				  	if(*(password_desired2+address) == '=')
    5284:	80 91 cf 05 	lds	r24, 0x05CF
    5288:	88 2f       	mov	r24, r24
    528a:	90 e0       	ldi	r25, 0x00	; 0
    528c:	fc 01       	movw	r30, r24
    528e:	eb 53       	subi	r30, 0x3B	; 59
    5290:	fa 4f       	sbci	r31, 0xFA	; 250
    5292:	80 81       	ld	r24, Z
    5294:	8d 33       	cpi	r24, 0x3D	; 61
    5296:	09 f0       	breq	.+2      	; 0x529a <SIGN_IN+0xa2>
    5298:	60 c0       	rjmp	.+192    	; 0x535a <SIGN_IN+0x162>
				       {
				     	    *(password_desired2+address)=0;
    529a:	80 91 cf 05 	lds	r24, 0x05CF
    529e:	88 2f       	mov	r24, r24
    52a0:	90 e0       	ldi	r25, 0x00	; 0
    52a2:	fc 01       	movw	r30, r24
    52a4:	eb 53       	subi	r30, 0x3B	; 59
    52a6:	fa 4f       	sbci	r31, 0xFA	; 250
    52a8:	10 82       	st	Z, r1
				     			 LCD_vClear();
    52aa:	0e 94 c2 24 	call	0x4984	; 0x4984 <LCD_vClear>
				     			 LCD_vGotoxy(1,0);
    52ae:	81 e0       	ldi	r24, 0x01	; 1
    52b0:	60 e0       	ldi	r22, 0x00	; 0
    52b2:	0e 94 96 24 	call	0x492c	; 0x492c <LCD_vGotoxy>
				     			xSemaphoreGive(Syc2);
    52b6:	80 91 dc 05 	lds	r24, 0x05DC
    52ba:	90 91 dd 05 	lds	r25, 0x05DD
    52be:	60 e0       	ldi	r22, 0x00	; 0
    52c0:	70 e0       	ldi	r23, 0x00	; 0
    52c2:	40 e0       	ldi	r20, 0x00	; 0
    52c4:	50 e0       	ldi	r21, 0x00	; 0
    52c6:	20 e0       	ldi	r18, 0x00	; 0
    52c8:	0e 94 07 0e 	call	0x1c0e	; 0x1c0e <xQueueGenericSend>
				     			vTaskDelay(200);
    52cc:	88 ec       	ldi	r24, 0xC8	; 200
    52ce:	90 e0       	ldi	r25, 0x00	; 0
    52d0:	0e 94 d1 13 	call	0x27a2	; 0x27a2 <vTaskDelay>
				     			 if(flag == 1) // check password
    52d4:	80 91 d0 05 	lds	r24, 0x05D0
    52d8:	81 30       	cpi	r24, 0x01	; 1
    52da:	e1 f4       	brne	.+56     	; 0x5314 <SIGN_IN+0x11c>
				     			 {
				     			 LCD_vSendString("*Password Saved*");
    52dc:	87 e8       	ldi	r24, 0x87	; 135
    52de:	90 e0       	ldi	r25, 0x00	; 0
    52e0:	0e 94 cc 24 	call	0x4998	; 0x4998 <LCD_vSendString>
				     		    	flag=0;
    52e4:	10 92 d0 05 	sts	0x05D0, r1
				     			 vTaskDelay(250);
    52e8:	8a ef       	ldi	r24, 0xFA	; 250
    52ea:	90 e0       	ldi	r25, 0x00	; 0
    52ec:	0e 94 d1 13 	call	0x27a2	; 0x27a2 <vTaskDelay>
					     		xSemaphoreGive(Syc);
    52f0:	80 91 da 05 	lds	r24, 0x05DA
    52f4:	90 91 db 05 	lds	r25, 0x05DB
    52f8:	60 e0       	ldi	r22, 0x00	; 0
    52fa:	70 e0       	ldi	r23, 0x00	; 0
    52fc:	40 e0       	ldi	r20, 0x00	; 0
    52fe:	50 e0       	ldi	r21, 0x00	; 0
    5300:	20 e0       	ldi	r18, 0x00	; 0
    5302:	0e 94 07 0e 	call	0x1c0e	; 0x1c0e <xQueueGenericSend>
				     			vTaskDelete(SIGN);
    5306:	80 91 d6 05 	lds	r24, 0x05D6
    530a:	90 91 d7 05 	lds	r25, 0x05D7
    530e:	0e 94 fa 12 	call	0x25f4	; 0x25f4 <vTaskDelete>
    5312:	23 c0       	rjmp	.+70     	; 0x535a <SIGN_IN+0x162>

				     			 }else
				     			 {
				     				LCD_vClear();
    5314:	0e 94 c2 24 	call	0x4984	; 0x4984 <LCD_vClear>
				     				 LCD_vGotoxy(1,0);
    5318:	81 e0       	ldi	r24, 0x01	; 1
    531a:	60 e0       	ldi	r22, 0x00	; 0
    531c:	0e 94 96 24 	call	0x492c	; 0x492c <LCD_vGotoxy>
					     			 if(counter<=1)
    5320:	89 81       	ldd	r24, Y+1	; 0x01
    5322:	82 30       	cpi	r24, 0x02	; 2
    5324:	50 f4       	brcc	.+20     	; 0x533a <SIGN_IN+0x142>
					     			 {
					     				LCD_vSendString("*Wrong pass Try again*");
    5326:	88 e9       	ldi	r24, 0x98	; 152
    5328:	90 e0       	ldi	r25, 0x00	; 0
    532a:	0e 94 cc 24 	call	0x4998	; 0x4998 <LCD_vSendString>
					     				address=0;
    532e:	10 92 cf 05 	sts	0x05CF, r1
					     				counter++;
    5332:	89 81       	ldd	r24, Y+1	; 0x01
    5334:	8f 5f       	subi	r24, 0xFF	; 255
    5336:	89 83       	std	Y+1, r24	; 0x01
    5338:	40 c0       	rjmp	.+128    	; 0x53ba <SIGN_IN+0x1c2>
					     		        goto repeat;
					     			 }else
					     			 {
					     				LCD_vClear();
    533a:	0e 94 c2 24 	call	0x4984	; 0x4984 <LCD_vClear>
					     				LCD_vGotoxy(1,0);
    533e:	81 e0       	ldi	r24, 0x01	; 1
    5340:	60 e0       	ldi	r22, 0x00	; 0
    5342:	0e 94 96 24 	call	0x492c	; 0x492c <LCD_vGotoxy>
					     				LCD_vSendString("*System Locked*");
    5346:	8f ea       	ldi	r24, 0xAF	; 175
    5348:	90 e0       	ldi	r25, 0x00	; 0
    534a:	0e 94 cc 24 	call	0x4998	; 0x4998 <LCD_vSendString>
					     				vTaskDelete(SIGN);
    534e:	80 91 d6 05 	lds	r24, 0x05D6
    5352:	90 91 d7 05 	lds	r25, 0x05D7
    5356:	0e 94 fa 12 	call	0x25f4	; 0x25f4 <vTaskDelete>
					     			 }
				     			 }
				     	 }
				     	 if(*(password_desired2+address)>0)
    535a:	80 91 cf 05 	lds	r24, 0x05CF
    535e:	88 2f       	mov	r24, r24
    5360:	90 e0       	ldi	r25, 0x00	; 0
    5362:	fc 01       	movw	r30, r24
    5364:	eb 53       	subi	r30, 0x3B	; 59
    5366:	fa 4f       	sbci	r31, 0xFA	; 250
    5368:	80 81       	ld	r24, Z
    536a:	88 23       	and	r24, r24
    536c:	71 f0       	breq	.+28     	; 0x538a <SIGN_IN+0x192>
				     	{
				     		 LCD_vGotoxy(2,0+address);
    536e:	90 91 cf 05 	lds	r25, 0x05CF
    5372:	82 e0       	ldi	r24, 0x02	; 2
    5374:	69 2f       	mov	r22, r25
    5376:	0e 94 96 24 	call	0x492c	; 0x492c <LCD_vGotoxy>
				     		 LCD_vWriteChar('*');
    537a:	8a e2       	ldi	r24, 0x2A	; 42
    537c:	0e 94 d5 21 	call	0x43aa	; 0x43aa <LCD_vWriteChar>

				     		 address++;
    5380:	80 91 cf 05 	lds	r24, 0x05CF
    5384:	8f 5f       	subi	r24, 0xFF	; 255
    5386:	80 93 cf 05 	sts	0x05CF, r24

				     	}
				     	 if(address == 10 )
    538a:	80 91 cf 05 	lds	r24, 0x05CF
    538e:	8a 30       	cpi	r24, 0x0A	; 10
    5390:	a1 f4       	brne	.+40     	; 0x53ba <SIGN_IN+0x1c2>
				     		{
				     		 LCD_vClear();
    5392:	0e 94 c2 24 	call	0x4984	; 0x4984 <LCD_vClear>
				     	   LCD_vGotoxy(1,0);
    5396:	81 e0       	ldi	r24, 0x01	; 1
    5398:	60 e0       	ldi	r22, 0x00	; 0
    539a:	0e 94 96 24 	call	0x492c	; 0x492c <LCD_vGotoxy>
				     	   LCD_vSendString("Max Pass 10 Num");
    539e:	8f eb       	ldi	r24, 0xBF	; 191
    53a0:	90 e0       	ldi	r25, 0x00	; 0
    53a2:	0e 94 cc 24 	call	0x4998	; 0x4998 <LCD_vSendString>
				     	   LCD_vGotoxy(2,3);
    53a6:	82 e0       	ldi	r24, 0x02	; 2
    53a8:	63 e0       	ldi	r22, 0x03	; 3
    53aa:	0e 94 96 24 	call	0x492c	; 0x492c <LCD_vGotoxy>
				     	   LCD_vSendString(" *Try Again*");
    53ae:	8f ec       	ldi	r24, 0xCF	; 207
    53b0:	90 e0       	ldi	r25, 0x00	; 0
    53b2:	0e 94 cc 24 	call	0x4998	; 0x4998 <LCD_vSendString>
			     		     address=0;
    53b6:	10 92 cf 05 	sts	0x05CF, r1
					 LCD_vClear();
				     LCD_vGotoxy(1,0);
				     LCD_vSendString("Enter Pass Again:");
				     address=0;
				     repeat :
				     while(address<=Max_num_of_passowrd)
    53ba:	80 91 cf 05 	lds	r24, 0x05CF
    53be:	8b 30       	cpi	r24, 0x0B	; 11
    53c0:	08 f4       	brcc	.+2      	; 0x53c4 <SIGN_IN+0x1cc>
    53c2:	55 cf       	rjmp	.-342    	; 0x526e <SIGN_IN+0x76>
    53c4:	18 c0       	rjmp	.+48     	; 0x53f6 <SIGN_IN+0x1fe>

				     	   }
				     	}

				 }
				else if(*(password_desired+address)>0)
    53c6:	80 91 cf 05 	lds	r24, 0x05CF
    53ca:	88 2f       	mov	r24, r24
    53cc:	90 e0       	ldi	r25, 0x00	; 0
    53ce:	fc 01       	movw	r30, r24
    53d0:	e5 54       	subi	r30, 0x45	; 69
    53d2:	fa 4f       	sbci	r31, 0xFA	; 250
    53d4:	80 81       	ld	r24, Z
    53d6:	88 23       	and	r24, r24
    53d8:	71 f0       	breq	.+28     	; 0x53f6 <SIGN_IN+0x1fe>
				{
					LCD_vGotoxy(2,0+address);
    53da:	90 91 cf 05 	lds	r25, 0x05CF
    53de:	82 e0       	ldi	r24, 0x02	; 2
    53e0:	69 2f       	mov	r22, r25
    53e2:	0e 94 96 24 	call	0x492c	; 0x492c <LCD_vGotoxy>
					LCD_vWriteChar('*');
    53e6:	8a e2       	ldi	r24, 0x2A	; 42
    53e8:	0e 94 d5 21 	call	0x43aa	; 0x43aa <LCD_vWriteChar>

					 address++;
    53ec:	80 91 cf 05 	lds	r24, 0x05CF
    53f0:	8f 5f       	subi	r24, 0xFF	; 255
    53f2:	80 93 cf 05 	sts	0x05CF, r24

				}
				  if(address == 10 )
    53f6:	80 91 cf 05 	lds	r24, 0x05CF
    53fa:	8a 30       	cpi	r24, 0x0A	; 10
    53fc:	a1 f4       	brne	.+40     	; 0x5426 <SIGN_IN+0x22e>
				   {
					   LCD_vClear();
    53fe:	0e 94 c2 24 	call	0x4984	; 0x4984 <LCD_vClear>
					   LCD_vGotoxy(1,0);
    5402:	81 e0       	ldi	r24, 0x01	; 1
    5404:	60 e0       	ldi	r22, 0x00	; 0
    5406:	0e 94 96 24 	call	0x492c	; 0x492c <LCD_vGotoxy>
					   LCD_vSendString("Max Pass 10 Num");
    540a:	8f eb       	ldi	r24, 0xBF	; 191
    540c:	90 e0       	ldi	r25, 0x00	; 0
    540e:	0e 94 cc 24 	call	0x4998	; 0x4998 <LCD_vSendString>
					   LCD_vGotoxy(2,3);
    5412:	82 e0       	ldi	r24, 0x02	; 2
    5414:	63 e0       	ldi	r22, 0x03	; 3
    5416:	0e 94 96 24 	call	0x492c	; 0x492c <LCD_vGotoxy>
					 LCD_vSendString(" *Try Again*");
    541a:	8f ec       	ldi	r24, 0xCF	; 207
    541c:	90 e0       	ldi	r25, 0x00	; 0
    541e:	0e 94 cc 24 	call	0x4998	; 0x4998 <LCD_vSendString>

					 address=0;
    5422:	10 92 cf 05 	sts	0x05CF, r1
{
	u8 ret ;
	u8 counter=0 ;

	LCD_vSendString("Enter New Pass:");
				while(address<=Max_num_of_passowrd)
    5426:	80 91 cf 05 	lds	r24, 0x05CF
    542a:	8b 30       	cpi	r24, 0x0B	; 11
    542c:	08 f4       	brcc	.+2      	; 0x5430 <SIGN_IN+0x238>
    542e:	f4 ce       	rjmp	.-536    	; 0x5218 <SIGN_IN+0x20>

					 address=0;

				   }
				}
}
    5430:	0f 90       	pop	r0
    5432:	0f 90       	pop	r0
    5434:	0f 90       	pop	r0
    5436:	0f 90       	pop	r0
    5438:	cf 91       	pop	r28
    543a:	df 91       	pop	r29
    543c:	1f 91       	pop	r17
    543e:	0f 91       	pop	r16
    5440:	08 95       	ret

00005442 <CHECK>:


void CHECK(void *pvParmater)
{
    5442:	df 93       	push	r29
    5444:	cf 93       	push	r28
    5446:	00 d0       	rcall	.+0      	; 0x5448 <CHECK+0x6>
    5448:	00 d0       	rcall	.+0      	; 0x544a <CHECK+0x8>
    544a:	00 d0       	rcall	.+0      	; 0x544c <CHECK+0xa>
    544c:	cd b7       	in	r28, 0x3d	; 61
    544e:	de b7       	in	r29, 0x3e	; 62
    5450:	9e 83       	std	Y+6, r25	; 0x06
    5452:	8d 83       	std	Y+5, r24	; 0x05
	u8 x=0;
    5454:	1c 82       	std	Y+4, r1	; 0x04
	 u8 ret;

	for(;;)
{

 	 ret=xSemaphoreTake(Syc2,0xffff);
    5456:	80 91 dc 05 	lds	r24, 0x05DC
    545a:	90 91 dd 05 	lds	r25, 0x05DD
    545e:	60 e0       	ldi	r22, 0x00	; 0
    5460:	70 e0       	ldi	r23, 0x00	; 0
    5462:	4f ef       	ldi	r20, 0xFF	; 255
    5464:	5f ef       	ldi	r21, 0xFF	; 255
    5466:	20 e0       	ldi	r18, 0x00	; 0
    5468:	0e 94 f2 0e 	call	0x1de4	; 0x1de4 <xQueueGenericReceive>
    546c:	8b 83       	std	Y+3, r24	; 0x03
 	 if(ret == 1 )
    546e:	8b 81       	ldd	r24, Y+3	; 0x03
    5470:	81 30       	cpi	r24, 0x01	; 1
    5472:	89 f7       	brne	.-30     	; 0x5456 <CHECK+0x14>
 	  {

 	 	 for (int i = 0; i < Max_num_of_passowrd; i++)
    5474:	1a 82       	std	Y+2, r1	; 0x02
    5476:	19 82       	std	Y+1, r1	; 0x01
    5478:	22 c0       	rjmp	.+68     	; 0x54be <CHECK+0x7c>
		 {
		        if (password_desired[i] == password_desired2[i])
    547a:	89 81       	ldd	r24, Y+1	; 0x01
    547c:	9a 81       	ldd	r25, Y+2	; 0x02
    547e:	fc 01       	movw	r30, r24
    5480:	e5 54       	subi	r30, 0x45	; 69
    5482:	fa 4f       	sbci	r31, 0xFA	; 250
    5484:	20 81       	ld	r18, Z
    5486:	89 81       	ldd	r24, Y+1	; 0x01
    5488:	9a 81       	ldd	r25, Y+2	; 0x02
    548a:	fc 01       	movw	r30, r24
    548c:	eb 53       	subi	r30, 0x3B	; 59
    548e:	fa 4f       	sbci	r31, 0xFA	; 250
    5490:	80 81       	ld	r24, Z
    5492:	28 17       	cp	r18, r24
    5494:	51 f4       	brne	.+20     	; 0x54aa <CHECK+0x68>
		        {
		        	++x;
    5496:	8c 81       	ldd	r24, Y+4	; 0x04
    5498:	8f 5f       	subi	r24, 0xFF	; 255
    549a:	8c 83       	std	Y+4, r24	; 0x04
		        	if(x == Max_num_of_passowrd)
    549c:	8c 81       	ldd	r24, Y+4	; 0x04
    549e:	8a 30       	cpi	r24, 0x0A	; 10
    54a0:	49 f4       	brne	.+18     	; 0x54b4 <CHECK+0x72>
		        	{

		       	     flag=1;
    54a2:	81 e0       	ldi	r24, 0x01	; 1
    54a4:	80 93 d0 05 	sts	0x05D0, r24
    54a8:	05 c0       	rjmp	.+10     	; 0x54b4 <CHECK+0x72>

		        	}

		        }else
		        {
		        	PORTB=0x00;
    54aa:	e8 e3       	ldi	r30, 0x38	; 56
    54ac:	f0 e0       	ldi	r31, 0x00	; 0
    54ae:	10 82       	st	Z, r1
		        	 flag=0;
    54b0:	10 92 d0 05 	sts	0x05D0, r1

 	 ret=xSemaphoreTake(Syc2,0xffff);
 	 if(ret == 1 )
 	  {

 	 	 for (int i = 0; i < Max_num_of_passowrd; i++)
    54b4:	89 81       	ldd	r24, Y+1	; 0x01
    54b6:	9a 81       	ldd	r25, Y+2	; 0x02
    54b8:	01 96       	adiw	r24, 0x01	; 1
    54ba:	9a 83       	std	Y+2, r25	; 0x02
    54bc:	89 83       	std	Y+1, r24	; 0x01
    54be:	89 81       	ldd	r24, Y+1	; 0x01
    54c0:	9a 81       	ldd	r25, Y+2	; 0x02
    54c2:	8a 30       	cpi	r24, 0x0A	; 10
    54c4:	91 05       	cpc	r25, r1
    54c6:	cc f2       	brlt	.-78     	; 0x547a <CHECK+0x38>
		        {
		        	PORTB=0x00;
		        	 flag=0;
		        }
		   }
 	 	 x=0;
    54c8:	1c 82       	std	Y+4, r1	; 0x04
    54ca:	c5 cf       	rjmp	.-118    	; 0x5456 <CHECK+0x14>

000054cc <LOG_IN>:
}



void LOG_IN(void *pvParmater)
{
    54cc:	0f 93       	push	r16
    54ce:	1f 93       	push	r17
    54d0:	df 93       	push	r29
    54d2:	cf 93       	push	r28
    54d4:	00 d0       	rcall	.+0      	; 0x54d6 <LOG_IN+0xa>
    54d6:	00 d0       	rcall	.+0      	; 0x54d8 <LOG_IN+0xc>
    54d8:	0f 92       	push	r0
    54da:	cd b7       	in	r28, 0x3d	; 61
    54dc:	de b7       	in	r29, 0x3e	; 62
    54de:	9d 83       	std	Y+5, r25	; 0x05
    54e0:	8c 83       	std	Y+4, r24	; 0x04
	u8 counter=0 ;
    54e2:	1b 82       	std	Y+3, r1	; 0x03
	u8 ret;
for(u8 i=0 ;i<10;i++)
    54e4:	19 82       	std	Y+1, r1	; 0x01
    54e6:	0a c0       	rjmp	.+20     	; 0x54fc <LOG_IN+0x30>
{
	*(password_desired2+i)=0;
    54e8:	89 81       	ldd	r24, Y+1	; 0x01
    54ea:	88 2f       	mov	r24, r24
    54ec:	90 e0       	ldi	r25, 0x00	; 0
    54ee:	fc 01       	movw	r30, r24
    54f0:	eb 53       	subi	r30, 0x3B	; 59
    54f2:	fa 4f       	sbci	r31, 0xFA	; 250
    54f4:	10 82       	st	Z, r1

void LOG_IN(void *pvParmater)
{
	u8 counter=0 ;
	u8 ret;
for(u8 i=0 ;i<10;i++)
    54f6:	89 81       	ldd	r24, Y+1	; 0x01
    54f8:	8f 5f       	subi	r24, 0xFF	; 255
    54fa:	89 83       	std	Y+1, r24	; 0x01
    54fc:	89 81       	ldd	r24, Y+1	; 0x01
    54fe:	8a 30       	cpi	r24, 0x0A	; 10
    5500:	98 f3       	brcs	.-26     	; 0x54e8 <LOG_IN+0x1c>
}

	for(;;)
{

	    	address=0;
    5502:	10 92 cf 05 	sts	0x05CF, r1
		 ret=xSemaphoreTake(Syc,0xffff);
    5506:	80 91 da 05 	lds	r24, 0x05DA
    550a:	90 91 db 05 	lds	r25, 0x05DB
    550e:	60 e0       	ldi	r22, 0x00	; 0
    5510:	70 e0       	ldi	r23, 0x00	; 0
    5512:	4f ef       	ldi	r20, 0xFF	; 255
    5514:	5f ef       	ldi	r21, 0xFF	; 255
    5516:	20 e0       	ldi	r18, 0x00	; 0
    5518:	0e 94 f2 0e 	call	0x1de4	; 0x1de4 <xQueueGenericReceive>
    551c:	8a 83       	std	Y+2, r24	; 0x02
		 if(ret == 1)
    551e:	8a 81       	ldd	r24, Y+2	; 0x02
    5520:	81 30       	cpi	r24, 0x01	; 1
    5522:	79 f7       	brne	.-34     	; 0x5502 <LOG_IN+0x36>
		 {

		   LCD_vClear();
    5524:	0e 94 c2 24 	call	0x4984	; 0x4984 <LCD_vClear>
		   LCD_vGotoxy(1,0);
    5528:	81 e0       	ldi	r24, 0x01	; 1
    552a:	60 e0       	ldi	r22, 0x00	; 0
    552c:	0e 94 96 24 	call	0x492c	; 0x492c <LCD_vGotoxy>
		   LCD_vSendString("LOGIN :");
    5530:	8c ed       	ldi	r24, 0xDC	; 220
    5532:	90 e0       	ldi	r25, 0x00	; 0
    5534:	0e 94 cc 24 	call	0x4998	; 0x4998 <LCD_vSendString>
    5538:	d6 c0       	rjmp	.+428    	; 0x56e6 <LOG_IN+0x21a>
		   repeat :
		   while(address<=Max_num_of_passowrd)
		  	{

			    *(password_desired2+address)=Keybad_getpressed(); // assign numbers into array2
    553a:	80 91 cf 05 	lds	r24, 0x05CF
    553e:	88 2f       	mov	r24, r24
    5540:	90 e0       	ldi	r25, 0x00	; 0
    5542:	8c 01       	movw	r16, r24
    5544:	0b 53       	subi	r16, 0x3B	; 59
    5546:	1a 4f       	sbci	r17, 0xFA	; 250
    5548:	0e 94 89 27 	call	0x4f12	; 0x4f12 <Keybad_getpressed>
    554c:	f8 01       	movw	r30, r16
    554e:	80 83       	st	Z, r24
		  		if(*(password_desired2+address) == '=')
    5550:	80 91 cf 05 	lds	r24, 0x05CF
    5554:	88 2f       	mov	r24, r24
    5556:	90 e0       	ldi	r25, 0x00	; 0
    5558:	fc 01       	movw	r30, r24
    555a:	eb 53       	subi	r30, 0x3B	; 59
    555c:	fa 4f       	sbci	r31, 0xFA	; 250
    555e:	80 81       	ld	r24, Z
    5560:	8d 33       	cpi	r24, 0x3D	; 61
    5562:	09 f0       	breq	.+2      	; 0x5566 <LOG_IN+0x9a>
    5564:	90 c0       	rjmp	.+288    	; 0x5686 <LOG_IN+0x1ba>
		  		{
		  		  *(password_desired2+address)=0;
    5566:	80 91 cf 05 	lds	r24, 0x05CF
    556a:	88 2f       	mov	r24, r24
    556c:	90 e0       	ldi	r25, 0x00	; 0
    556e:	fc 01       	movw	r30, r24
    5570:	eb 53       	subi	r30, 0x3B	; 59
    5572:	fa 4f       	sbci	r31, 0xFA	; 250
    5574:	10 82       	st	Z, r1
		  			LCD_vClear();
    5576:	0e 94 c2 24 	call	0x4984	; 0x4984 <LCD_vClear>
		  			LCD_vGotoxy(1,0);
    557a:	81 e0       	ldi	r24, 0x01	; 1
    557c:	60 e0       	ldi	r22, 0x00	; 0
    557e:	0e 94 96 24 	call	0x492c	; 0x492c <LCD_vGotoxy>
		  			xSemaphoreGive(Syc2);
    5582:	80 91 dc 05 	lds	r24, 0x05DC
    5586:	90 91 dd 05 	lds	r25, 0x05DD
    558a:	60 e0       	ldi	r22, 0x00	; 0
    558c:	70 e0       	ldi	r23, 0x00	; 0
    558e:	40 e0       	ldi	r20, 0x00	; 0
    5590:	50 e0       	ldi	r21, 0x00	; 0
    5592:	20 e0       	ldi	r18, 0x00	; 0
    5594:	0e 94 07 0e 	call	0x1c0e	; 0x1c0e <xQueueGenericSend>
		  			vTaskDelay(200);
    5598:	88 ec       	ldi	r24, 0xC8	; 200
    559a:	90 e0       	ldi	r25, 0x00	; 0
    559c:	0e 94 d1 13 	call	0x27a2	; 0x27a2 <vTaskDelay>
		  			 if(flag == 1) // check password
    55a0:	80 91 d0 05 	lds	r24, 0x05D0
    55a4:	81 30       	cpi	r24, 0x01	; 1
    55a6:	09 f0       	breq	.+2      	; 0x55aa <LOG_IN+0xde>
    55a8:	51 c0       	rjmp	.+162    	; 0x564c <LOG_IN+0x180>
		  			 {	LCD_vClear();
    55aa:	0e 94 c2 24 	call	0x4984	; 0x4984 <LCD_vClear>
		  				LCD_vGotoxy(1,0);
    55ae:	81 e0       	ldi	r24, 0x01	; 1
    55b0:	60 e0       	ldi	r22, 0x00	; 0
    55b2:	0e 94 96 24 	call	0x492c	; 0x492c <LCD_vGotoxy>
		  			   LCD_vSendString("*Welcome*");
    55b6:	84 ee       	ldi	r24, 0xE4	; 228
    55b8:	90 e0       	ldi	r25, 0x00	; 0
    55ba:	0e 94 cc 24 	call	0x4998	; 0x4998 <LCD_vSendString>
		  		    	 vTaskDelay(350);
    55be:	8e e5       	ldi	r24, 0x5E	; 94
    55c0:	91 e0       	ldi	r25, 0x01	; 1
    55c2:	0e 94 d1 13 	call	0x27a2	; 0x27a2 <vTaskDelay>
		  		    	 flag=0;
    55c6:	10 92 d0 05 	sts	0x05D0, r1

		  		    	LCD_vClear();
    55ca:	0e 94 c2 24 	call	0x4984	; 0x4984 <LCD_vClear>
		  		    	LCD_vGotoxy(1,0);
    55ce:	81 e0       	ldi	r24, 0x01	; 1
    55d0:	60 e0       	ldi	r22, 0x00	; 0
    55d2:	0e 94 96 24 	call	0x492c	; 0x492c <LCD_vGotoxy>
		  		       LCD_vSendString("1.Light LEDS ");
    55d6:	8e ee       	ldi	r24, 0xEE	; 238
    55d8:	90 e0       	ldi	r25, 0x00	; 0
    55da:	0e 94 cc 24 	call	0x4998	; 0x4998 <LCD_vSendString>
		  		       	 LCD_vGotoxy(2,0);
    55de:	82 e0       	ldi	r24, 0x02	; 2
    55e0:	60 e0       	ldi	r22, 0x00	; 0
    55e2:	0e 94 96 24 	call	0x492c	; 0x492c <LCD_vGotoxy>
		  		       LCD_vSendString("2.OPEN DOOR ");
    55e6:	8c ef       	ldi	r24, 0xFC	; 252
    55e8:	90 e0       	ldi	r25, 0x00	; 0
    55ea:	0e 94 cc 24 	call	0x4998	; 0x4998 <LCD_vSendString>
		  		     reapet2 :
		  		     *(choose)=Keybad_getpressed();
    55ee:	0e 94 89 27 	call	0x4f12	; 0x4f12 <Keybad_getpressed>
    55f2:	80 93 d1 05 	sts	0x05D1, r24
		  		 	 vTaskDelay(200);
    55f6:	88 ec       	ldi	r24, 0xC8	; 200
    55f8:	90 e0       	ldi	r25, 0x00	; 0
    55fa:	0e 94 d1 13 	call	0x27a2	; 0x27a2 <vTaskDelay>
		  		   if (*(choose)== 49)
    55fe:	80 91 d1 05 	lds	r24, 0x05D1
    5602:	81 33       	cpi	r24, 0x31	; 49
    5604:	79 f4       	brne	.+30     	; 0x5624 <LOG_IN+0x158>
		  		   {
				     	xSemaphoreGive(TASK);
    5606:	80 91 d8 05 	lds	r24, 0x05D8
    560a:	90 91 d9 05 	lds	r25, 0x05D9
    560e:	60 e0       	ldi	r22, 0x00	; 0
    5610:	70 e0       	ldi	r23, 0x00	; 0
    5612:	40 e0       	ldi	r20, 0x00	; 0
    5614:	50 e0       	ldi	r21, 0x00	; 0
    5616:	20 e0       	ldi	r18, 0x00	; 0
    5618:	0e 94 07 0e 	call	0x1c0e	; 0x1c0e <xQueueGenericSend>
		  		       	vTaskDelay(200);
    561c:	88 ec       	ldi	r24, 0xC8	; 200
    561e:	90 e0       	ldi	r25, 0x00	; 0
    5620:	0e 94 d1 13 	call	0x27a2	; 0x27a2 <vTaskDelay>
		  		   }
		  		       	   if (*(choose) == 50)
    5624:	80 91 d1 05 	lds	r24, 0x05D1
    5628:	82 33       	cpi	r24, 0x32	; 50
    562a:	09 f7       	brne	.-62     	; 0x55ee <LOG_IN+0x122>
		  		       	  {
		  		       		xSemaphoreGive(TASK2);
    562c:	80 91 d2 05 	lds	r24, 0x05D2
    5630:	90 91 d3 05 	lds	r25, 0x05D3
    5634:	60 e0       	ldi	r22, 0x00	; 0
    5636:	70 e0       	ldi	r23, 0x00	; 0
    5638:	40 e0       	ldi	r20, 0x00	; 0
    563a:	50 e0       	ldi	r21, 0x00	; 0
    563c:	20 e0       	ldi	r18, 0x00	; 0
    563e:	0e 94 07 0e 	call	0x1c0e	; 0x1c0e <xQueueGenericSend>
		  		       		vTaskDelay(200);
    5642:	88 ec       	ldi	r24, 0xC8	; 200
    5644:	90 e0       	ldi	r25, 0x00	; 0
    5646:	0e 94 d1 13 	call	0x27a2	; 0x27a2 <vTaskDelay>
    564a:	d1 cf       	rjmp	.-94     	; 0x55ee <LOG_IN+0x122>
		  		       	  }

		  		       	  goto reapet2;
		  			 }else
		  			{
		  				LCD_vClear();
    564c:	0e 94 c2 24 	call	0x4984	; 0x4984 <LCD_vClear>
		  				LCD_vGotoxy(1,0);
    5650:	81 e0       	ldi	r24, 0x01	; 1
    5652:	60 e0       	ldi	r22, 0x00	; 0
    5654:	0e 94 96 24 	call	0x492c	; 0x492c <LCD_vGotoxy>
		  				 if(counter<=1)
    5658:	8b 81       	ldd	r24, Y+3	; 0x03
    565a:	82 30       	cpi	r24, 0x02	; 2
    565c:	50 f4       	brcc	.+20     	; 0x5672 <LOG_IN+0x1a6>
		  				 {
		  				LCD_vSendString("*Wrong Password:");
    565e:	89 e0       	ldi	r24, 0x09	; 9
    5660:	91 e0       	ldi	r25, 0x01	; 1
    5662:	0e 94 cc 24 	call	0x4998	; 0x4998 <LCD_vSendString>
		  				address=0;
    5666:	10 92 cf 05 	sts	0x05CF, r1
		  			   counter++;
    566a:	8b 81       	ldd	r24, Y+3	; 0x03
    566c:	8f 5f       	subi	r24, 0xFF	; 255
    566e:	8b 83       	std	Y+3, r24	; 0x03
    5670:	3a c0       	rjmp	.+116    	; 0x56e6 <LOG_IN+0x21a>
		  				goto repeat;
		  		      }else
		  		     	{
		  					 LCD_vClear();
    5672:	0e 94 c2 24 	call	0x4984	; 0x4984 <LCD_vClear>
		  					   LCD_vGotoxy(1,0);
    5676:	81 e0       	ldi	r24, 0x01	; 1
    5678:	60 e0       	ldi	r22, 0x00	; 0
    567a:	0e 94 96 24 	call	0x492c	; 0x492c <LCD_vGotoxy>
		  					   LCD_vSendString("*System Locked*");
    567e:	8f ea       	ldi	r24, 0xAF	; 175
    5680:	90 e0       	ldi	r25, 0x00	; 0
    5682:	0e 94 cc 24 	call	0x4998	; 0x4998 <LCD_vSendString>
		  			    }
		  			 }
		  	      }
		  				 	 if(*(password_desired2+address)>0)
    5686:	80 91 cf 05 	lds	r24, 0x05CF
    568a:	88 2f       	mov	r24, r24
    568c:	90 e0       	ldi	r25, 0x00	; 0
    568e:	fc 01       	movw	r30, r24
    5690:	eb 53       	subi	r30, 0x3B	; 59
    5692:	fa 4f       	sbci	r31, 0xFA	; 250
    5694:	80 81       	ld	r24, Z
    5696:	88 23       	and	r24, r24
    5698:	71 f0       	breq	.+28     	; 0x56b6 <LOG_IN+0x1ea>
		  				     	{
		  				     		 LCD_vGotoxy(2,0+address);
    569a:	90 91 cf 05 	lds	r25, 0x05CF
    569e:	82 e0       	ldi	r24, 0x02	; 2
    56a0:	69 2f       	mov	r22, r25
    56a2:	0e 94 96 24 	call	0x492c	; 0x492c <LCD_vGotoxy>
		  				     		 LCD_vWriteChar('*');
    56a6:	8a e2       	ldi	r24, 0x2A	; 42
    56a8:	0e 94 d5 21 	call	0x43aa	; 0x43aa <LCD_vWriteChar>

		  				     		 address++;
    56ac:	80 91 cf 05 	lds	r24, 0x05CF
    56b0:	8f 5f       	subi	r24, 0xFF	; 255
    56b2:	80 93 cf 05 	sts	0x05CF, r24

		  				     	}
		  				     	 if(address == 10 )
    56b6:	80 91 cf 05 	lds	r24, 0x05CF
    56ba:	8a 30       	cpi	r24, 0x0A	; 10
    56bc:	a1 f4       	brne	.+40     	; 0x56e6 <LOG_IN+0x21a>
		  				     		{
		  				     		 LCD_vClear();
    56be:	0e 94 c2 24 	call	0x4984	; 0x4984 <LCD_vClear>
		  				     	   LCD_vGotoxy(1,0);
    56c2:	81 e0       	ldi	r24, 0x01	; 1
    56c4:	60 e0       	ldi	r22, 0x00	; 0
    56c6:	0e 94 96 24 	call	0x492c	; 0x492c <LCD_vGotoxy>
		  				     	   LCD_vSendString("Max Pass 10 Num");
    56ca:	8f eb       	ldi	r24, 0xBF	; 191
    56cc:	90 e0       	ldi	r25, 0x00	; 0
    56ce:	0e 94 cc 24 	call	0x4998	; 0x4998 <LCD_vSendString>
		  				     	   LCD_vGotoxy(2,3);
    56d2:	82 e0       	ldi	r24, 0x02	; 2
    56d4:	63 e0       	ldi	r22, 0x03	; 3
    56d6:	0e 94 96 24 	call	0x492c	; 0x492c <LCD_vGotoxy>
		  				     	   LCD_vSendString(" *Try Again*");
    56da:	8f ec       	ldi	r24, 0xCF	; 207
    56dc:	90 e0       	ldi	r25, 0x00	; 0
    56de:	0e 94 cc 24 	call	0x4998	; 0x4998 <LCD_vSendString>
		  			     		     address=0;
    56e2:	10 92 cf 05 	sts	0x05CF, r1

		   LCD_vClear();
		   LCD_vGotoxy(1,0);
		   LCD_vSendString("LOGIN :");
		   repeat :
		   while(address<=Max_num_of_passowrd)
    56e6:	80 91 cf 05 	lds	r24, 0x05CF
    56ea:	8b 30       	cpi	r24, 0x0B	; 11
    56ec:	08 f4       	brcc	.+2      	; 0x56f0 <LOG_IN+0x224>
    56ee:	25 cf       	rjmp	.-438    	; 0x553a <LOG_IN+0x6e>
    56f0:	08 cf       	rjmp	.-496    	; 0x5502 <LOG_IN+0x36>

000056f2 <Motor>:
}

}

void Motor(void *pvParmater)
{
    56f2:	df 93       	push	r29
    56f4:	cf 93       	push	r28
    56f6:	00 d0       	rcall	.+0      	; 0x56f8 <Motor+0x6>
    56f8:	0f 92       	push	r0
    56fa:	cd b7       	in	r28, 0x3d	; 61
    56fc:	de b7       	in	r29, 0x3e	; 62
    56fe:	9b 83       	std	Y+3, r25	; 0x03
    5700:	8a 83       	std	Y+2, r24	; 0x02

	u8 ret;

for(;;)
{
	 ret=xSemaphoreTake(TASK2,0xffff);
    5702:	80 91 d2 05 	lds	r24, 0x05D2
    5706:	90 91 d3 05 	lds	r25, 0x05D3
    570a:	60 e0       	ldi	r22, 0x00	; 0
    570c:	70 e0       	ldi	r23, 0x00	; 0
    570e:	4f ef       	ldi	r20, 0xFF	; 255
    5710:	5f ef       	ldi	r21, 0xFF	; 255
    5712:	20 e0       	ldi	r18, 0x00	; 0
    5714:	0e 94 f2 0e 	call	0x1de4	; 0x1de4 <xQueueGenericReceive>
    5718:	89 83       	std	Y+1, r24	; 0x01
	 if(ret == 1)
    571a:	89 81       	ldd	r24, Y+1	; 0x01
    571c:	81 30       	cpi	r24, 0x01	; 1
    571e:	89 f7       	brne	.-30     	; 0x5702 <Motor+0x10>
	 {

		DIO_vWritePin(PORT_A,0,HIGH);
    5720:	80 e0       	ldi	r24, 0x00	; 0
    5722:	60 e0       	ldi	r22, 0x00	; 0
    5724:	41 e0       	ldi	r20, 0x01	; 1
    5726:	0e 94 04 1c 	call	0x3808	; 0x3808 <DIO_vWritePin>
		 vTaskDelay(5000);
    572a:	88 e8       	ldi	r24, 0x88	; 136
    572c:	93 e1       	ldi	r25, 0x13	; 19
    572e:	0e 94 d1 13 	call	0x27a2	; 0x27a2 <vTaskDelay>
			DIO_vWritePin(PORT_A,0,LOW);
    5732:	80 e0       	ldi	r24, 0x00	; 0
    5734:	60 e0       	ldi	r22, 0x00	; 0
    5736:	40 e0       	ldi	r20, 0x00	; 0
    5738:	0e 94 04 1c 	call	0x3808	; 0x3808 <DIO_vWritePin>
    573c:	e2 cf       	rjmp	.-60     	; 0x5702 <Motor+0x10>

0000573e <LEDS>:

}
}

void LEDS(void *pvParmater)
{
    573e:	df 93       	push	r29
    5740:	cf 93       	push	r28
    5742:	00 d0       	rcall	.+0      	; 0x5744 <LEDS+0x6>
    5744:	00 d0       	rcall	.+0      	; 0x5746 <LEDS+0x8>
    5746:	cd b7       	in	r28, 0x3d	; 61
    5748:	de b7       	in	r29, 0x3e	; 62
    574a:	9c 83       	std	Y+4, r25	; 0x04
    574c:	8b 83       	std	Y+3, r24	; 0x03

	u8 ret;

for(;;)
{
	 ret=xSemaphoreTake(TASK,0xffff);
    574e:	80 91 d8 05 	lds	r24, 0x05D8
    5752:	90 91 d9 05 	lds	r25, 0x05D9
    5756:	60 e0       	ldi	r22, 0x00	; 0
    5758:	70 e0       	ldi	r23, 0x00	; 0
    575a:	4f ef       	ldi	r20, 0xFF	; 255
    575c:	5f ef       	ldi	r21, 0xFF	; 255
    575e:	20 e0       	ldi	r18, 0x00	; 0
    5760:	0e 94 f2 0e 	call	0x1de4	; 0x1de4 <xQueueGenericReceive>
    5764:	8a 83       	std	Y+2, r24	; 0x02
if(ret == 1)
    5766:	8a 81       	ldd	r24, Y+2	; 0x02
    5768:	81 30       	cpi	r24, 0x01	; 1
    576a:	89 f7       	brne	.-30     	; 0x574e <LEDS+0x10>
{

		for(u8 i=0 ;i < 7 ;i++)
    576c:	19 82       	std	Y+1, r1	; 0x01
    576e:	14 c0       	rjmp	.+40     	; 0x5798 <LEDS+0x5a>
		  {
			 PORTB=(1<<i);
    5770:	e8 e3       	ldi	r30, 0x38	; 56
    5772:	f0 e0       	ldi	r31, 0x00	; 0
    5774:	89 81       	ldd	r24, Y+1	; 0x01
    5776:	28 2f       	mov	r18, r24
    5778:	30 e0       	ldi	r19, 0x00	; 0
    577a:	81 e0       	ldi	r24, 0x01	; 1
    577c:	90 e0       	ldi	r25, 0x00	; 0
    577e:	02 c0       	rjmp	.+4      	; 0x5784 <LEDS+0x46>
    5780:	88 0f       	add	r24, r24
    5782:	99 1f       	adc	r25, r25
    5784:	2a 95       	dec	r18
    5786:	e2 f7       	brpl	.-8      	; 0x5780 <LEDS+0x42>
    5788:	80 83       	st	Z, r24
			 vTaskDelay(250);
    578a:	8a ef       	ldi	r24, 0xFA	; 250
    578c:	90 e0       	ldi	r25, 0x00	; 0
    578e:	0e 94 d1 13 	call	0x27a2	; 0x27a2 <vTaskDelay>
{
	 ret=xSemaphoreTake(TASK,0xffff);
if(ret == 1)
{

		for(u8 i=0 ;i < 7 ;i++)
    5792:	89 81       	ldd	r24, Y+1	; 0x01
    5794:	8f 5f       	subi	r24, 0xFF	; 255
    5796:	89 83       	std	Y+1, r24	; 0x01
    5798:	89 81       	ldd	r24, Y+1	; 0x01
    579a:	87 30       	cpi	r24, 0x07	; 7
    579c:	48 f3       	brcs	.-46     	; 0x5770 <LEDS+0x32>
    579e:	d7 cf       	rjmp	.-82     	; 0x574e <LEDS+0x10>

000057a0 <__udivmodqi4>:
    57a0:	99 1b       	sub	r25, r25
    57a2:	79 e0       	ldi	r23, 0x09	; 9
    57a4:	04 c0       	rjmp	.+8      	; 0x57ae <__udivmodqi4_ep>

000057a6 <__udivmodqi4_loop>:
    57a6:	99 1f       	adc	r25, r25
    57a8:	96 17       	cp	r25, r22
    57aa:	08 f0       	brcs	.+2      	; 0x57ae <__udivmodqi4_ep>
    57ac:	96 1b       	sub	r25, r22

000057ae <__udivmodqi4_ep>:
    57ae:	88 1f       	adc	r24, r24
    57b0:	7a 95       	dec	r23
    57b2:	c9 f7       	brne	.-14     	; 0x57a6 <__udivmodqi4_loop>
    57b4:	80 95       	com	r24
    57b6:	08 95       	ret

000057b8 <__udivmodhi4>:
    57b8:	aa 1b       	sub	r26, r26
    57ba:	bb 1b       	sub	r27, r27
    57bc:	51 e1       	ldi	r21, 0x11	; 17
    57be:	07 c0       	rjmp	.+14     	; 0x57ce <__udivmodhi4_ep>

000057c0 <__udivmodhi4_loop>:
    57c0:	aa 1f       	adc	r26, r26
    57c2:	bb 1f       	adc	r27, r27
    57c4:	a6 17       	cp	r26, r22
    57c6:	b7 07       	cpc	r27, r23
    57c8:	10 f0       	brcs	.+4      	; 0x57ce <__udivmodhi4_ep>
    57ca:	a6 1b       	sub	r26, r22
    57cc:	b7 0b       	sbc	r27, r23

000057ce <__udivmodhi4_ep>:
    57ce:	88 1f       	adc	r24, r24
    57d0:	99 1f       	adc	r25, r25
    57d2:	5a 95       	dec	r21
    57d4:	a9 f7       	brne	.-22     	; 0x57c0 <__udivmodhi4_loop>
    57d6:	80 95       	com	r24
    57d8:	90 95       	com	r25
    57da:	bc 01       	movw	r22, r24
    57dc:	cd 01       	movw	r24, r26
    57de:	08 95       	ret

000057e0 <__prologue_saves__>:
    57e0:	2f 92       	push	r2
    57e2:	3f 92       	push	r3
    57e4:	4f 92       	push	r4
    57e6:	5f 92       	push	r5
    57e8:	6f 92       	push	r6
    57ea:	7f 92       	push	r7
    57ec:	8f 92       	push	r8
    57ee:	9f 92       	push	r9
    57f0:	af 92       	push	r10
    57f2:	bf 92       	push	r11
    57f4:	cf 92       	push	r12
    57f6:	df 92       	push	r13
    57f8:	ef 92       	push	r14
    57fa:	ff 92       	push	r15
    57fc:	0f 93       	push	r16
    57fe:	1f 93       	push	r17
    5800:	cf 93       	push	r28
    5802:	df 93       	push	r29
    5804:	cd b7       	in	r28, 0x3d	; 61
    5806:	de b7       	in	r29, 0x3e	; 62
    5808:	ca 1b       	sub	r28, r26
    580a:	db 0b       	sbc	r29, r27
    580c:	0f b6       	in	r0, 0x3f	; 63
    580e:	f8 94       	cli
    5810:	de bf       	out	0x3e, r29	; 62
    5812:	0f be       	out	0x3f, r0	; 63
    5814:	cd bf       	out	0x3d, r28	; 61
    5816:	09 94       	ijmp

00005818 <__epilogue_restores__>:
    5818:	2a 88       	ldd	r2, Y+18	; 0x12
    581a:	39 88       	ldd	r3, Y+17	; 0x11
    581c:	48 88       	ldd	r4, Y+16	; 0x10
    581e:	5f 84       	ldd	r5, Y+15	; 0x0f
    5820:	6e 84       	ldd	r6, Y+14	; 0x0e
    5822:	7d 84       	ldd	r7, Y+13	; 0x0d
    5824:	8c 84       	ldd	r8, Y+12	; 0x0c
    5826:	9b 84       	ldd	r9, Y+11	; 0x0b
    5828:	aa 84       	ldd	r10, Y+10	; 0x0a
    582a:	b9 84       	ldd	r11, Y+9	; 0x09
    582c:	c8 84       	ldd	r12, Y+8	; 0x08
    582e:	df 80       	ldd	r13, Y+7	; 0x07
    5830:	ee 80       	ldd	r14, Y+6	; 0x06
    5832:	fd 80       	ldd	r15, Y+5	; 0x05
    5834:	0c 81       	ldd	r16, Y+4	; 0x04
    5836:	1b 81       	ldd	r17, Y+3	; 0x03
    5838:	aa 81       	ldd	r26, Y+2	; 0x02
    583a:	b9 81       	ldd	r27, Y+1	; 0x01
    583c:	ce 0f       	add	r28, r30
    583e:	d1 1d       	adc	r29, r1
    5840:	0f b6       	in	r0, 0x3f	; 63
    5842:	f8 94       	cli
    5844:	de bf       	out	0x3e, r29	; 62
    5846:	0f be       	out	0x3f, r0	; 63
    5848:	cd bf       	out	0x3d, r28	; 61
    584a:	ed 01       	movw	r28, r26
    584c:	08 95       	ret

0000584e <memcpy>:
    584e:	fb 01       	movw	r30, r22
    5850:	dc 01       	movw	r26, r24
    5852:	02 c0       	rjmp	.+4      	; 0x5858 <memcpy+0xa>
    5854:	01 90       	ld	r0, Z+
    5856:	0d 92       	st	X+, r0
    5858:	41 50       	subi	r20, 0x01	; 1
    585a:	50 40       	sbci	r21, 0x00	; 0
    585c:	d8 f7       	brcc	.-10     	; 0x5854 <memcpy+0x6>
    585e:	08 95       	ret

00005860 <memset>:
    5860:	dc 01       	movw	r26, r24
    5862:	01 c0       	rjmp	.+2      	; 0x5866 <memset+0x6>
    5864:	6d 93       	st	X+, r22
    5866:	41 50       	subi	r20, 0x01	; 1
    5868:	50 40       	sbci	r21, 0x00	; 0
    586a:	e0 f7       	brcc	.-8      	; 0x5864 <memset+0x4>
    586c:	08 95       	ret

0000586e <strncpy>:
    586e:	fb 01       	movw	r30, r22
    5870:	dc 01       	movw	r26, r24
    5872:	41 50       	subi	r20, 0x01	; 1
    5874:	50 40       	sbci	r21, 0x00	; 0
    5876:	48 f0       	brcs	.+18     	; 0x588a <strncpy+0x1c>
    5878:	01 90       	ld	r0, Z+
    587a:	0d 92       	st	X+, r0
    587c:	00 20       	and	r0, r0
    587e:	c9 f7       	brne	.-14     	; 0x5872 <strncpy+0x4>
    5880:	01 c0       	rjmp	.+2      	; 0x5884 <strncpy+0x16>
    5882:	1d 92       	st	X+, r1
    5884:	41 50       	subi	r20, 0x01	; 1
    5886:	50 40       	sbci	r21, 0x00	; 0
    5888:	e0 f7       	brcc	.-8      	; 0x5882 <strncpy+0x14>
    588a:	08 95       	ret

0000588c <_exit>:
    588c:	f8 94       	cli

0000588e <__stop_program>:
    588e:	ff cf       	rjmp	.-2      	; 0x588e <__stop_program>
